{"./fagus/fagus.py": "\"\"\"Base-module that contains the :obj:`~fagus.Fagus`-class\"\"\"\n\n\nimport copy as cp\nfrom collections.abc import (\n    Collection,\n    Mapping,\n    Sequence,\n    Set,\n    MutableMapping,\n    MutableSequence,\n    Reversible,\n    Iterable,\n    MutableSet,\n    Container,\n)\nfrom datetime import datetime, date, time\nfrom typing import Union, Tuple, Any, Optional, List, Callable\n\nfrom .utils import (\n    FagusMeta,\n    _None,\n    INF,\n    _filter_r,\n    _copy_node,\n    _is,\n    _copy_any,\n)\nfrom .filters import Fil\nfrom .iterators import FagusIterator\n\n\nclass Fagus(MutableMapping, MutableSequence, MutableSet, metaclass=FagusMeta):\n    \"\"\"Fagus is a wrapper-class for complex, nested objects of dicts and lists in Python\n\n    Fagus can be used as an object by instantiating it, but it's also possible to use all methods statically without\n    even an object, so that a = {}; Fagus.set(a, \"top med\", 1) and a = Fagus({}); a.set(1, \"top med\") do the same.\n\n    The root node is always modified directly. If you don't want to change the root node, all the functions where it\n    makes sense support to rather modify a copy, and return that modified copy using the copy-parameter.\n\n    Several parameters used in functions in Fagus work as options so that you don't have to specify them each time you\n    run a function. In the docstrings, these options are marked with a \\\\*, e.g. the fagus parameter is an option.\n    Options can be specified at three levels with increasing precedence: at class-level (Fagus.fagus = True), at\n    object-level (a = Fagus(), a.fagus = True) and in each function-call (a.get(\"b\", fagus=True)). If you generally want\n    to change an option, change it at class-level - all objects in that file will inherit this option. If you want to\n    change the option specifically for one object, change the option at object-level. If you only want to change the\n    option for one single run of a function, put it as a function-parameter. More thorough examples of options can be\n    found in README.md.\n    \"\"\"\n\n    def __init__(\n        self,\n        root: Collection = None,\n        node_types: str = ...,\n        list_insert: int = ...,\n        value_split: str = ...,\n        fagus: bool = ...,\n        default_node_type: str = ...,\n        default=...,\n        if_=...,\n        iter_fill=...,\n        mod_functions: Mapping = ...,\n        copy: bool = False,\n    ):\n        \"\"\"Constructor for Fagus, a wrapper-class for complex, nested objects of dicts and lists in Python\n\n        \\\\* means that the parameter is a Fagus-Setting, see Fagus-class-docstring for more information about options\n\n        Args:\n            root: object (like dict / list) to wrap Fagus around. If this is None, an empty node of the type\n                default_node_type will be used. Default None\n            node_types: \\\\* Can be used to manually define if the nodes along path are supposed to be (l)ists or\n                (d)icts. E.g. \"dll\" to create a dict at level 1, and lists at level 2 and 3. \" \" can also be used -\n                space doesn't enforce a node-type like d or l. For \" \", existing nodes are traversed if possible,\n                otherwise default_node_type is used to create new nodes. Default \"\", interpreted as \" \" at each level.\n            list_insert: \\\\* Level at which a new node shall be inserted into the list instead of traversing the\n                existing node in the list at that index. See README\n            value_split: \\\\* used to split path into a list if path is a string, default \" \"\n            fagus: \\\\* this option is used to determine whether nodes in the returned object should be returned as\n                Fagus-objects. This can be useful e.g. if you want to use Fagus in an iteration. Check the particular\n                function you want to use for a more thorough explanation of what this does in each case\n            default_node_type: \\\\* determines if new nodes by default should be created as (d)ict or (l)ist. Must be\n                either \"d\" or \"l\", default \"d\"\n            default: \\\\* ~ is used in get and other functions if a path doesn't exist\n            if_: \\\\* only set value if it meets the condition specified here, otherwise do nothing. The condition can be\n                a lambda, any value or a tuple of accepted values. Default _None (don't check value)\n            iter_fill: \\\\* Fill up tuples with iter_fill (can be any object, e.g. None) to ensure that all the tuples\n                iter() returns are exactly max_items long. See iter()\n            copy: ~ creates a copy of the root node before Fagus is initialized. Makes sure that changes on this Fagus\n                won't modify the root node that was passed here itself. Default False\n        \"\"\"\n        if root is None:\n            root = [] if Fagus.default_node_type == \"l\" else {}\n        if copy:\n            root = Fagus.__copy__(root)\n        if isinstance(root, Fagus):\n            self.root = root()\n            self._options = None if root._options is None else root._options.copy()\n        else:\n            self.root = root\n            self._options = None\n        self.options = self.__options  # Renaming __options to options. This is done at runtime to prevent overriding\n        del self.__options  # options in FagusMeta, which is still supposed to run if Fagus.options() is called\n        for kw, value in locals().copy().items():\n            if kw not in (\"copy\", \"self\", \"root\") and value is not ...:\n                setattr(self, kw, value)\n\n    def get(\n        self: Collection,\n        path: Any = \"\",\n        default=...,\n        fagus: bool = ...,\n        copy: bool = False,\n        value_split: str = ...,\n    ) -> Any:\n        \"\"\"Retrieves value at path. If the value doesn't exist, default is returned.\n\n        To get \"hello\" from x = Fagus({\"a\": [\"b\", {\"c\": \"d\"}], e: [\"f\", \"g\"]}), you can use x[(\"a\", 1, \"c\")]. The tuple\n        (\"a\", 1, \"c\") is the path-parameter that is used to traverse x. At first, the list at \"a\" is picked in the\n        top-most dict, and then the 2nd element {\"c\": \"d\"} is picked from that list. Then, \"d\" is picked from {\"c\": \"d\"}\n        and returned. The path-parameter can be a tuple or list, the keys must be either integers for lists, or any\n        hashable objects for dicts. For convenience, the keys can also be put in a single string separated by\n        value_split (default \" \"), so a[\"a 1 c\"] also returns \"d\".\n\n        \\\\* means that the parameter is a Fagus-Setting, see Fagus-class-docstring for more information about options\n\n        Args:\n            path: List/Tuple of key-values to recursively traverse self. Can also be specified as string, that is split\n                into a tuple using value_split\n            default: \\\\* returned if path doesn't exist in self\n            fagus: \\\\* returns a Fagus-object if the value at path is a list or dict\n            copy: Option to return a copy of the returned value. The default behaviour is that if there are subnodes\n                (dicts, lists) in the returned values, and you make changes to these nodes, these changes will also be\n                applied in the root node from which values() was called. If you want the returned values to be\n                independent, use copy to get a shallow copy of the returned value\n            value_split: \\\\* used to split path into a list if path is a str, default \" \"\n\n        Returns:\n            the value if the path exists, or default if it doesn't exist\n        \"\"\"\n        node = self.root if isinstance(self, Fagus) else self\n        if isinstance(path, str):\n            t_path = path.split(Fagus._opt(self, \"value_split\", value_split)) if path else ()\n        else:\n            t_path = tuple(path) if _is(path, Collection) else (path,)\n        if t_path:\n            for node_name in t_path:\n                try:\n                    if _is(node, Mapping, Sequence):\n                        node = node[node_name if isinstance(node, Mapping) else int(node_name)]\n                    else:\n                        node = Fagus._opt(self, \"default\", default)\n                        break\n                except (IndexError, ValueError, KeyError):\n                    node = Fagus._opt(self, \"default\", default)\n                    break\n        if copy:\n            node = _copy_any(node)\n        return Fagus.child(self, node) if _is(node, Collection) and Fagus._opt(self, \"fagus\", fagus) else node\n\n    def iter(\n        self: Collection,\n        max_depth: int = INF,\n        path: Any = \"\",\n        filter_: Fil = None,\n        fagus: bool = ...,\n        iter_fill=...,\n        select: Union[int, Iterable] = None,\n        copy: bool = False,\n        iter_nodes: bool = ...,\n        filter_ends: bool = False,\n        value_split: str = ...,\n    ) -> \"FagusIterator\":\n        \"\"\"Recursively iterate through Fagus-object, starting at path\n\n        \\\\* means that the parameter is a Fagus-Setting, see Fagus-class-docstring for more information about options\n\n        Args:\n            max_depth: Can be used to limit how deep the iteration goes. Example: a = {\"a\": [\"b\", [\"c\", \"d\"]], \"e\": \"f\"}\n                If max_depth is sys.max_size, all the nodes are traversed: [(\"a\", \"b\", \"c\"), (\"a\", \"b\", \"d\"]),\n                (\"e\", \"f\")]. If max_depth is 1, iter returns [(\"a\", \"b\", [\"c\", \"d\"]), (\"e\", \"f\")], so [\"c\", \"d\"] is not\n                iterated through but returned as a node. If max_depth is 0, iter returns [(\"a\", [\"b\", [\"c\", \"d\"]]),\n                (\"e\", \"f\")], effectively the same as dict.items(). Default sys.maxitems (iterate as deeply as possible)\n                A negative number (e.g. -1) is treated as sys.maxitems.\n            path: Start iterating at path. Internally calls get(path), and iterates on the node get returns. See get()\n            filter_: Only iterate over specific nodes defined using TFilter (see README.md and TFilter for more info)\n            fagus: \\\\* If the leaf in the tuple is a dict or list, return it as a Fagus-object. This option has no\n                effect if max_items is sys.maxitems.\n            iter_fill: \\\\* Fill up tuples with iter_fill (can be any object, e.g. None) to ensure that all the tuples\n                iter() returns are exactly max_items long. This can be useful if you want to unpack the keys / leaves\n                from the tuples in a loop, which fails if the count of items in the tuples varies. This option has no\n                effect if max_items is -1. The default value is ..., meaning that the tuples are not filled, and the\n                length of the tuples can vary. See README.md for a more thorough example.\n            select: Extract only some specified values from the tuples. E.g. if ~ is -1, only the leaf-values are\n                returned. ~ can also be a list of indices. Default None (don't reduce the tuples)\n            copy: Iterate on a shallow-copy to make sure that you can edit root node without disturbing the iteration\n            iter_nodes: \\\\* includes the traversed nodes into the resulting tuples, order is then:\n                node1, key1, node2, key2, ..., leaf_value\n            filter_ends: Affects the end dict/list that is returned if max_items is used. Normally, filters are not\n                applied on that end node. If you would like to get the end node filtered too, set this to True. If this\n                is set to True, the last nodes will always be copies (if unfiltered they are references)\n            value_split: \\\\* used to split path into a list if path is a str, default \" \"\n\n        Returns:\n            FagusIterator with one tuple for each leaf-node, containing the keys of the parent-nodes until the leaf\n        \"\"\"\n        iter_fill = Fagus._opt(self, \"iter_fill\", iter_fill)\n        node = Fagus.get(self, path, (), True, copy and iter_fill, value_split)\n        if not _is(node, Collection) or isinstance(filter_, Fil) and not filter_.match_extra_filters(node):\n            node = Fagus.child(self, ())\n        return FagusIterator(\n            node,\n            max_depth,\n            filter_,\n            Fagus._opt(self, \"fagus\", fagus),\n            iter_fill,\n            select,\n            Fagus._opt(self, \"iter_nodes\", iter_nodes),\n            copy and not iter_fill,\n            filter_ends,\n        )\n\n    def filter(\n        self: Collection,\n        filter_: Fil,\n        path: Any = \"\",\n        fagus: bool = ...,\n        copy: bool = False,\n        default=...,\n        value_split: str = ...,\n    ) -> Collection:\n        \"\"\"Filters self, only keeping the nodes that pass the filter\n\n        \\\\* means that the parameter is a Fagus-Setting, see Fagus-class-docstring for more information about options\n\n        Args:\n            filter_: TFilter-object in which the filtering-criteria are specified\n            path: at this point in self, the filtering will start (apply filter\\\\_ relatively from this point).\n                Default \"\", meaning that the root node is filtered, see get() and README for examples\n            fagus: \\\\* return the filtered self as Fagus-object (default is just to return the filtered node)\n            copy: Create a copy and filter on that copy. Default is to modify the self directly\n            default: \\\\* returned if path doesn't exist in self, or the value at path can't be filtered\n            value_split: \\\\* used to split path into a list if path is a str, default \" \"\n\n        Returns:\n            the filtered object, starting at path\n\n        Raises:\n            TypeError: if the root node needs to be modified and isn't modifiable (e.g. tuple or frozenset)\n        \"\"\"\n        if isinstance(path, str):\n            l_path = path.split(Fagus._opt(self, \"value_split\", value_split)) if path else []\n        else:\n            l_path = list(path) if _is(path, Collection) else [path]\n        if copy:\n            parent_node = Fagus.get(self, l_path[:-1], _None, False, copy, value_split)\n        else:\n            parent_node = Fagus._get_mutable_node(self, l_path)\n        node = _None if parent_node is _None else Fagus.get(parent_node, l_path[-1:], _None, False)\n        if node is _None or not _is(node, Collection):\n            filtered = Fagus._opt(self, \"default\", default)\n        else:\n            filtered = _filter_r(node, copy, filter_)\n            if not filter_.match_extra_filters(node):\n                filtered.clear()\n            if not copy:\n                if path:\n                    parent_node[int(l_path[-1]) if isinstance(parent_node, Sequence) else l_path[-1]] = filtered\n                else:\n                    parent_node.clear()\n                    getattr(parent_node, \"extend\" if isinstance(parent_node, MutableSequence) else \"update\")(filtered)\n        return Fagus.child(self, filtered) if Fagus._opt(self, \"fagus\", fagus) else filtered\n\n    def split(\n        self: Collection,\n        filter_: Fil,\n        path: Any = \"\",\n        fagus: bool = ...,\n        copy: bool = False,\n        default=...,\n        value_split: str = ...,\n    ) -> Union[Tuple[Collection, Collection], Tuple[Any, Any]]:\n        \"\"\"Splits self into nodes that pass the filter, and nodes that don't pass the filter\n\n        \\\\* means that the parameter is a Fagus-Setting, see Fagus-class-docstring for more information about options\n\n        Args:\n            filter_: TFilter-object in which the filtering-criteria are specified\n            path: at this position in self, the splitting will start (apply filter\\\\_ relatively from this point).\n                Default \"\", meaning that the root node is split, see get() and README for examples\n            fagus: \\\\* return the filtered self as Fagus-object (default is just to return the filtered node)\n            copy: Create a copy and filter on that copy. Default is to modify the object directly\n            default: \\\\* returned if path doesn't exist in self, or the\n            value_split: \\\\* used to split path into a list if path is a str, default \" \"\n\n        Returns:\n            a tuple, where the first element is the nodes that pass the filter, and the second element is the nodes that\n            don't pass the filter\n\n        Raises:\n            TypeError: if the root node needs to be modified and isn't modifiable (e.g. tuple or frozenset)\n        \"\"\"\n        if isinstance(path, str):\n            l_path = path.split(Fagus._opt(self, \"value_split\", value_split)) if path else []\n        else:\n            l_path = list(path) if _is(path, Collection) else [path]\n        if copy:\n            parent_node = Fagus.get(self, l_path[:-1], _None, False, copy, value_split)\n        else:\n            parent_node = Fagus._get_mutable_node(self, l_path)\n        node = _None if parent_node is _None else Fagus.get(parent_node, l_path[-1:], _None, False)\n        if node is _None or not _is(node, Collection):\n            filter_in, filter_out = 2 * (Fagus._opt(self, \"default\", default),)\n        else:\n            filter_in, filter_out = Fagus._split_r(node, copy, filter_)\n            if not filter_.match_extra_filters(node):\n                filter_in.clear()\n                filter_out = node\n            if not copy:\n                if path:\n                    parent_node[int(l_path[-1]) if isinstance(parent_node, Sequence) else l_path[-1]] = filter_in\n                else:\n                    parent_node.clear()\n                    getattr(parent_node, \"extend\" if isinstance(parent_node, MutableSequence) else \"update\")(filter_in)\n        return (\n            (Fagus.child(self, filter_in), Fagus.child(self, filter_out))\n            if Fagus._opt(self, \"fagus\", fagus) and _is(filter_in, Collection)\n            else (filter_in, filter_out)\n        )\n\n    @staticmethod\n    def _split_r(\n        node: Collection, copy: bool, filter_: Optional[Fil], index: int = 0\n    ) -> Tuple[Union[MutableMapping, MutableSequence, MutableSet], Union[MutableMapping, MutableSequence, MutableSet]]:\n        \"\"\"Internal recursive method that facilitates filtering\n\n        Args:\n            node: the node to filter\n            copy: creates copies instead of directly referencing nodes included in the filter\n            filter_: TFilter-object in which the filtering-criteria are specified\n            index: index in the current filter-object\n\n        Returns:\n            the filtered node\n        \"\"\"\n        if isinstance(node, Mapping):\n            filter_in, filter_out, action, match_key = {}, {}, None, filter_.match if filter_ else None\n        elif isinstance(node, Sequence):\n            filter_in, filter_out, action, match_key = [], [], \"append\", filter_.match_list if filter_ else None\n        else:\n            filter_in, filter_out, action, match_key = set(), set(), \"add\", None\n        for k, v in node.items() if isinstance(node, Mapping) else enumerate(node):\n            v_in, v_out = _None, _None\n            match_k = match_key(k, index, len(node)) if callable(match_key) else (True, filter_, index + 1)\n            match_v = False\n            if match_k[0]:\n                if match_k[1] is None:\n                    match_v = True\n                elif _is(v, Collection):\n                    if match_k[1].match_extra_filters(v, match_k[2]):\n                        v_in, v_out = Fagus._split_r(v, copy, *match_k[1:])\n                        match_v = bool(v) == bool(v_in)\n                else:\n                    match_v, *_ = match_k[1].match(v, match_k[2])\n                if match_v or v_in is not _None:\n                    if v_in is _None:\n                        v_in = v\n                    if action:\n                        getattr(filter_in, action)(_copy_any(v_in) if copy else v_in)\n                    else:\n                        filter_in[k] = _copy_any(v_in) if copy else v_in\n            if not match_v or v_out is not _None:\n                if v_out is _None:\n                    v_out = v\n                elif bool(v) != bool(v_out):\n                    continue\n                if action:\n                    getattr(filter_out, action)(_copy_any(v_out) if copy else v_out)\n                else:\n                    filter_out[k] = _copy_any(v_out) if copy else v_out\n        return filter_in, filter_out\n\n    def set(\n        self: Collection,\n        value,\n        path: Iterable,\n        node_types: str = ...,\n        list_insert: int = ...,\n        value_split: str = ...,\n        fagus: bool = ...,\n        if_: Any = ...,\n        default_node_type: str = ...,\n        copy: bool = False,\n    ) -> Collection:\n        \"\"\"Create (if they don't already exist) all sub-nodes in path, and finally set value at leaf-node\n\n        \\\\* means that the parameter is a Fagus-Setting, see Fagus-class-docstring for more information about options\n\n        Args:\n            value: ~ is placed at path, after creating new nodes if necessary. An existing value at path is overwritten\n            path: List/Tuple of key-values that are traversed in self. If no nodes exist at the keys, new nodes are\n                created. Can also be specified as a string, that is split into a tuple using value_split. See get()\n            node_types: \\\\* Can be used to manually define if the nodes along path are supposed to be (l)ists or\n                (d)icts. E.g. \"dll\" to create a dict at level 1, and lists at level 2 and 3. \" \" can also be used -\n                space doesn't enforce a node-type like d or l. For \" \", existing nodes are traversed if possible,\n                otherwise default_node_type is used to create new nodes. Default \"\", interpreted as \" \" at each level.\n            list_insert: \\\\* Level at which a new node shall be inserted into the list instead of traversing the\n                existing node in the list at that index. See README\n            value_split: \\\\* used to split path into a list if path is a string, default \" \"\n            fagus: \\\\* return self as a Fagus-object if it is a node (tuple / list / dict), default False\n            if_: \\\\* only set value if it meets the condition specified here, otherwise do nothing. The condition can be\n                a lambda, any value or a tuple of accepted values. Default _None (don't check value)\n            default_node_type: \\\\* determines if new nodes by default should be created as (d)ict or (l)ist. Must be\n                either \"d\" or \"l\", default \"d\"\n            copy: if this is set, a copy of self is modified and then returned (thus self is not modified)\n\n        Returns:\n            self as a node if fagus is set, or a modified copy of self if copy is set\n\n        Raises:\n            ValueError: if it isn't possible to parse an int-index from the provided key in a position where node-types\n                defines that the node shall be a list (if node-types is not l, the node will be replaced with a dict)\n            TypeError: if the root node needs to be modified and isn't modifiable (e.g. tuple or frozenset)\n        \"\"\"\n        return Fagus._build_node(\n            self, value, path, \"set\", node_types, list_insert, value_split, fagus, if_, default_node_type, copy\n        )\n\n    def append(\n        self: Collection,\n        value,\n        path: Any = \"\",\n        node_types: str = ...,\n        list_insert: int = ...,\n        value_split: str = ...,\n        fagus: bool = ...,\n        if_: Any = ...,\n        default_node_type: str = ...,\n        copy: bool = False,\n    ) -> Collection:\n        \"\"\"Create (if they don't already exist) all sub-nodes in path, and finally append value to a list at leaf-node\n\n        If the leaf-node is a set, tuple or other value it is converted to a list. Then the new value is appended.\n\n        \\\\* means that the parameter is a Fagus-Setting, see Fagus-class-docstring for more information about options\n\n        Args:\n            value: ~ is appended to list at path, after creating new nodes along path as necessary\n            path: List/Tuple of key-values that are traversed in self. If no nodes exist at the keys, new nodes are\n                created. Can also be specified as a string, that is split into a tuple using value_split. See get()\n            node_types: \\\\* Can be used to manually define if the nodes along path are supposed to be (l)ists or\n                (d)icts. E.g. \"dll\" to create a dict at level 1, and lists at level 2 and 3. \" \" can also be used -\n                space doesn't enforce a node-type like d or l. For \" \", existing nodes are traversed if possible,\n                otherwise default_node_type is used to create new nodes. Default \"\", interpreted as \" \" at each level.\n            list_insert: \\\\* Level at which a new node shall be inserted into the list instead of traversing the\n                existing node in the list at that index. See README\n            value_split: \\\\* used to split path into a list if path is a string, default \" \"\n            fagus: \\\\* return self as a Fagus-object if it is a node (tuple / list / dict), default False\n            if_: \\\\* only append value if it meets the condition specified here, otherwise do nothing. The condition can\n                be a lambda, any value or a tuple of accepted values. Default _None (don't check value)\n            default_node_type: \\\\* determines if new nodes by default should be created as (d)ict or (l)ist. Must be\n                either \"d\" or \"l\", default \"d\"\n            copy: if this is set, a copy of self is modified and then returned (thus self is not modified)\n\n        Returns:\n            self as a node if fagus is set, or a modified copy of self if copy is set\n\n        Raises:\n            ValueError: if it isn't possible to parse an int-index from the provided key in a position where node-types\n                defines that the node shall be a list (if node-types is not l, the node will be replaced with a dict)\n            TypeError: if path is empty and the root node is not a list (can't append to a dict, tuple or set) or the\n                root node needs to be modified and isn't modifiable (e.g. tuple or frozenset)\n        \"\"\"\n        return Fagus._build_node(\n            self, value, path, \"append\", node_types, list_insert, value_split, fagus, if_, default_node_type, copy\n        )\n\n    def extend(\n        self: Collection,\n        values: Iterable,\n        path: Any = \"\",\n        node_types: str = ...,\n        list_insert: int = ...,\n        value_split: str = ...,\n        fagus: bool = ...,\n        if_: Any = ...,\n        default_node_type: str = ...,\n        copy: bool = False,\n    ) -> Collection:\n        \"\"\"Create (if they don't already exist) all sub-nodes in path. Then extend list at leaf-node with the new values\n\n        If the leaf-node is a set, tuple or other value it is converted to a list, which is extended with the new values\n\n        \\\\* means that the parameter is a Fagus-Setting, see Fagus-class-docstring for more information about options\n\n        Args:\n            values: the list at path is extended with ~, after creating new nodes along path as necessary\n            path: List/Tuple of key-values that are traversed in self. If no nodes exist at the keys, new nodes are\n                created. Can also be specified as a string, that is split into a tuple using value_split. See get()\n\n            node_types: \\\\* Can be used to manually define if the nodes along path are supposed to be (l)ists or\n                (d)icts. E.g. \"dll\" to create a dict at level 1, and lists at level 2 and 3. \" \" can also be used -\n                space doesn't enforce a node-type like d or l. For \" \", existing nodes are traversed if possible,\n                otherwise default_node_type is used to create new nodes. Default \"\", interpreted as \" \" at each level.\n            list_insert: \\\\* Level at which a new node shall be inserted into the list instead of traversing the\n                existing node in the list at that index. See README\n            value_split: \\\\* used to split path into a list if path is a string, default \" \"\n            fagus: \\\\* return self as a Fagus-object if it is a node (tuple / list / dict), default False\n            if_: \\\\* only extend with values if they meet the condition specified here, otherwise do nothing. The\n                condition can be a lambda, any value or a tuple of accepted values. Default _None (don't check values)\n            default_node_type: \\\\* determines if new nodes by default should be created as (d)ict or (l)ist. Must be\n                either \"d\" or \"l\", default \"d\"\n            copy: if this is set, a copy of self is modified and then returned (thus self is not modified)\n\n        Returns:\n            self as a node if fagus is set, or a modified copy of self if copy is set\n\n        Raises:\n            ValueError: if it isn't possible to parse an int-index from the provided key in a position where node-types\n                defines that the node shall be a list (if node-types is not l, the node will be replaced with a dict)\n            TypeError: if path is empty and the root node is not a list (can't extend a dict, tuple or set) or the\n                root node needs to be modified and isn't modifiable (e.g. tuple or frozenset)\n        \"\"\"\n        return Fagus._build_node(\n            self, values, path, \"extend\", node_types, list_insert, value_split, fagus, if_, default_node_type, copy\n        )\n\n    def insert(\n        self: Collection,\n        index: int,\n        value,\n        path: Any = \"\",\n        node_types: str = ...,\n        list_insert: int = ...,\n        value_split: str = ...,\n        fagus: bool = ...,\n        if_: Any = ...,\n        default_node_type: str = ...,\n        copy: bool = False,\n    ) -> Collection:\n        \"\"\"Create (if they don't already exist) all sub-nodes in path. Insert new value at index in list at leaf-node\n\n        If the leaf-node is a set, tuple or other value it is converted to a list, in which the new value is inserted at\n        index\n\n        \\\\* means that the parameter is a Fagus-Setting, see Fagus-class-docstring for more information about options\n\n        Args:\n            index: ~ at which the value shall be inserted in the list at path\n            value: ~ is inserted at index into list at path, after creating new nodes along path as necessary\n            path: List/Tuple of key-values that are traversed in self. If no nodes exist at the keys, new nodes are\n                created. Can also be specified as a string, that is split into a tuple using value_split. See get()\n            node_types: \\\\* Can be used to manually define if the nodes along path are supposed to be (l)ists or\n                (d)icts. E.g. \"dll\" to create a dict at level 1, and lists at level 2 and 3. \" \" can also be used -\n                space doesn't enforce a node-type like d or l. For \" \", existing nodes are traversed if possible,\n                otherwise default_node_type is used to create new nodes. Default \"\", interpreted as \" \" at each level.\n            list_insert: \\\\* Level at which a new node shall be inserted into the list instead of traversing the\n                existing node in the list at that index. See README\n            value_split: \\\\* used to split path into a list if path is a string, default \" \"\n            fagus: \\\\* return self as a Fagus-object if it is a node (tuple / list / dict), default False\n            if_: \\\\* only insert value if it meets the condition specified here, otherwise do nothing. The condition can\n                be a lambda, any value or a tuple of accepted values. Default _None (don't check value)\n            default_node_type: \\\\* determines if new nodes by default should be created as (d)ict or (l)ist. Must be\n                either \"d\" or \"l\", default \"d\"\n            copy: if this is set, a copy of self is modified and then returned (thus self is not modified)\n\n        Returns:\n            self as a node if fagus is set, or a modified copy of self if copy is set\n\n        Raises:\n            ValueError: if it isn't possible to parse an int-index from the provided key in a position where node-types\n                defines that the node shall be a list (if node-types is not l, the node will be replaced with a dict)\n            TypeError: if path is empty and the root node is not a list (can't insert into dict, tuple or set) or the\n                root node needs to be modified and isn't modifiable (e.g. tuple or frozenset)\n        \"\"\"\n        return Fagus._build_node(\n            self,\n            value,\n            path,\n            \"insert\",\n            node_types,\n            list_insert,\n            value_split,\n            fagus,\n            if_,\n            default_node_type,\n            copy,\n            index,\n        )\n\n    def add(\n        self: Collection,\n        value,\n        path: Any = \"\",\n        node_types: str = ...,\n        list_insert: int = ...,\n        value_split: str = ...,\n        fagus: bool = ...,\n        if_: Any = ...,\n        default_node_type: str = ...,\n        copy: bool = False,\n    ) -> Collection:\n        \"\"\"Create (if they don't already exist) all sub-nodes in path, and finally add new value to set at leaf-node\n\n        If the leaf-node is a list, tuple or other value it is converted to a set, to which the new value is added\n\n        \\\\* means that the parameter is a Fagus-Setting, see Fagus-class-docstring for more information about options\n\n        Args:\n            value: ~ is added to set at path, after creating new nodes along path as necessary\n            path: List/Tuple of key-values that are traversed in self. If no nodes exist at the keys, new nodes are\n                created. Can also be specified as a string, that is split into a tuple using value_split. See get()\n            node_types: \\\\* Can be used to manually define if the nodes along path are supposed to be (l)ists or\n                (d)icts. E.g. \"dll\" to create a dict at level 1, and lists at level 2 and 3. \" \" can also be used -\n                space doesn't enforce a node-type like d or l. For \" \", existing nodes are traversed if possible,\n                otherwise default_node_type is used to create new nodes. Default \"\", interpreted as \" \" at each level.\n            list_insert: \\\\* Level at which a new node shall be inserted into the list instead of traversing the\n                existing node in the list at that index. See README\n            value_split: \\\\* used to split path into a list if path is a string, default \" \"\n            fagus: \\\\* return self as a Fagus-object if it is a node (tuple / list / dict), default False\n            if_: \\\\* only add value if it meets the condition specified here, otherwise do nothing. The condition can be\n                a lambda, any value or a tuple of accepted values. Default _None (don't check value)\n            default_node_type: \\\\* determines if new nodes by default should be created as (d)ict or (l)ist. Must be\n                either \"d\" or \"l\", default \"d\"\n            copy: if this is set, a copy of self is modified and then returned (thus self is not modified)\n\n        Returns:\n            self as a node if fagus is set, or a modified copy of self if copy is set\n\n        Raises:\n            ValueError: if it isn't possible to parse an int-index from the provided key in a position where node-types\n                defines that the node shall be a list (if node-types is not l, the node will be replaced with a dict)\n            TypeError: if path is empty and the root node is not a set (can't add to list or dict) or the root node\n                needs to be modified and isn't modifiable (e.g. tuple or frozenset)\n        \"\"\"\n        return Fagus._build_node(\n            self, value, path, \"add\", node_types, list_insert, value_split, fagus, if_, default_node_type, copy\n        )\n\n    def update(\n        self: Collection,\n        values: Iterable,\n        path: Any = \"\",\n        node_types: str = ...,\n        list_insert: int = ...,\n        value_split: str = ...,\n        fagus: bool = ...,\n        if_: Any = ...,\n        default_node_type: str = ...,\n        copy: bool = False,\n    ) -> Collection:\n        \"\"\"Create (if they don't already exist) all sub-nodes in path, then update set at leaf-node with new values\n\n        If the leaf-node is a list, tuple or other value it is converted to a set. That set is then updated with the new\n        values. If the node at path is a dict, and values also is a dict, the node-dict is updated with the new values.\n\n        \\\\* means that the parameter is a Fagus-Setting, see Fagus-class-docstring for more information about options\n\n        Args:\n            values: the set/dict at path is updated with ~, after creating new nodes along path as necessary\n            path: List/Tuple of key-values that are traversed in self. If no nodes exist at the keys, new nodes are\n                created. Can also be specified as a string, that is split into a tuple using value_split. See get()\n            node_types: \\\\* Can be used to manually define if the nodes along path are supposed to be (l)ists or\n                (d)icts. E.g. \"dll\" to create a dict at level 1, and lists at level 2 and 3. \" \" can also be used -\n                space doesn't enforce a node-type like d or l. For \" \", existing nodes are traversed if possible,\n                otherwise default_node_type is used to create new nodes. Default \"\", interpreted as \" \" at each level.\n            list_insert: \\\\* Level at which a new node shall be inserted into the list instead of traversing the\n                existing node in the list at that index. See README\n            value_split: \\\\* used to split path into a list if path is a string, default \" \"\n            fagus: \\\\* return self as a Fagus-object if it is a node (tuple / list / dict), default False\n            if_: \\\\* only update with values if they meet the condition specified here, otherwise do nothing. The\n                condition can be a lambda, any value or a tuple of accepted values. Default _None (don't check values)\n            default_node_type: \\\\* determines if new nodes by default should be created as (d)ict or (l)ist. Must be\n                either \"d\" or \"l\", default \"d\"\n            copy: if this is set, a copy of self is modified and then returned (thus self is not modified)\n\n        Returns:\n            self as a node if fagus is set, or a modified copy of self if copy is set\n\n        Raises:\n            ValueError: if it isn't possible to parse an int-index from the provided key in a position where node-types\n                defines that the node shall be a list (if node-types is not l, the node will be replaced with a dict)\n            TypeError: if path is empty and the root node is not a set or dict (can't update list) or the root node\n                needs to be modified and isn't modifiable (e.g. tuple or frozenset)\n        \"\"\"\n        return Fagus._build_node(\n            self, values, path, \"update\", node_types, list_insert, value_split, fagus, if_, default_node_type, copy\n        )\n\n    def _build_node(\n        self: Collection,\n        value,\n        path,\n        action: str,\n        node_types: str = ...,\n        list_insert: int = ...,\n        value_split: str = ...,\n        fagus: bool = ...,\n        if_: Any = ...,\n        default_node_type: str = ...,\n        copy: bool = False,\n        index: int = ...,\n    ) -> Collection:\n        \"\"\"Internal function that is used to _build all necessary subnodes in path\"\"\"\n        root = self.root if isinstance(self, Fagus) else self\n        if_ = Fagus._opt(self, \"if_\", if_)\n        if if_ is not _None and not (\n            if_(value) if callable(if_) else (value in if_ if _is(if_, Container) else if_ == value)\n        ):\n            return Fagus.child(self, root) if Fagus._opt(self, \"fagus\", fagus) else root\n        node_types = Fagus._opt(self, \"node_types\", node_types)\n        if copy:\n            root = Fagus.__copy__(root)\n        node = root\n        if isinstance(path, str):\n            l_path = path.split(Fagus._opt(self, \"value_split\", value_split)) if path else []\n        else:\n            l_path = list(path) if _is(path, Collection) else [path]\n        if l_path:\n            try:\n                next_index = int(l_path[0])\n            except (ValueError, TypeError):\n                next_index = _None\n            list_insert = Fagus._opt(self, \"list_insert\", list_insert)\n            default_node_type = Fagus._opt(self, \"default_node_type\", default_node_type)\n            nodes = [root]\n            for i in range(len(l_path)):\n                is_list = _is(node, Sequence)\n                if is_list:\n                    if next_index is _None:\n                        raise ValueError(f\"Can't parse numeric list-index from {l_path[i]}.\")\n                    node_key = next_index\n                else:\n                    node_key = l_path[i]\n                try:\n                    next_index = int(l_path[i + 1]) if i < len(l_path) - 1 else _None\n                except (ValueError, TypeError):\n                    next_index = _None\n                next_node = (\n                    Sequence\n                    if node_types[i : i + 1] == \"l\"\n                    or not node_types[i : i + 1].strip()\n                    and default_node_type == \"l\"\n                    and next_index is not _None\n                    else Mapping\n                )\n                if is_list:\n                    l_path[i] = node_key\n                    if node_key >= len(node) and list_insert:\n                        if nodes:\n                            node = Fagus._ensure_mutable_node(nodes, l_path[: i + 1])\n                            nodes.clear()\n                        node.append([] if next_node is Sequence else {})\n                        node_key = -1\n                    elif node_key < -len(node):\n                        if nodes:\n                            node = Fagus._ensure_mutable_node(nodes, l_path[: i + 1])\n                            nodes.clear()\n                        node.insert(0, [] if next_node is Sequence else {})\n                        node_key = 0\n                    if i == len(l_path) - 1:\n                        if nodes:\n                            node = Fagus._ensure_mutable_node(nodes, l_path[: i + 1])\n                            nodes.clear()\n                        if list_insert == 0:\n                            node.insert(node_key, Fagus._put_value(_None, value, action, index))\n                        else:\n                            node[node_key] = Fagus._put_value(node[node_key], value, action, index)\n                    else:\n                        if list_insert <= 0:\n                            if nodes:\n                                node = Fagus._ensure_mutable_node(nodes, l_path[: i + 1])\n                                nodes.clear()\n                            node.insert(node_key, [] if next_node is Sequence else {})\n                            list_insert = INF\n                        else:\n                            next_node_type = (\n                                Mapping\n                                if isinstance(node[node_key], Mapping)\n                                else (Sequence if _is(node[node_key], Sequence) else _None)\n                            )\n                            if next_node_type is _None or (\n                                next_node != next_node_type\n                                if node_types[i : i + 1].strip()\n                                else next_node_type is Sequence and next_index is _None\n                            ):\n                                if nodes:\n                                    node = Fagus._ensure_mutable_node(nodes, l_path[: i + 1])\n                                    nodes.clear()\n                                node[node_key] = [] if next_node is Sequence else {}\n                elif isinstance(node, Mapping):  # isinstance(node, dict)\n                    if i == len(l_path) - 1:\n                        if nodes:\n                            node = Fagus._ensure_mutable_node(nodes, l_path[: i + 1])\n                            nodes.clear()\n                        node[node_key] = Fagus._put_value(node.get(node_key, _None), value, action, index)\n                    else:\n                        next_value = node.get(node_key, _None)\n                        next_node_type = (\n                            Mapping\n                            if isinstance(next_value, Mapping)\n                            else (Sequence if _is(next_value, Sequence) else _None)\n                        )\n                        if next_node_type is _None or (\n                            next_node != next_node_type\n                            if node_types[i : i + 1].strip()\n                            else next_node_type is Sequence and next_index is _None\n                        ):\n                            if nodes:\n                                node = Fagus._ensure_mutable_node(nodes, l_path[: i + 1])\n                                nodes.clear()\n                            node[node_key] = [] if next_node is Sequence else {}\n                node = node[node_key]\n                if nodes:\n                    nodes.append(node)\n                list_insert -= 1\n        else:\n            if not _is(root, MutableMapping, MutableSequence, MutableSet):\n                raise TypeError(f\"Can't modify root node self having the immutable type {type(self).__name__}.\")\n            if isinstance(root, MutableMapping) and action == \"update\":\n                root.update(value)\n            elif isinstance(root, MutableSequence) and action in (\"append\", \"extend\", \"insert\"):\n                if action == \"insert\":\n                    root.insert(index, value)\n                else:\n                    getattr(root, action)(value)\n            elif isinstance(root, MutableSet) and action in (\"add\", \"update\"):\n                getattr(root, action)(value)\n            elif not action == \"parent\":\n                raise TypeError(\n                    f\"Can't {action} value {'to' if action in ('add', 'append') else 'in'} root {type(root).__name__}.\"\n                )\n        return Fagus.child(self, root) if Fagus._opt(self, \"fagus\", fagus) else root\n\n    @staticmethod\n    def _put_value(node: Union[Collection, type], value, action: str, index: int):\n        \"\"\"internal function that sets, appends or adds value as the last step in building a node\"\"\"\n        if action == \"set\":\n            return value\n        if action in (\"append\", \"extend\", \"insert\"):\n            if not _is(node, MutableSequence):\n                if _is(node, Iterable):\n                    node = list(node)\n                elif node is _None:\n                    node = []\n                else:\n                    node = [node]\n            if action == \"insert\":\n                node.insert(index, value)\n            else:\n                getattr(node, action)(value)\n        elif action in (\"add\", \"update\"):\n            if node is _None:\n                return dict(value) if isinstance(value, Mapping) else set(value) if _is(value, Iterable) else {value}\n            else:\n                if not isinstance(node, (MutableSet, MutableMapping)):\n                    if _is(node, Iterable):\n                        node = set(node)\n                    else:\n                        node = {node}\n                elif isinstance(node, MutableMapping) and not isinstance(value, Mapping):  # it makes no sense to\n                    return set(value)  # convert the existing node to a set if it's a Mapping, so just return set(value)\n                getattr(node, action)(value)\n        else:\n            raise ValueError(\n                f\"Invalid action for _build_node(): {action}, must be one of add, append, extend, insert, set, update\"\n            )\n        return node\n\n    def setdefault(\n        self: Collection,\n        path: Any = \"\",\n        default=...,\n        fagus: bool = ...,\n        node_types: str = ...,\n        list_insert: int = ...,\n        value_split: str = ...,\n        default_node_type: str = ...,\n    ) -> Any:\n        \"\"\"Get value at path and return it. If there is no value at path, set default at path, and return default\n\n        \\\\* means that the parameter is a Fagus-Setting, see Fagus-class-docstring for more information about options\n\n        Args:\n            path: position in self where default shall be set / from where value shall be fetched. See get() and README\n            default: \\\\* returned if path doesn't exist in self\n            fagus: \\\\* return self as a Fagus-object if it is a node (tuple / list / dict), default False\n            node_types: \\\\* Can be used to manually define if the nodes along path are supposed to be (l)ists or\n                (d)icts. E.g. \"dll\" to create a dict at level 1, and lists at level 2 and 3. \" \" can also be used -\n                space doesn't enforce a node-type like d or l. For \" \", existing nodes are traversed if possible,\n                otherwise default_node_type is used to create new nodes. Default \"\", interpreted as \" \" at each level.\n            list_insert: \\\\* Level at which a new node shall be inserted into the list instead of traversing the\n                existing node in the list at that index. See README\n            value_split: \\\\* used to split path into a list if path is a str, default \" \"\n            default_node_type: \\\\* determines if new nodes by default should be created as (d)ict or (l)ist. Must be\n                either \"d\" or \"l\", default \"d\"\n\n        Returns:\n            value at path if it exists, otherwise default is set at path and returned\n\n        Raises:\n            ValueError: if it isn't possible to parse an int-index from the provided key in a position where node-types\n                defines that the node shall be a list (if node-types is not l, the node will be replaced with a dict)\n            TypeError: if the root node needs to be modified and isn't modifiable (e.g. tuple or frozenset)\n        \"\"\"\n        if isinstance(path, str):\n            l_path = path.split(Fagus._opt(self, \"value_split\", value_split)) if path else []\n        else:\n            l_path = list(path) if _is(path, Collection) else [path]\n        parent_node = Fagus._get_mutable_node(\n            self, l_path, Fagus._opt(self, \"list_insert\", list_insert), Fagus._opt(self, \"node_types\", node_types)\n        )\n        if parent_node is _None:\n            value = Fagus._opt(self, \"default\", default)\n            Fagus.set(self, value, path, node_types, list_insert, value_split, False, _None, default_node_type)\n        else:\n            value = Fagus.get(parent_node, l_path[-1], _None, fagus=False)\n            if value is _None or (list_insert == len(l_path) - 1 and isinstance(parent_node, MutableSequence)):\n                value = Fagus._opt(self, \"default\", default)\n                if isinstance(parent_node, MutableSequence):\n                    parent_node.insert(int(l_path[-1]), value)\n                else:\n                    parent_node[l_path[-1]] = value\n        return Fagus.child(self, value) if Fagus._opt(self, \"fagus\", fagus) and _is(value, Collection) else value\n\n    def mod(\n        self: Collection,\n        mod_function: Callable,\n        path,\n        default=...,\n        replace_value=True,\n        fagus: bool = ...,\n        node_types: str = ...,\n        list_insert: int = ...,\n        value_split: str = ...,\n        default_node_type: str = ...,\n    ) -> Any:\n        \"\"\"Modifies the value at path using the function-pointer mod_function\n\n        mod can be used like this Fagus.mod(obj, \"kitchen spoon\", lambda x: x + 1, 1) to count the number of spoons in\n        the kitchen. If there is no value to modify, the default value (here 1) will be set at the node.\n\n        \\\\* means that the parameter is a Fagus-Setting, see Fagus-class-docstring for more information about options\n\n        Args:\n            mod_function: A function pointer or lambda that modifies the existing value at path. TFunc can be used to\n                call more complex functions requiring several arguments.\n            path: position in self at which the value shall be modified. Defined as a list/Tuple of key-values to\n                recursively traverse self. Can also be specified as string which is split into a tuple using value_split\n            default: \\\\* this value is set in path if it doesn't exist\n            fagus: \\\\* Return new value as a Fagus-object if it is a node (tuple / list / dict), default False\n            replace_value: Replace the old value with what mod_function returns. Can be deactivated e.g. if mod_function\n                changes the object, but returns None (if ~ stays on, the object is replaced with None). Default True.\n                If no value exists at path, the default value is always set at path (independent of ~)\n            node_types: \\\\* Can be used to manually define if the nodes along path are supposed to be (l)ists or\n                (d)icts. E.g. \"dll\" to create a dict at level 1, and lists at level 2 and 3. \" \" can also be used -\n                space doesn't enforce a node-type like d or l. For \" \", existing nodes are traversed if possible,\n                otherwise default_node_type is used to create new nodes. Default \"\", interpreted as \" \" at each level.\n            list_insert: \\\\* Level at which a new node shall be inserted into the list instead of traversing the\n                existing node in the list at that index. See README\n            value_split: \\\\* used to split path into a list if path is a str, default \" \"\n            default_node_type: \\\\* determines if new nodes by default should be created as (d)ict or (l)ist. Must be\n                either \"d\" or \"l\", default \"d\"\n\n        Returns:\n            the new value that was returned by the mod_function, or default if there was no value at path\n\n        Raises:\n            ValueError: if it isn't possible to parse an int-index from the provided key in a position where node-types\n                defines that the node shall be a list (if node-types is not l, the node will be replaced with a dict)\n            TypeError: if the root node needs to be modified and isn't modifiable (e.g. tuple or frozenset)\n        \"\"\"\n        root = self.root if isinstance(self, Fagus) else self\n        if isinstance(path, str):\n            l_path = path.split(Fagus._opt(self, \"value_split\", value_split)) if path else []\n        else:\n            l_path = list(path) if _is(path, Collection) else [path]\n        list_insert = Fagus._opt(self, \"list_insert\", list_insert)\n        parent = Fagus._get_mutable_node(\n            self, l_path, list_insert=list_insert, node_types=Fagus._opt(self, \"node_types\", node_types)\n        )\n        if isinstance(parent, (MutableMapping, MutableSequence)) and list_insert != len(l_path):\n            old_value = Fagus.get(parent, l_path[-1], _None, fagus=False)\n            if replace_value:\n                if isinstance(parent, MutableSequence):\n                    if list_insert == len(l_path) - 1:\n                        new_value = Fagus._opt(self, \"default\", default)\n                        parent.insert(int(l_path[-1]), new_value)\n                    else:\n                        new_value = (\n                            Fagus._opt(self, \"default\", default) if old_value is _None else mod_function(old_value)\n                        )\n                        parent[int(l_path[-1])] = new_value\n                else:\n                    new_value = Fagus._opt(self, \"default\", default) if old_value is _None else mod_function(old_value)\n                    parent[l_path[-1]] = new_value\n        else:\n            new_value = Fagus._opt(self, \"default\", default)\n            Fagus.set(root, new_value, path, node_types, list_insert, value_split, False, _None, default_node_type)\n        return Fagus.child(self, default) if _is(default, Collection) and Fagus._opt(self, \"fagus\", fagus) else default\n\n    def mod_all(\n        self: Collection,\n        mod_function: Callable,\n        filter_: Fil = None,\n        path: Any = \"\",\n        replace_value=True,\n        default=...,\n        max_depth: int = INF,\n        fagus: bool = ...,\n        copy=False,\n        value_split: str = ...,\n    ) -> Collection:\n        \"\"\"Modify all the leaf-values that match a certain filter\n\n        \\\\* means that the parameter is a Fagus-Setting, see Fagus-class-docstring for more information about options\n\n        Args:\n            mod_function: A function pointer or lambda that modifies the existing value at path. TFunc can be used to\n                call more complex functions requiring several arguments.\n            filter_: used to select which leaves shall be modified. Default None (all leaves are modified)\n            path: position in self at which the value shall be modified. See get() / README\n            default: \\\\* this value is returned if path doesn't exist, or if no leaves match the filter\n            fagus: \\\\* Return new value as a Fagus-object if it is a node (tuple / list / dict), default False\n            replace_value: Replace the old value with what mod_function returns. Can be deactivated e.g. if mod_function\n                changes the object, but returns None (if ~ stays on, the object is replaced with None). Default True.\n                If no value exists at path, the default value is always set at path (independent of ~)\n            max_depth: Defines the maximum depth for the iteration. See Fagus.iter max_depth for more information\n            copy: Can be ued to make sure that the node at path is not modified (instead a modified copy is returned)\n            value_split: \\\\* used to split path into a list if path is a str, default \" \"\n\n        Returns:\n            the node at path where all the leaves matching filter\\\\_ are modified, or default if it didn't exist\n\n        Raises:\n            TypeError: if the root node needs to be modified and isn't modifiable (e.g. tuple or frozenset)\n        \"\"\"\n        base = Fagus.get(self, path, _None, False, copy, value_split)\n        if base is _None or not _is(base, Collection) or not base:\n            return Fagus._opt(self, \"default\", default)\n        f_iter = Fagus.iter(base, max_depth, filter_=filter_, fagus=False, iter_fill=_None, iter_nodes=True)\n        if replace_value:\n            parent, last_deepest = None, None\n            for deepest_change, parent_not_deepest, *base_keys, parent_, key, old_value in tuple(\n                (f_iter.deepest_change, f_iter.deepest_change < (len(p) - 3) / 2, *p[1::2], *p[-3:]) for p in f_iter\n            ):\n                if parent_not_deepest or last_deepest != deepest_change:\n                    if not _is(parent_, MutableMapping, MutableSequence, MutableSet):\n                        parent = Fagus._get_mutable_node(base, base_keys)\n                    else:\n                        parent = parent_\n                    last_deepest = deepest_change\n                if isinstance(parent, MutableSet):\n                    parent.remove(old_value)\n                    parent.add(mod_function(old_value))\n                else:\n                    parent[key] = mod_function(old_value)\n        else:\n            for *_, old_value in f_iter:\n                mod_function(old_value)\n        return Fagus.child(self, base) if Fagus._opt(self, \"fagus\", fagus) else base\n\n    def serialize(\n        self: Union[dict, list],\n        mod_functions: Mapping = None,\n        path: Any = \"\",\n        node_types: str = ...,\n        list_insert: int = ...,\n        value_split: str = ...,\n        copy: bool = False,\n    ) -> Union[dict, list]:\n        \"\"\"Makes sure the object can be serialized so that it can be converted to JSON, YAML etc.\n\n        The only allowed data-types for serialization are: dict, list, bool, float, int, str, None\n\n        Sets and tuples are converted into lists. Other objects whose types are not allowed in serialized objects are\n        modified to a type that is allowed using the mod_functions-parameter. mod_functions is a dict, with the type\n        of object like IPv4Address or a tuple of types like (IPv4Address, IPv6Address). The values are function pointers\n        or lambdas, that are executed to convert e.g. an IPv4Address to one of the allowed data types mentioned above.\n\n        The default mod_functions are: {datetime: lambda x: x.isoformat(), date: lambda x: x.isoformat(), time:\n        lambda x: x.isoformat(), \"default\": lambda x: str(x)}\n\n        By default, date, datetime and time-objects are replaced by their isoformat-string. All other objects whose\n        types don't appear in mod_functions are modified by the function behind the key \"default\". By default, this\n        function is lambda x: str(x) that replaces the object with its string-representation.\n\n        \\\\* means that the parameter is a Fagus-Setting, see Fagus-class-docstring for more information about options\n\n        Args:\n            mod_functions: \\\\* ~ is used to define how different types of objects are supposed to be serialized. This is\n                defined in a dict. The keys are either a type (like IPAddress) or a tuple of different types\n                (IPv4Address, IPv6Address). The values are function pointers, or lambdas, which are supposed to convert\n                e.g. an IPv4Address into a string. Check out TFunc if you want to call more complicated functions with\n                several arguments. See README for examples\n            path: position in self at which the value shall be modified. See get() / README\n            node_types: \\\\* Can be used to manually define if the nodes along path are supposed to be (l)ists or\n                (d)icts. E.g. \"dll\" to create a dict at level 1, and lists at level 2 and 3. \" \" can also be used -\n                space doesn't enforce a node-type like d or l. For \" \", existing nodes are traversed if possible,\n                otherwise default_node_type is used to create new nodes. Default \"\", interpreted as \" \" at each level.\n            list_insert: \\\\* Level at which a new node shall be inserted into the list instead of traversing the\n                existing node in the list at that index. See README\n            value_split: \\\\* used to split path into a list if path is a str, default \" \"\n            copy: Create a copy and make that copy serializable. Default is to modify self directly\n\n        Returns:\n            a serializable object that only contains types allowed in json or yaml\n\n        Raises:\n            TypeError: if root node is not a dict or list (serialize can't fix that for the root node)\n            ValueError: if tuple_keys is not defined in mod_functions and a dict has tuples as keys\n            Exception: Can raise any exception if it occurs in one of the mod_functions\n        \"\"\"\n        if isinstance(path, str):\n            l_path = path.split(Fagus._opt(self, \"value_split\", value_split)) if path else []\n        else:\n            l_path = list(path) if _is(path, Collection) else [path]\n        node = Fagus._get_mutable_node(\n            self,\n            l_path,\n            Fagus._opt(self, \"list_insert\", list_insert),\n            Fagus._opt(self, \"node_types\", node_types),\n            False,\n        )\n        if node is _None:\n            return [] if Fagus._opt(self, \"default_node_type\") == \"l\" else {}\n        if copy:\n            node = Fagus.__copy__(node)\n        if not (\n            mod_functions is None\n            or all(\n                k in (\"default\", \"tuple_keys\")\n                or all(isinstance(e, type) for e in (k if _is(k, Iterable) else (k,)))\n                and callable(v)\n                for k, v in mod_functions.items()\n            )\n        ):\n            raise ValueError(\n                \"mod_functions must be a dict with types (or tuples of types) as keys and function pointers \"\n                \"(either lambda or wrapped in TFunc-nodeects) as values.\"\n            )\n        return Fagus._serialize_r(\n            node,\n            {\n                **{\n                    datetime: lambda x: x.isoformat(\" \", \"seconds\"),\n                    date: lambda x: x.isoformat(),\n                    time: lambda x: x.isoformat(\"seconds\"),\n                    \"default\": lambda x: repr(x),\n                },\n                **({} if mod_functions is None else mod_functions),\n            },\n        )\n\n    @staticmethod\n    def _serialize_r(node: Union[dict, list], mod_functions: Mapping):\n        \"\"\"Recursive function that returns a node where all the keys and values are serializable\"\"\"\n        for k, v in list(node.items() if isinstance(node, MutableMapping) else enumerate(node)):\n            ny_k, ny_v = _None, _None\n            if not isinstance(k, (bool, float, int, str)) and k is not None:\n                if isinstance(k, tuple):\n                    if \"tuple_keys\" in mod_functions:\n                        ny_k = mod_functions[\"tuple_keys\"](k)\n                    else:\n                        raise ValueError(\n                            \"Dicts with composite keys (tuples) are not supported in serialized objects. \"\n                            'Use \"tuple_keys\" to define a specific mod_function for these dict-keys.'\n                        )\n                else:\n                    ny_k = Fagus._serializable_value(k, mod_functions)\n            if _is(v, Collection):\n                if isinstance(v, (dict, list)):\n                    Fagus._serialize_r(v, mod_functions)\n                else:\n                    ny_v = dict(v.items()) if isinstance(v, Mapping) else list(v)\n                    Fagus._serialize_r(ny_v, mod_functions)\n            elif not isinstance(v, (bool, float, int, str)) and v is not None:\n                ny_v = Fagus._serializable_value(v, mod_functions)\n            if ny_k is not _None:\n                node.pop(k)\n                node[ny_k] = v if ny_v is _None else ny_v\n            elif ny_v is not _None:\n                node[k] = ny_v\n        return node\n\n    @staticmethod\n    def _serializable_value(value, mod_functions):\n        \"\"\"Returns the value modified through the mod-function for its type\"\"\"\n        for types, mod_function in mod_functions.items():\n            if type(value) == types or (_is(types, Collection) and type(value) in types):\n                return mod_function(value)\n        return mod_functions[\"default\"](value)\n\n    def merge(\n        self: Collection,\n        obj: Union[\"FagusIterator\", Collection],\n        path: Any = \"\",\n        new_value_action: str = \"r\",\n        extend_from: int = INF,\n        update_from: int = INF,\n        fagus: bool = ...,\n        copy: bool = False,\n        copy_obj: bool = False,\n        value_split: str = ...,\n        node_types: str = ...,\n        list_insert: int = ...,\n        default_node_type: str = ...,\n    ) -> Collection:\n        \"\"\"Merges two or more tree-objects to update and extend the root node\n\n        Args:\n            obj: tree-object that shall be merged. Can also be a FagusIterator returned from iter() to only merge\n                values matching a filter defined in iter()\n            path: position in root where the new objects shall be merged, default \"\"\n            new_value_action: This parameter defines what merge is supposed to do if a value at a path is present in the\n                root and in one of the objects to merge. The possible values are: (r)eplace - the value in the root is\n                replaced with the new value, this is the default behaviour; (i)gnore - the value in the root is not\n                updated; (a)ppend - the old and new value are both put into a list, and thus aggregated\n            extend_from: By default, lists are traversed, so the value at index i will be compared in both lists. If\n                at some point you rather want to just append the contents from the objects to be merged, use this\n                parameter to define the level (count of keys) from which lists should be extended isf traversed. Default\n                infinite (never extend lists)\n            update_from: Like extend_from, but for dicts. Allows you to define at which level the contents of the root\n                should just be updated with the contents of the objects instead of traversing and comparing each value\n            fagus: whether the returned tree-object should be returned as Fagus\n            copy: Don't modify the root node, modify and return a copy instead\n            copy_obj: The objects to be merged are not modified, but references to subnodes of the objects can be\n                put into the root node. Set this to True to prevent that and keep root and objects independent\n            value_split: \\\\* used to split path into a list if path is a str, default \" \"\n            node_types: \\\\* Can be used to manually define if the nodes along path are supposed to be (l)ists or\n                (d)icts. E.g. \"dll\" to create a dict at level 1, and lists at level 2 and 3. \" \" can also be used -\n                space doesn't enforce a node-type like d or l. For \" \", existing nodes are traversed if possible,\n                otherwise default_node_type is used to create new nodes. Default \"\", interpreted as \" \" at each level.\n            list_insert: \\\\* Level at which a new node shall be inserted into the list instead of traversing the\n                existing node in the list at that index. See README\n            default_node_type: \\\\* determines if new nodes by default should be created as (d)ict or (l)ist. Must be\n                either \"d\" or \"l\", default \"d\"\n\n        Returns:\n            a reference to the modified root node, or a modified copy of the root node (see copy-parameter)\n\n        Raises:\n            ValueError: if it isn't possible to parse an int-index from the provided key in a position where node-types\n                defines that the node shall be a list (if node-types is not l, the node will be replaced with a dict)\n            TypeError: if obj is not either a FagusIterator or a Collection. Also raised if you try to merge different\n                types of nodes at root level, e.g. a dict can only be merged with another Mapping, and a list can only\n                be merged with another Iterable. ~ is also raised if a not modifiable root node needs to be modified\n        \"\"\"\n        if new_value_action[0:1] not in \"ria\":\n            raise ValueError(\n                f\"Invalid new_value_action: {new_value_action}. Valid inputs: (r)eplace, (i)gnore or (a)ppend.\"\n            )\n        node = Fagus.get(self, path, _None, False, copy, value_split)\n        if node is _None or not _is(node, Collection):\n            if isinstance(obj, FagusIterator):\n                object_ = obj.obj()\n            elif _is(obj, Collection):\n                object_ = obj.root if isinstance(obj, Fagus) else obj\n            else:\n                raise TypeError(f\"Can merge with FagusIterator or Collection, but not with {type(obj).__name__}\")\n            if copy_obj:\n                object_ = Fagus.__copy__(object_)\n            if not copy:\n                Fagus.set(self, object_, path, node_types, list_insert, value_split, False, _None, default_node_type)\n            return Fagus.child(self, object_) if Fagus._opt(self, \"fagus\", fagus) else object_\n        base_nodes = [node]\n        iter_options = dict(\n            max_depth=extend_from + update_from,\n            fagus=False,\n            iter_fill=_None,\n            iter_nodes=True,\n            copy=copy_obj,\n            filter_ends=True,\n        )\n        if isinstance(obj, FagusIterator):\n            obj_iter = obj\n            obj_iter.__dict__.update(**iter_options)\n        elif _is(obj, Collection):\n            obj_iter = FagusIterator(obj if isinstance(obj, Fagus) else Fagus.child(self, obj), **iter_options)\n        else:\n            raise TypeError(f\"Can merge with FagusIterator or Collection, but not with {type(obj).__name__}\")\n        node_type, mutable_node = Fagus._node_type(node, True)\n        obj_type = Fagus._node_type(obj_iter.obj())\n        if not extend_from or not update_from or node_type != obj_type or node_type == Set:\n            if obj_type == Mapping:\n                if node_type == Mapping and not update_from:\n                    node.update(obj_iter.obj())\n                    return Fagus.child(self, node) if Fagus._opt(self, \"fagus\", fagus) else node\n            elif node_type == Set:\n                node.update(obj_iter.obj())\n                return Fagus.child(self, node) if Fagus._opt(self, \"fagus\", fagus) else node\n            elif node_type == Sequence and not extend_from or obj_type != Sequence:\n                node.extend(obj_iter.obj())\n                return Fagus.child(self, node) if Fagus._opt(self, \"fagus\", fagus) else node\n            raise TypeError(\n                f\"Unsupported operand types for merge: {node_type.__name__} and {obj_type.__name__}. The types \"\n                \"have to be equal, additionally a Sequence can be extended with a Set and a Set can be updated \"\n                \"with anything except from a Mapping.\"\n            )\n        for path in obj_iter:\n            i = obj_iter.deepest_change\n            if i < len(base_nodes):\n                del base_nodes[i + 1 :]\n                node = base_nodes[-1]\n                node_type, mutable_node = Fagus._node_type(node, True)\n                try:\n                    for i, k in enumerate(path[1 + i * 2 : -3 : 2], start=i):\n                        obj_node_type = Fagus._node_type(path[2 * i])\n                        extend_sequence = extend_from <= i and node_type == Sequence\n                        if extend_sequence or update_from <= i or node_type == Set:\n                            if not mutable_node:\n                                Fagus._ensure_mutable_node(base_nodes, path[1:-1:2])\n                                mutable_node = True\n                            getattr(node, \"extend\" if extend_sequence else \"update\")(obj_iter.skip(i, copy_obj))\n                            raise StopIteration\n                        try:\n                            if node_type == obj_node_type:\n                                new_node = node[k]\n                                if _is(new_node, Collection):\n                                    node = new_node\n                                    node_type, mutable_node = Fagus._node_type(node, True)\n                                    base_nodes.append(node)\n                        except (IndexError, KeyError):\n                            if not mutable_node:\n                                node = Fagus._ensure_mutable_node(base_nodes, path[1:-1:2])\n                                mutable_node = True\n                            if node_type == Mapping:\n                                node[k] = obj_iter.skip(i + 1, copy_obj)\n                            elif node_type == Sequence:\n                                node.insert(k, obj_iter.skip(i + 1, copy_obj))\n                            else:\n                                node.add(obj_iter.skip(i + 1, copy_obj))\n                            raise StopIteration\n                except StopIteration:\n                    continue\n            old_value = Fagus.get(node, (path[2 * len(base_nodes) - 1],), _None)\n            if old_value is _None:\n                if not mutable_node:\n                    node = Fagus._ensure_mutable_node(base_nodes, path[1 : 2 * len(base_nodes) : 2])\n                    mutable_node = True\n                if node_type == Mapping:\n                    node[path[2 * len(base_nodes) - 1]] = path[-1]\n                else:\n                    getattr(node, \"append\" if node_type == Sequence else \"add\")(path[-1])\n            else:\n                if new_value_action[0:1] == \"i\":\n                    continue\n                elif new_value_action[0:1] == \"a\":\n                    if _is(old_value, MutableSequence):\n                        old_value.append(path[-1])\n                        continue\n                    new_value = [old_value, path[-1]]\n                else:\n                    new_value = path[2 * len(base_nodes)]\n                if not mutable_node:\n                    node = Fagus._ensure_mutable_node(base_nodes, path[1 : 2 * len(base_nodes) : 2])\n                    mutable_node = True\n                if node_type == Set:\n                    node.add(new_value)\n                elif new_value or not _is(new_value, Collection):\n                    node[path[2 * len(base_nodes) - 1]] = new_value\n        return Fagus.child(self, base_nodes[0]) if Fagus._opt(self, \"fagus\", fagus) else base_nodes[0]\n\n    def pop(self: Collection, path: Any = \"\", default=..., fagus: bool = ..., value_split: str = ...):\n        \"\"\"Deletes the value at path and returns it\n\n        \\\\* means that the parameter is a Fagus-Setting, see Fagus-class-docstring for more information about options\n\n        Args:\n            path: pop value at this position in self, or don't do anything if path doesn't exist in self\n            default: \\\\* returned if path doesn't exist in self\n            fagus: \\\\* return the result as Fagus-object if possible (default is just to return the result)\n            value_split: \\\\* used to split path into a list if path is a str, default \" \"\n\n        Returns:\n            value at path if it exists, or default if it doesn't\n\n        Raises:\n            TypeError: if the root node needs to be modified and isn't modifiable (e.g. tuple or frozenset)\n        \"\"\"\n        if isinstance(path, str):\n            l_path = path.split(Fagus._opt(self, \"value_split\", value_split)) if path else []\n        else:\n            l_path = list(path) if _is(path, Collection) else [path]\n        default = Fagus._opt(self, \"default\", default)\n        node = Fagus._get_mutable_node(self, l_path)\n        try:\n            if isinstance(node, MutableMapping):\n                node = node.pop(l_path[-1])\n            elif isinstance(node, MutableSequence):\n                node = node.pop(int(l_path[-1]))\n            elif isinstance(node, MutableSet):\n                node.remove(l_path[-1])\n                node = l_path[-1]\n            else:\n                node = default\n        except (IndexError, ValueError, KeyError):\n            node = default\n        return Fagus.child(self, node) if _is(node, Collection) and Fagus._opt(self, \"fagus\", fagus) else node\n\n    def popitem(self):\n        \"\"\"This function is not implemented in Fagus\"\"\"\n        pass\n\n    def discard(self: Collection, path: Any = \"\", value_split: str = ...) -> None:\n        \"\"\"Deletes the value at path if it exists\n\n        \\\\* means that the parameter is a Fagus-Setting, see Fagus-class-docstring for more information about options\n\n        Args:\n            path: pop value at this position in self, or don't do anything if path doesn't exist in self\n            value_split: \\\\* used to split path into a list if path is a str, default \" \"\n\n        Returns: None\n        \"\"\"\n        Fagus.pop(self, path, value_split=value_split)\n\n    def remove(self, path: Any = \"\", value_split: str = ...) -> None:\n        \"\"\"Deletes the value at path if it exists, raises KeyError if it doesn't\n\n        \\\\* means that the parameter is a Fagus-Setting, see Fagus-class-docstring for more information about options\n\n        Args:\n            path: pop value at this position in self, or don't do anything if path doesn't exist in self\n            value_split: \\\\* used to split path into a list if path is a str, default \" \"\n\n        Returns: None\n\n        Raises:\n            KeyError: if the value at path doesn't exist\n        \"\"\"\n        if Fagus.pop(self, path, _None, value_split=value_split) is _None:\n            raise KeyError(f\"Couldn't remove {path}: Does not exist\")\n\n    def keys(self: Collection, path: Any = \"\", value_split: str = ...):\n        \"\"\"Returns keys for the node at path, or None if that node is a set or doesn't exist / doesn't have keys\n\n        \\\\* means that the parameter is a Fagus-Setting, see Fagus-class-docstring for more information about options\n\n        Args:\n            path: get keys for node at this position in self. Default \"\" (gets values from the root node), See get()\n            value_split: \\\\* used to split path into a list if path is a str, default \" \"\n\n        Returns:\n            keys for the node at path, or an empty tuple if that node is a set or doesn't exist / doesn't have keys\n        \"\"\"\n        node = Fagus.get(self, path, fagus=False, value_split=value_split)\n        if isinstance(node, Mapping):\n            return node.keys()\n        if _is(node, Sequence):\n            return range(len(node))\n        if isinstance(node, Set):\n            return (... for _ in node)\n        return ()\n\n    def values(\n        self: Collection,\n        path: Any = \"\",\n        value_split: str = ...,\n        fagus: bool = ...,\n        copy: bool = False,\n    ):\n        \"\"\"Returns values for node at path\n\n        \\\\* means that the parameter is a Fagus-Setting, see Fagus-class-docstring for more information about options\n\n        Args:\n            path: get values at this position in self, default \"\" (gets values from the root node). See get()\n            value_split: \\\\* used to split path into a list if path is a str, default \" \"\n            fagus: \\\\* converts sub-nodes into Fagus-objects in the returned list of values, default False\n            copy: ~ creates a copy of the node before values() are returned. This can be beneficial if you want to make\n                changes to the returned nodes, but you don't want to change self. Default False\n\n        Returns:\n            values for the node at path. Returns an empty tuple if the value doesn't exist, or just the value in a\n            tuple if the node isn't iterable.\n        \"\"\"\n        node = Fagus.get(self, path, _None, value_split=value_split, fagus=False, copy=copy)\n        if _is(node, Collection):\n            values = node.values() if isinstance(node, Mapping) else node\n            if Fagus._opt(self, \"fagus\", fagus):\n                return (Fagus.child(self, e) if _is(e, Collection) else e for e in values)\n            return values\n        elif node is _None:\n            return ()\n        return (node,)\n\n    def items(\n        self: Collection,\n        path: Any = \"\",\n        value_split: str = ...,\n        fagus: bool = ...,\n        copy: bool = False,\n    ):\n        \"\"\"Returns in iterator of (key, value)-tuples in self, like dict.items()\n\n        \\\\* means that the parameter is a Fagus-Setting, see Fagus-class-docstring for more information about options\n\n        Args:\n            path: get items at this position in self, Default \"\" (gets values from the root node). See get()\n            value_split: \\\\* used to split path into a list if path is a str, default \" \"\n            fagus: \\\\* converts sub-nodes into Fagus-objects in the returned iterator, default False\n            copy: ~ creates a copy of the node before items() are returned. This can be beneficial if you want to make\n                changes to the returned nodes, but you don't want to change self. Default False\n\n        Returns:\n            iterator of (key, value)-tuples in self, like dict.items()\n        \"\"\"\n        node = Fagus.get(self, path, _None, False, copy, value_split)\n        if isinstance(node, Mapping):\n            items = node.items()\n        elif _is(node, Sequence):\n            items = enumerate(node)\n        elif isinstance(node, Set):\n            items = ((..., e) for e in node)\n        else:\n            return ()\n        if Fagus._opt(self, \"fagus\", fagus):\n            return ((k, Fagus.child(self, v) if _is(v, Collection) else v) for k, v in items)\n        return items\n\n    def clear(\n        self: Collection,\n        path: Any = \"\",\n        value_split: str = ...,\n        copy: bool = False,\n        fagus: bool = ...,\n    ) -> Collection:\n        \"\"\"Removes all elements from node at path.\n\n        \\\\* means that the parameter is a Fagus-Setting, see Fagus-class-docstring for more information about options\n\n        Args:\n            path: clear at this position in self, Default \"\" (gets values from the root node). See get()\n            value_split: \\\\* used to split path into a list if path is a str, default \" \"\n            copy: if ~ is set, a copy of self is modified and then returned (thus self is not modified), default False\n            fagus: \\\\* return self as a Fagus-object if it is a node (tuple / list / dict), default False\n\n        Returns:\n            self as a node if fagus is set, or a modified copy of self if copy is set\n\n        Raises:\n            TypeError: if the root node needs to be modified and isn't modifiable (e.g. tuple or frozenset)\n        \"\"\"\n        root = Fagus.__copy__(self) if copy else self\n        if isinstance(path, str):\n            l_path = path.split(Fagus._opt(self, \"value_split\", value_split)) if path else []\n        else:\n            l_path = list(path) if _is(path, Collection) else [path]\n        node = Fagus._get_mutable_node(root, l_path, parent=False)\n        if node is not _None:\n            node.clear()\n        if isinstance(root, Fagus):\n            return root if Fagus._opt(self, \"fagus\", fagus) else root()\n        return Fagus.child(self, root) if Fagus._opt(self, \"fagus\", fagus) else root\n\n    def contains(self: Collection, value, path: Any = \"\", value_split: str = ...) -> bool:\n        \"\"\"Check if value is present in the node at path\n\n        \\\\* means that the parameter is a Fagus-Setting, see Fagus-class-docstring for more information about options\n\n        Args:\n            value: value to check\n            path: check if value is in node at this position in self, Default \"\" (checks root node). See get()\n            value_split: \\\\* used to split path into a list if path is a str, default \" \"\n\n        Return:\n            whether value is in node at path in self. returns value == node if the node isn't iterable, and false if\n            path doesn't exit in self\"\"\"\n        node = Fagus.get(self, path, _None, fagus=False, value_split=value_split)\n        return value in node if _is(node, Collection) else value == node\n\n    def count(self: Collection, path: Any = \"\", value_split: str = ...) -> int:\n        \"\"\"Check the number of elements in the node at path\n\n        \\\\* means that the parameter is a Fagus-Setting, see Fagus-class-docstring for more information about options\n\n        Args:\n            path: position in self where the number of elements shall be found.Default \"\" (checks root node). See get()\n            value_split: \\\\* used to split path into a list if path is a str, default \" \"\n\n        Return:\n            the number of elements in the node at path. if there is no node at path, 0 is returned. If the element\n            at path is not a node, 1 is returned\n        \"\"\"\n        node = Fagus.get(self, path, _None, fagus=False, value_split=value_split)\n        return len(node) if _is(node, Collection) else 0 if node is _None else 1\n\n    def index(\n        self: Collection,\n        value: Any,\n        start: int = ...,\n        stop: int = ...,\n        path: Any = \"\",\n        all_: bool = False,\n        value_split: str = ...,\n    ) -> Optional[Union[int, Any, Sequence]]:\n        \"\"\"Returns the index / key of the specified value in the node at path if it exists\n\n        Args:\n            value: ~ to search index for\n            start: start searching at this index. Only applicable if the node at path is a list / tuple\n            stop: stop searching at this index. Only applicable if the node at path is a list / tuple\n            path: position in self where the node shall be searched for value. Default \"\" (checks root node). See get()\n            all_: returns all matching indices / keys in a generator (instead of only the first)\n            value_split: \\\\* used to split path into a list if path is a str, default \" \"\n\n        Returns:\n            The first index of value if the node at path is a list, or the first key containing value if the node at\n            path is a dict. True if the node at path is a Set and contains value. If the element can't be found in the\n            node at path, or there is no Collection at path, None is returned (instead of a ValueError).\n        \"\"\"\n        node = Fagus.get(self, path, None, False, False, value_split)\n        if isinstance(node, Set):\n            if all_:\n                return\n            return ((True,) if value in node else ()) if all_ else (True if value in node else None)\n        if isinstance(node, Mapping):\n            if all_:\n                return (k for k, v in node.items() if v == value)\n            for k, v in node.items():\n                if v == value:\n                    return k\n            return\n        if _is(node, Sequence):\n            if all_:\n                indices = []\n                try:\n                    start = 0 if start is ... else start\n                    stop = INF if stop is ... else (stop if stop >= 0 else len(node) + stop)\n                    while start < stop:\n                        indices.append(node.index(value, start, stop))\n                        start = indices[-1] + 1\n                except ValueError:\n                    pass\n                return indices\n            try:\n                return node.index(value, *((() if start is ... else (start,)) + (() if stop is ... else (stop,))))\n            except ValueError:\n                pass\n\n    def isdisjoint(\n        self: Collection, other: Iterable, path: Any = \"\", value_split: str = ..., dict_: str = \"keys\"\n    ) -> bool:\n        \"\"\"Returns whether the other iterable is disjoint (has no common items) with the node at path\n\n        \\\\* means that the parameter is a Fagus-Setting, see Fagus-class-docstring for more information about options\n\n        Args:\n            other: other object to check\n            path: check if the node at this position in self, is disjoint from other\n            value_split: \\\\* used to split path into a list if path is a str, default \" \"\n            dict_: use (k)eys, (v)alues or (i)tems for if value is a dict. Default keys\n\n        Returns: whether the other iterable is disjoint from the value at path. If value is a dict, the keys are used.\n            Checks if value is present in other if value isn't iterable. Returns True if there is no value at path.\n        \"\"\"\n        node = Fagus.get(self, path, _None, False, False, value_split)\n        if isinstance(node, Mapping):\n            if not dict_ or dict_[0] not in (\"k\", \"v\", \"i\"):\n                raise ValueError(f\"dict_ attribute must bei either (k)eys, (v)alues or (i)tems. You provided {dict_}\")\n            return set(getattr(node, {\"k\": \"keys\", \"v\": \"values\", \"i\": \"items\"}[dict_[0]])()).isdisjoint(other)\n        if isinstance(node, Set):\n            return node.isdisjoint(other)\n        return set(node).isdisjoint(other) if _is(node, Collection) else node not in other\n\n    def child(self: Collection, obj: Collection = None, **kwargs) -> \"Fagus\":\n        \"\"\"Creates a Fagus-object for obj that has the same options as self\"\"\"\n        return Fagus(obj, **({**self._options, **kwargs} if isinstance(self, Fagus) and self._options else kwargs))\n\n    def reversed(\n        self: Collection,\n        path: Any = \"\",\n        fagus: bool = ...,\n        value_split: str = ...,\n        copy: bool = False,\n    ):\n        \"\"\"Get reversed child-node at path if that node is a list\n\n        \\\\* means that the parameter is a Fagus-Setting, see Fagus-class-docstring for more information about options\n\n        Args:\n            path: position in self where a list / tuple shall be returned reversed\n            fagus: \\\\* converts sub-nodes into Fagus-objects in the returned iterator, default False\n            value_split: \\\\* used to split path into a list if path is a str, default \" \"\n            copy: ~ creates a copy of the node before it is returned reversed(). This can be beneficial if you want to\n                make changes to the returned nodes, but you don't want to change self. Default False\n\n        Returns:\n            a reversed iterator on the node at path (empty if path doesn't exist)\n        \"\"\"\n        node = Fagus.values(self, path, value_split, fagus, copy)\n        if not _is(node, Reversible):\n            node = tuple(node) if _is(node, Iterable) else (node,)\n        return reversed(node)\n\n    def reverse(\n        self: Collection,\n        path: Any = \"\",\n        fagus: bool = ...,\n        value_split: str = ...,\n        copy: bool = False,\n    ) -> Collection:\n        \"\"\"Reverse child-node at path if that node exists and is reversible\n\n        \\\\* means that the parameter is a Fagus-Setting, see Fagus-class-docstring for more information about options\n\n        Args:\n            path: position in self where a list / tuple shall be reversed\n            fagus: \\\\* converts sub-nodes into Fagus-objects in the returned iterator, default False\n            value_split: \\\\* used to split path into a list if path is a str, default \" \"\n            copy: ~ creates a copy of the node before it is returned reversed(). This can be beneficial if you want to\n                make changes to the returned nodes, but you don't want to change self. Default False\n\n        Returns:\n            self as a node if fagus is set, or a modified copy of self if copy is set\n\n        Raises:\n            TypeError: if the root node needs to be modified and isn't modifiable (e.g. tuple or frozenset)\n        \"\"\"\n        root = self.root if isinstance(self, Fagus) else self\n        if copy:\n            root = Fagus.__copy__(self)\n        if isinstance(path, str):\n            l_path = path.split(Fagus._opt(self, \"value_split\", value_split)) if path else []\n        else:\n            l_path = list(path) if _is(path, Collection) else [path]\n        if l_path:\n            parent = Fagus._get_mutable_node(root, l_path)\n            node = Fagus.get(parent, l_path[-1], _None, fagus=False)\n            if hasattr(node, \"reverse\"):\n                node.reverse()\n            elif isinstance(node, Mapping):  # if node.items() isn't reversible, the native error is thrown (that's ok)\n                parent[l_path[-1]] = dict(reversed(tuple(node.items())))\n            elif isinstance(node, Reversible):\n                parent[int(l_path[-1]) if isinstance(parent, Sequence) else l_path[-1]] = list(reversed(node))\n            elif node is not _None:\n                raise TypeError(f\"Cannot reverse node of type {type(node).__name__}.\")\n        else:\n            if hasattr(root, \"reverse\"):\n                root.reverse()\n            else:\n                if isinstance(root, MutableMapping):\n                    tmp = cp.copy(root)\n                    root.clear()\n                    root.update(reversed(tuple(tmp.items())))\n                elif isinstance(root, MutableSequence):\n                    tmp = cp.copy(root)\n                    root.clear()\n                    root.extend(reversed(tmp))\n                else:\n                    raise TypeError(f\"Cannot reverse root node of type {type(root).__name__}\")\n        return Fagus.child(self, root) if Fagus._opt(self, \"fagus\", fagus) else root\n\n    def copy(self: Collection, deep: bool = False):\n        \"\"\"Creates a copy of self. Creates a recursive shallow copy by default, or a copy.deepcopy() if deep is set.\"\"\"\n        if deep:\n            return cp.deepcopy(self)\n        return Fagus.__copy__(self)\n\n    def __options(  # at runtime, this function is renamed to options (see __init__). That was necessary to not override\n        self,  # options in FagusMeta when Fagus.options() is called, instead of a = Fagus(); a.options(). Little hack\n        options: dict = None,\n        get_default_options: bool = False,\n        reset: bool = False,\n    ) -> dict:\n        \"\"\"Function to set multiple Fagus-options in one line\n\n        Args:\n            options: dict with options that shall be set\n            get_default_options: return all options (include default-values). Default: only return options that are set\n            reset: if ~ is set, all options are reset before options is set\n\n        Returns:\n            a dict of options that are set, or all options if get_default_options is set\n        \"\"\"\n        if all(Fagus.__verify_option__(k, v) for k, v in options.items()) if options else True:\n            if reset or self._options is None:\n                self._options = options\n            elif options:\n                self._options.update(options)\n        return {\n            **{k: v[0] for k, v in (self.__default_options__ if get_default_options else {}).items()},\n            **Fagus.options(),\n            **(self._options if self._options else {}),\n        }\n\n    def _opt(self: Collection, option_name: str, option=...):\n        \"\"\"Internal function that is used for Fagus-options (see Fagus-help or README for more information)\"\"\"\n        if option is not ...:\n            return Fagus.__verify_option__(option_name, option)\n        return (\n            self._options[option_name]\n            if isinstance(self, Fagus) and isinstance(self._options, dict) and option_name in self._options\n            else getattr(Fagus, option_name)\n        )\n\n    @staticmethod\n    def _ensure_mutable_node(\n        nodes: List[Collection], path: Sequence, parent: bool = True\n    ) -> Union[MutableMapping, MutableSequence, MutableSet]:\n        \"\"\"Internal function that ensures that the current node (the last in nodes) is mutable\n\n        Args:\n            nodes: list of nodes that probably will be modified to make the last node mutable\n            path: list of keys used to traverse the nodes (and that link the nodes together)\n\n        Returns:\n            the node, but modifiable (a tuple will have turned into a list, a frozenset will have turned into a set)\n        \"\"\"\n        node = None\n        parent = int(not parent)\n        i = -1\n        for i in range(i, -len(nodes) - 1, -1):\n            node = nodes[i]\n            if _is(node, MutableMapping, MutableSequence, MutableSet):\n                break\n            elif i == -len(nodes):\n                raise TypeError(f\"Can't modify root node self having the immutable type {type(node).__name__}.\")\n        for i in range(i, -1):\n            if i == -2 and _is(nodes[i + 1], Set, is_not=MutableSet):\n                node[path[i + parent]] = set(nodes[i + 1])\n            else:\n                node[path[i + parent]] = (dict if isinstance(nodes[i + 1], Mapping) else list)(nodes[i + 1])\n            nodes[i] = node\n            node = node[path[i + parent]]\n        return node\n\n    def _get_mutable_node(\n        self: Collection, l_path: MutableSequence, list_insert: int = INF, node_types: str = \"\", parent: bool = True\n    ) -> Union[MutableMapping, MutableSequence, MutableSet, type(_None)]:\n        \"\"\"Internal function retrieving the parent_node, changing necessary nodes on the way to make it mutable\n\n        Args:\n            l_path: must already be a list, so a string from a calling path-function must already be split\n            list_insert: \\\\* Level at which a new node shall be inserted into the list instead of traversing the\n                existing node in the list at that index. See README\n            node_types: \\\\* Can be used to manually define if the nodes along path are supposed to be (l)ists or\n                (d)icts. E.g. \"dll\" to create a dict at level 1, and lists at level 2 and 3. \" \" can also be used -\n                space doesn't enforce a node-type like d or l. For \" \", existing nodes are traversed if possible,\n                otherwise default_node_type is used to create new nodes. Default \"\", interpreted as \" \" at each level.\n\n        Returns:\n            the parent node if it exists, otherwise None\n        \"\"\"\n        node = self.root if isinstance(self, Fagus) else self\n        nodes = [node]\n        node_types = Fagus._opt(self, \"node_types\", node_types)\n        try:\n            for i in range(len(l_path) - int(parent)):\n                if isinstance(node, Sequence):\n                    if list_insert <= 0 or node_types[i - 1 : i] == \"d\":\n                        return _None\n                    l_path[i] = int(l_path[i])\n                elif node_types[i - 1 : i] == \"l\":\n                    return _None\n                node = node[l_path[i]]\n                nodes.append(node)\n                list_insert -= 1\n            if _is(node, Collection):\n                return Fagus._ensure_mutable_node(nodes, l_path, parent)\n        except (IndexError, ValueError, KeyError):\n            pass\n        return _None\n\n    @staticmethod\n    def _node_type(node: Collection, check_mutable: bool = False) -> Union[Tuple[type, bool], type]:\n        \"\"\"Internal function. Returns the type of node, and if check_mutable is on also whether the node is mutable\n\n        Args:\n            node: the node whose type shall be checked\n            check_mutable: if this is on, a tuple is returned of the node-type and whether it is mutable\n\n        Returns:\n            Returns the type of node, and if check_mutable is on a tuple: (node-type, mutable) where mutable is a bool\n        \"\"\"\n        if check_mutable:\n            if isinstance(node, MutableMapping):\n                return Mapping, True\n            elif _is(node, MutableSequence):\n                return Sequence, True\n            elif isinstance(node, MutableSet):\n                return Set, True\n            elif isinstance(node, Mapping):\n                return Mapping, False\n            elif _is(node, Sequence):\n                return Sequence, False\n            elif isinstance(node, Set):\n                return Set, False\n            elif isinstance(node, Iterable):\n                return Iterable, False\n            else:\n                return type(node), False\n        if isinstance(node, Mapping):\n            return Mapping\n        elif _is(node, Sequence):\n            return Sequence\n        elif isinstance(node, Set):\n            return Set\n        elif isinstance(node, Iterable):\n            return Iterable\n        else:\n            return type(node)\n\n    def _hash(self) -> int:\n        \"\"\"Inherited from Set. Overridden to ensure that two equal Fagus's have equal hashes (ignoring options)\"\"\"\n        return hash(self.root)\n\n    def __copy__(self: Collection, recursive=False):\n        \"\"\"Recursively creates a shallow-copy of self\"\"\"\n        new_node = _copy_node(self.root if isinstance(self, Fagus) else self, recursive)\n        return Fagus.child(self, new_node) if isinstance(self, Fagus) else new_node\n\n    def __call__(self):\n        \"\"\"Calling the Fagus-object returns the root node the Fagus-object is wrapped around (equivalent to .root)\n\n        Example:\n            >>> from fagus import Fagus\n            >>> a = Fagus({\"f\": \"q\"})\n            >>> a\n            Fagus({'f': 'q'})\n            >>> a()\n            {'f': 'q'}\n            >>> a.root  # .root returns the root-object in the same way as ()\n            {'f': 'q'}\n\n        Returns:\n            the root object Fagus is wrapped around\n        \"\"\"\n        return self.root\n\n    def __getattr__(self, attr):  # Enable dot-notation for getting items at a path\n        if attr == \"root\":\n            return self.root\n        elif hasattr(Fagus, attr):\n            if isinstance(self._options, dict):\n                return self._options.get(attr, getattr(Fagus, attr))\n            return getattr(Fagus, attr)\n        else:\n            return self.get(attr.lstrip(Fagus._opt(self, \"value_split\") if isinstance(attr, str) else attr))\n\n    def __getitem__(self, item):  # Enable [] access for dict-keys at the top-level\n        return self.get(item)\n\n    def __setattr__(self, attr, value):  # Enable dot-notation for setting items at a given path\n        if attr in (\"root\", \"_options\", \"options\"):\n            super(Fagus, self).__setattr__(attr, value)\n        elif attr in Fagus.__default_options__:\n            if self._options is None:\n                super(Fagus, self).__setattr__(\"_options\", {})\n            self._options[attr] = Fagus.__verify_option__(attr, value)\n        else:\n            self.set(value, attr.lstrip(Fagus._opt(self, \"value_split\") if isinstance(attr, str) else attr))\n\n    def __setitem__(self, path, value):  # Enable [] for setting items at a given path\n        self.set(value, path)\n\n    def __delattr__(self, attr):  # Enable dot-notation for deleting items at a given path\n        if hasattr(Fagus, attr):\n            if self._options and attr in self._options:\n                del self._options[attr]\n                if not self._options:\n                    self._options = None\n        else:\n            self.pop(attr.lstrip(Fagus._opt(self, \"value_split\") if isinstance(attr, str) else attr))\n\n    def __delitem__(self, path):  # Enable [] for deleting items\n        self.pop(path)\n\n    def __iter__(self):\n        return iter(self.root if isinstance(self.root, Mapping) else self.values())\n\n    def __hash__(self):\n        return hash(self.root)\n\n    def __eq__(self, other):\n        return isinstance(other, Fagus) and self.root == other.root\n\n    def __ne__(self, other):\n        return not isinstance(other, Fagus) or self.root != other.root\n\n    def __lt__(self, other):\n        return self.root < (other.root if isinstance(other, Fagus) else other)\n\n    def __le__(self, other):\n        return self.root <= (other.root if isinstance(other, Fagus) else other)\n\n    def __gt__(self, other):\n        return self.root > (other.root if isinstance(other, Fagus) else other)\n\n    def __ge__(self, other):\n        return self.root >= (other.root if isinstance(other, Fagus) else other)\n\n    def __contains__(self, value):\n        return value in self.root\n\n    def __len__(self):\n        return len(self.root)\n\n    def __bool__(self):\n        return bool(self.root)\n\n    def __repr__(self):\n        return \"Fagus(%s)\" % \", \".join(\n            (repr(self.root), *(f\"{e[0]}={repr(e[1])}\" for e in (self._options.items() if self._options else ())))\n        )\n\n    def __str__(self):\n        return str(self.root)\n\n    def __iadd__(self, value):\n        self.merge(value)\n        return self\n\n    def __add__(self, other):\n        res = Fagus.merge(self, other, copy=True)\n        return self.child(res) if Fagus._opt(self if isinstance(self, Fagus) else other, \"fagus\") else res\n\n    def __radd__(self, other):\n        res = Fagus.merge(other if isinstance(other, Fagus) else self.child(other), self, copy=True)\n        return self.child(res) if Fagus._opt(self if isinstance(self, Fagus) else other, \"fagus\") else res\n\n    def __isub__(self, other):\n        if isinstance(self.root, (MutableMapping, MutableSet)):\n            for e in other if _is(other, Iterable) else (other,):\n                self.root.pop(e, None)\n        elif isinstance(self.root, MutableSequence):\n            other = set(other() if isinstance(other, Fagus) else other) if _is(other, Iterable) else (other,)\n            for i in (k for k, v in enumerate(self.root) if v in other):\n                self.root.pop(i)\n        else:\n            raise TypeError(\n                \"Unsupported operand types for -=: Can't remove items from self being an immutable \"\n                f\"{type(self.root).__name__}.\"\n            )\n        return self\n\n    def __sub__(self, other):\n        root = self.root if isinstance(self, Fagus) else self\n        other = set(other() if isinstance(other, Fagus) else other) if _is(other, Iterable) else (other,)\n        if isinstance(root, Mapping):\n            res = {k: v for k, v in root.items() if k not in other}\n        else:  # isinstance(self(), (Sequence, Set)):\n            res = (set if isinstance(root, Set) else list)(filter(lambda x: x not in other, root))\n        return self.child(res) if Fagus._opt(self if isinstance(self, Fagus) else other, \"fagus\") else res\n\n    def __rsub__(self, other):\n        return Fagus.__sub__(other, self)\n\n    def __imul__(self, times: int):\n        if not isinstance(times, int):\n            raise TypeError(f\"Unsupported operand types for *: times must b an int, got {type(times).__name__}.\")\n        if _is(self.root, MutableSequence):\n            self.root.extend(tuple(self.root) * (times - 1))\n            return self\n        raise TypeError(f\"Unsupported operand types for *=: root node must be a list, got {type(self.root).__name__}.\")\n\n    def __mul__(self, times: int):\n        if not isinstance(times, int):\n            raise TypeError(f\"Unsupported operand types for *: times must b an int, got {type(times).__name__}.\")\n        if not _is(self(), Sequence):\n            raise TypeError(\n                \"Unsupported operand types for *: root node must a tuple or list to get multiplied, got \"\n                f\"{type(self.root).__name__}.\"\n            )\n        return self.child(self() * times) if Fagus._opt(self, \"fagus\") else self() * times\n\n    def __rmul__(self, times: int):\n        return Fagus.__mul__(self, times)\n\n    def __reversed__(self):\n        return self.reversed()\n\n    def __reduce__(self):\n        return self.root.__reduce__()\n\n    def __reduce_ex__(self, protocol):\n        return self.root.__reduce_ex__(protocol)\n"}