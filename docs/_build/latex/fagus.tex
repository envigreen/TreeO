%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}


\usepackage{lmodern}


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{2}



\title{Fagus}
\date{Aug 21, 2023}
\release{1.1.0}
\author{Lukas Neuenschwander}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxstepscope


\chapter{ISC License}
\label{\detokenize{LICENSE:isc-license}}\label{\detokenize{LICENSE::doc}}
\sphinxAtStartPar
Copyright (c) 2022 Lukas Neuenschwander

\sphinxAtStartPar
Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies.

\sphinxAtStartPar
THE SOFTWARE IS PROVIDED “AS IS” AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

\sphinxstepscope


\chapter{README}
\label{\detokenize{README:readme}}\label{\detokenize{README::doc}}
\sphinxAtStartPar
These days most data is converted to and from \sphinxcode{\sphinxupquote{json}} and \sphinxcode{\sphinxupquote{yaml}} while it is sent back and forth to and from API’s. Often this data is deeply nested. \sphinxcode{\sphinxupquote{Fagus}} is a Python\sphinxhyphen{}library that makes it easier to work with nested dicts and lists. It allows you to traverse and edit these tree\sphinxhyphen{}objects with simple function calls that handle the most common errors and exceptions internally. The name fagus is actually the latin name for the genus of beech\sphinxhyphen{}trees.


\section{Code and tests ready, documentation still WORK IN PROGRESS}
\label{\detokenize{README:code-and-tests-ready-documentation-still-work-in-progress}}
\sphinxAtStartPar
This documentation is still Work in Progress. I have some more ideas for features, but most of the coding is done. The code is tested as good as possible, but of course there still might be bugs as this library has just been released. Just report them so we get them away ;). Even though this README is not done yet, you should be able to use most of the functions based on the docstrings and some trial and error. Just ask questions \sphinxhref{https://github.com/treeorg/Fagus/discussions/categories/q-a}{here} if sth is unclear. The documentation will be filled in and completed as soon as possible.

\sphinxAtStartPar
\sphinxstylestrong{HAVE FUN!}


\section{Basic principles}
\label{\detokenize{README:basic-principles}}

\subsection{Introduction \textendash{} What it solves}
\label{\detokenize{README:introduction-what-it-solves}}
\sphinxAtStartPar
Imagine you want to fetch values from a nested dict as shown below:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{d1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{6}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} prints 2, so far so good}
\PYG{g+go}{2}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} fails, because b3 doesn\PYGZsq{}t exist}
\PYG{g+gt}{Traceback (most recent call last):}
\PYG{+w}{ }\PYG{c}{...}
\PYG{g+gr}{KeyError}: \PYG{n}{\PYGZsq{}b3\PYGZsq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The problem is that the consecutive square brackets fail if one of the nodes doesn’t exist. There are ways around, like writing \sphinxcode{\sphinxupquote{a.get("a1", \{\}).get("b3", \{\}).get("c2")}} or surrounding each of these statements with \sphinxcode{\sphinxupquote{try\sphinxhyphen{}except}}, but both are hard to maintain and verbose. Below you can see how \sphinxcode{\sphinxupquote{Fagus}} can help to resolve this:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{fagus} \PYG{k+kn}{import} \PYG{n}{Fagus}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{Fagus}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} None, as this key doesn\PYGZsq{}t exist in a}
\PYG{g+go}{None}
\end{sphinxVerbatim}

\sphinxAtStartPar
As you can see, now only one function call is needed to fetch the value from \sphinxcode{\sphinxupquote{a}}. If one of the keys doesn’t exist, a default value is returned. In this case no default value was specified, so \sphinxcode{\sphinxupquote{None}} is returned.

\sphinxAtStartPar
The whole \sphinxcode{\sphinxupquote{Fagus}} library is built around these principles. It provides:
\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{Simple functions}: replacing tedious code that is hard to maintain and error prone

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Few exceptions}: Rather than raising a lot of exceptions, \sphinxcode{\sphinxupquote{Fagus}} does what is most likely the programmer’s intention.

\end{itemize}


\subsection{The path\sphinxhyphen{}parameter}
\label{\detokenize{README:the-path-parameter}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Fagus}} is built around the concept of a Mapping or dict, where there are keys that are used to refer to values. For lists, the indices are used as keys. In opposition to a simple dict, in \sphinxcode{\sphinxupquote{Fagus}} the key can consist of multiple values \textendash{} one for each layer.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{6}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{fg}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{]}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Fagus}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}v1\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Fagus}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2 \PYGZhy{}1 fg}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}v2\PYGZsq{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{Line 3}: The path\sphinxhyphen{}parameter is the tuple in the second argument of the get\sphinxhyphen{}function. The first and third element in that tuple are list\sphinxhyphen{}indices, whereas the second and fourth element are dict\sphinxhyphen{}keys.

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Line 5}: In many cases, the dict\sphinxhyphen{}keys that are traversed are strings. For convenience, it’s also possible to provide the whole path\sphinxhyphen{}parameter as one string that is split up into the different keys. In the example above, \sphinxcode{\sphinxupquote{" "}} is used to split the path\sphinxhyphen{}string, this can be customized using the {\hyperref[\detokenize{README:path-split}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{path\_split}}}}}} {\hyperref[\detokenize{README:fagus-options}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{FagusOption}}}}}}.

\end{itemize}


\subsection{Static and instance usage}
\label{\detokenize{README:static-and-instance-usage}}
\sphinxAtStartPar
All functions in \sphinxcode{\sphinxupquote{Fagus}} can be used statically, or on a \sphinxcode{\sphinxupquote{Fagus}}\sphinxhyphen{}instance, so the following two calls of {\hyperref[\detokenize{README:the-path-parameter}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{get()}}}}}} give the same result:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{6}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{fg}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{]}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Fagus}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2 0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}e\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b} \PYG{o}{=} \PYG{n}{Fagus}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2 0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}e\PYGZsq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The first call of {\hyperref[\detokenize{README:the-path-parameter}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{get()}}}}}} in line 3 is static, as we have seen before. No \sphinxcode{\sphinxupquote{Fagus}} instance is required, the object \sphinxcode{\sphinxupquote{a}} is just passed as the first parameter. In line 5, \sphinxcode{\sphinxupquote{b}} is created as a \sphinxcode{\sphinxupquote{Fagus}}\sphinxhyphen{}instance \textendash{} calling {\hyperref[\detokenize{README:the-path-parameter}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{get()}}}}}} on \sphinxcode{\sphinxupquote{b}} also yields \sphinxcode{\sphinxupquote{e}}.

\sphinxAtStartPar
While it’s not necessary to instantiate \sphinxcode{\sphinxupquote{Fagus}}, there are some neat shortcuts that are only available to \sphinxcode{\sphinxupquote{Fagus}}\sphinxhyphen{}instances:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Fagus}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x y z}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{6}  \PYG{c+c1}{\PYGZsh{} a = \PYGZob{}\PYGZdq{}x\PYGZdq{}: \PYGZob{}\PYGZdq{}y\PYGZdq{}: \PYGZob{}\PYGZdq{}z\PYGZdq{}: 6\PYGZcb{}\PYGZcb{}\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{x}  \PYG{c+c1}{\PYGZsh{} returns the whole subnode at a[\PYGZdq{}x\PYGZdq{}]}
\PYG{g+go}{\PYGZob{}\PYGZsq{}y\PYGZsq{}: \PYGZob{}\PYGZsq{}z\PYGZsq{}: 6\PYGZcb{}\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{del} \PYG{n}{a}\PYG{p}{[}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{y}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{z}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} Delete the z\PYGZhy{}subnode in a[\PYGZdq{}x y z\PYGZdq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}\PYGZsq{}x\PYGZsq{}: \PYGZob{}\PYGZsq{}y\PYGZsq{}: \PYGZob{}\PYGZcb{}\PYGZcb{}\PYGZcb{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{Square bracket notation}: On \sphinxcode{\sphinxupquote{Fagus}}\sphinxhyphen{}instances, the square\sphinxhyphen{}bracket notation can be used for easier access of data if no further customization is needed. Line 3 is equivalent to \sphinxcode{\sphinxupquote{a.set(6, "x y z")}}. It can be used for getting, setting and deleting items (line 6).

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Dot notation}: The dot\sphinxhyphen{}notation is activated for setting, getting and deleting items as well (line 4). It can be used to access \sphinxcode{\sphinxupquote{str}}\sphinxhyphen{}keys in \sphinxcode{\sphinxupquote{dict}}s and \sphinxcode{\sphinxupquote{list}}\sphinxhyphen{}indices, the index must then be preceded with an underscore due to Python naming limitations (\sphinxcode{\sphinxupquote{a.\_4}}). This can be further customized using the {\hyperref[\detokenize{README:path-split}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{path\_split}}}}}} {\hyperref[\detokenize{README:fagus-options}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{FagusOption}}}}}}.

\end{itemize}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Fagus}} is a wrapper\sphinxhyphen{}class around a tree of \sphinxcode{\sphinxupquote{dict}}\sphinxhyphen{} or \sphinxcode{\sphinxupquote{list}}\sphinxhyphen{}nodes. To get back the root\sphinxhyphen{}object inside the instance, use \sphinxcode{\sphinxupquote{()}} to call the object \textendash{} this is shown in line 7. Alternatively you can get the root\sphinxhyphen{}object through \sphinxcode{\sphinxupquote{.root}}.


\subsection{Fagus options}
\label{\detokenize{README:fagus-options}}
\sphinxAtStartPar
There are several parameters used across many functions in \sphinxcode{\sphinxupquote{Fagus}} steering the behaviour of that function. Often, similar behaviour is intended across a whole application or parts of it, and this is where options come in handy allowing to only specify these parameters once instead of each time a function is called.

\sphinxAtStartPar
One example of a \sphinxcode{\sphinxupquote{Fagus}}\sphinxhyphen{}option is {\hyperref[\detokenize{README:default}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{default}}}}}}. This option contains the value that is returned e.g. in {\hyperref[\detokenize{README:the-path-parameter}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{get()}}}}}} if a {\hyperref[\detokenize{README:the-path-parameter}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{path}}}}}} doesn’t exist, see {\hyperref[\detokenize{README:introduction-what-it-solves}]{\sphinxcrossref{\DUrole{std,std-doc}{Introduction}}}}, code block two for an example of {\hyperref[\detokenize{README:default}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{default}}}}}}.

\sphinxAtStartPar
There are four levels at which an option can be set, where the higher levels take precedence over the lower levels:

\sphinxAtStartPar
\sphinxstylestrong{The four levels of \sphinxcode{\sphinxupquote{Fagus}}\sphinxhyphen{}options}:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
\sphinxstylestrong{Default}: If no other level is specified, the hardcoded default for that option is used.

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Class}: If an option is set at class level (i.e. \sphinxcode{\sphinxupquote{Fagus.option}}), it applies to all function calls and all instances where level one and two of that option aren’t defined. Options at this level apply for the whole file \sphinxcode{\sphinxupquote{Fagus}} has been imported in.

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Instance}: If an option is set for an instance, it will apply to all function calls at that instance where the option wasn’t overriden by an argument.

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Argument}: The highest level \sphinxhyphen{} if an option is specified directly as an argument to a function, that value takes precedence over all other levels.

\end{enumerate}

\sphinxAtStartPar
Below is an example of how the different levels take precedence over one another:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Fagus}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} b does not exist in a \PYGZhy{} default is None by default}
\PYG{g+go}{None}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Fagus}\PYG{o}{.}\PYG{n}{default} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{class}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{c+c1}{\PYGZsh{} Overriding default at class level (level 2)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} now \PYGZsq{}class\PYGZsq{} is returned, as None was overridden}
\PYG{g+go}{\PYGZsq{}class\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{default} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{instance}\PYG{l+s+s1}{\PYGZsq{}}  \PYG{c+c1}{\PYGZsh{} setting the default option at instance level (level 3)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} for a default is set to \PYGZsq{}instance\PYGZsq{} \PYGZhy{}\PYGZhy{} return \PYGZsq{}instance\PYGZsq{}}
\PYG{g+go}{\PYGZsq{}instance\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b} \PYG{o}{=} \PYG{n}{Fagus}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} for b, line 7 doesn\PYGZsq{}t apply \PYGZhy{}\PYGZhy{} line 5 still applies}
\PYG{g+go}{\PYGZsq{}class\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{del} \PYG{n}{Fagus}\PYG{o}{.}\PYG{n}{default}  \PYG{c+c1}{\PYGZsh{} deleting an option resets it to its default}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{b}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} for default, the default is None}
\PYG{g+go}{None}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{default}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{arg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} passing an option as a parameter always wins}
\PYG{g+go}{\PYGZsq{}arg\PYGZsq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
All \sphinxcode{\sphinxupquote{Fagus}}\sphinxhyphen{}options at level three can be set in the constructor of \sphinxcode{\sphinxupquote{Fagus}}, so they don’t have to be set one by one like in line 8. You can also use \sphinxcode{\sphinxupquote{options()}} on an instance or on the \sphinxcode{\sphinxupquote{Fagus}}\sphinxhyphen{}class to set several options in one line, or get all the options that apply to an instance.

\sphinxAtStartPar
Some \sphinxcode{\sphinxupquote{Fagus}}\sphinxhyphen{}functions return child\sphinxhyphen{}\sphinxcode{\sphinxupquote{Fagus}}\sphinxhyphen{}objects in their result. These child\sphinxhyphen{}objects inherit the options at level three from their parent.

\sphinxAtStartPar
The remaining part of this section explains the \sphinxcode{\sphinxupquote{FagusOption}}s one by one.


\subsubsection{default}
\label{\detokenize{README:default}}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{Default}: \sphinxcode{\sphinxupquote{None}}

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Type}: \sphinxcode{\sphinxupquote{Any}}

\end{itemize}

\sphinxAtStartPar
This value is returned if the requested {\hyperref[\detokenize{README:the-path-parameter}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{path}}}}}} does not exist, for example in {\hyperref[\detokenize{README:the-path-parameter}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{get()}}}}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{fagus} \PYG{k+kn}{import} \PYG{n}{Fagus}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Fagus}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{default}\PYG{o}{=}\PYG{l+m+mi}{8}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} return 3, as \PYGZdq{}b\PYGZdq{} exists}
\PYG{g+go}{3}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Fagus}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{q}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{default}\PYG{o}{=}\PYG{l+m+mi}{8}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} return default 8, as \PYGZdq{}q\PYGZdq{} does not exist}
\PYG{g+go}{8}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{Fagus}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{q}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} \PYGZdq{}q\PYGZdq{} does not exist \PYGZhy{}\PYGZhy{} return None being default if it hasn\PYGZsq{}t been specified as arg}
\PYG{g+go}{None}
\end{sphinxVerbatim}


\subsubsection{default\_node\_type}
\label{\detokenize{README:default-node-type}}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{Default}: \sphinxcode{\sphinxupquote{"d"}}

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Type}: \sphinxcode{\sphinxupquote{str}}

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Allowed values}: \sphinxcode{\sphinxupquote{"d"}} and \sphinxcode{\sphinxupquote{"l"}}

\end{itemize}

\sphinxAtStartPar
Can be either \sphinxcode{\sphinxupquote{"d"}} for \sphinxcode{\sphinxupquote{dict}} or \sphinxcode{\sphinxupquote{"l"}} for \sphinxcode{\sphinxupquote{list}}. A new node of this type is created if it’s not specified clearly what other type that node shall have. It is used e.g. when Fagus is instanciated with an empty constructor:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Fagus}\PYG{o}{.}\PYG{n}{default\PYGZus{}node\PYGZus{}type} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{l}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Fagus}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} the root node of a is an empty list as this was set in line 2}
\PYG{g+go}{[]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{del} \PYG{n}{Fagus}\PYG{o}{.}\PYG{n}{default\PYGZus{}node\PYGZus{}type}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b} \PYG{o}{=} \PYG{n}{Fagus}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} the root node of b is a dict (default for default\PYGZus{}node\PYGZus{}type)}
\PYG{g+go}{\PYGZob{}\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Fagus}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} the root node of c is now also a list}
\PYG{g+go}{[]}
\end{sphinxVerbatim}

\sphinxAtStartPar
More information about how \sphinxcode{\sphinxupquote{default\_node\_type}} is used when new nodes need to be generated can be found in {\hyperref[\detokenize{README:basic-principles-for-modifying-the-tree}]{\sphinxcrossref{\DUrole{std,std-doc}{Basic principles for modifying the tree}}}} and the documentation of the \sphinxcode{\sphinxupquote{FagusOption}} {\hyperref[\detokenize{README:node-types}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{node\_types}}}}}}.


\subsubsection{if\_}
\label{\detokenize{README:if}}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{Default}: \sphinxcode{\sphinxupquote{\_None}}, meaning that the value is not checked

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Type}: Any

\end{itemize}

\sphinxAtStartPar
This option can be used to verify values before they’re inserted into the \sphinxcode{\sphinxupquote{Fagus}}\sphinxhyphen{}object. Generating configuration\sphinxhyphen{}files, default values can often be omitted whereas special settings shall be included, \sphinxcode{\sphinxupquote{if\_}} can be used to do this without an extra if\sphinxhyphen{}statement.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Fagus}\PYG{p}{(}\PYG{n}{if\PYGZus{}}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} the only allowed value for set is now True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{v1} \PYG{o}{=} \PYG{k+kc}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} v1 was set, because it was True (as requested in line 1)}
\PYG{g+go}{\PYGZob{}\PYGZsq{}v1\PYGZsq{}: True\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{v2} \PYG{o}{=} \PYG{k+kc}{None}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} note that v2 has not been set as it was not True}
\PYG{g+go}{\PYGZob{}\PYGZsq{}v1\PYGZsq{}: True\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{if\PYGZus{}}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} 6 was set as it was in (4, 5, 6)}
\PYG{g+go}{\PYGZob{}\PYGZsq{}v1\PYGZsq{}: True, \PYGZsq{}v2\PYGZsq{}: 6\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{if\PYGZus{}}\PYG{o}{=}\PYG{n+nb}{bool}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} v3 is not set because bool(\PYGZdq{}\PYGZdq{}) is False}
\PYG{g+go}{\PYGZob{}\PYGZsq{}v1\PYGZsq{}: True, \PYGZsq{}v2\PYGZsq{}: 6\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Possible ways to specify \sphinxcode{\sphinxupquote{if\_}}:
\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{Single value}: This is shown in line 1 \textendash{} the only values that can now be set is \sphinxcode{\sphinxupquote{True}}, anything else is not accepted.

\item {}
\sphinxAtStartPar
\sphinxstylestrong{List of values}: You can also specify any \sphinxcode{\sphinxupquote{Iterable}} (e.g. a \sphinxcode{\sphinxupquote{list}}) with multiple values \textendash{} the values that can be set must be one of the values in the \sphinxcode{\sphinxupquote{list}} (line 8).

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Callable}: You can also pass a callable object or a function (lambda) \textendash{} the result of that call determines whether the value is set (line 10).

\end{itemize}


\subsubsection{iter\_fill}
\label{\detokenize{README:iter-fill}}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{Default}: \sphinxcode{\sphinxupquote{\_None}}, meaning that \sphinxcode{\sphinxupquote{iter\_fill}} is inactive

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Type}: Any

\end{itemize}

\sphinxAtStartPar
This option is used to get a constant number of items in the iterator while iterating over a \sphinxcode{\sphinxupquote{Fagus}}\sphinxhyphen{}object, see {\hyperref[\detokenize{README:iterating-over-nested-objects}]{\sphinxcrossref{\DUrole{std,std-doc}{here}}}} for more about iteration in \sphinxcode{\sphinxupquote{Fagus}}. The example below shows what happens by default when iterating over a \sphinxcode{\sphinxupquote{Fagus}}\sphinxhyphen{}object where the leaf\sphinxhyphen{}nodes are at different depths:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{Fagus}\PYG{o}{.}\PYG{n}{iter}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}
\PYG{g+go}{[(\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, 2), (\PYGZsq{}c\PYGZsq{}, 4)]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z} \PYG{o+ow}{in} \PYG{n}{a}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}
\PYG{g+gt}{Traceback (most recent call last):}
\PYG{c}{...}
\PYG{g+gr}{ValueError}: \PYG{n}{not enough values to unpack (expected 3, got 2)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{Fagus}\PYG{o}{.}\PYG{n}{iter}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{iter\PYGZus{}fill}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}
\PYG{g+go}{[(\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, 2), (\PYGZsq{}c\PYGZsq{}, 4, None)]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z} \PYG{o+ow}{in} \PYG{n}{a}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}
\PYG{g+go}{a b 2}
\PYG{g+go}{c 4 None}
\end{sphinxVerbatim}

\sphinxAtStartPar
In line 3, we see that the first tuple has three items, and the second only two. When this is run in a loop that always expects three values to unpack, it fails (line 4\sphinxhyphen{}8). That problem is solved in line 9 by using \sphinxcode{\sphinxupquote{iter\_fill}}, which fills up the shorter tuples with the value that was specified for \sphinxcode{\sphinxupquote{iter\_fill}}, here \sphinxcode{\sphinxupquote{None}}. With that in place, the loop in line 12\sphinxhyphen{}15 runs through without raising an error. Note that \sphinxcode{\sphinxupquote{max\_depth}} has to be specified for \sphinxcode{\sphinxupquote{Fagus}} to know how many items to fill up to.


\subsubsection{iter\_nodes}
\label{\detokenize{README:iter-nodes}}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{Default}: \sphinxcode{\sphinxupquote{False}}

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Type}: \sphinxcode{\sphinxupquote{bool}}

\end{itemize}

\sphinxAtStartPar
This option is used to get references to the traversed nodes while iterating on a \sphinxcode{\sphinxupquote{Fagus}}\sphinxhyphen{}object, see {\hyperref[\detokenize{README:iterating-over-nested-objects}]{\sphinxcrossref{\DUrole{std,std-doc}{here}}}} for more about iteration in \sphinxcode{\sphinxupquote{Fagus}}. Below is an example of what this means:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{Fagus}\PYG{o}{.}\PYG{n}{iter}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{[(\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, 2), (\PYGZsq{}c\PYGZsq{}, 4)]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{Fagus}\PYG{o}{.}\PYG{n}{iter}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{iter\PYGZus{}nodes}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{[(\PYGZob{}\PYGZsq{}a\PYGZsq{}: \PYGZob{}\PYGZsq{}b\PYGZsq{}: 2\PYGZcb{}, \PYGZsq{}c\PYGZsq{}: 4\PYGZcb{}, \PYGZsq{}a\PYGZsq{}, \PYGZob{}\PYGZsq{}b\PYGZsq{}: 2\PYGZcb{}, \PYGZsq{}b\PYGZsq{}, 2), (\PYGZob{}\PYGZsq{}a\PYGZsq{}: \PYGZob{}\PYGZsq{}b\PYGZsq{}: 2\PYGZcb{}, \PYGZsq{}c\PYGZsq{}: 4\PYGZcb{}, \PYGZsq{}c\PYGZsq{}, 4)]}
\end{sphinxVerbatim}

\sphinxAtStartPar
As you can see, the node itself is included as the first element in both tuples. In the first tuple, we also find the subnode \sphinxcode{\sphinxupquote{\{"b": 2\}}} as the third element. In line 2, the tuples are filled after this scheme: \sphinxcode{\sphinxupquote{key1, key2, key3, ..., value}}. In line 4, we additionally get the nodes, so it is \sphinxcode{\sphinxupquote{root\sphinxhyphen{}node, key1, node, key2, node2, key3, ..., value}}.

\sphinxAtStartPar
Sometimes in loops it can be helpful to actually have access to the whole node containing other relevant information. This can be especially useful combined with {\hyperref[\detokenize{README:skipping-nodes-in-iteration}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{skip()}}}}}}.


\subsubsection{list\_insert}
\label{\detokenize{README:list-insert}}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{Default}: \sphinxcode{\sphinxupquote{INF}} (infinity, defined as \sphinxcode{\sphinxupquote{sys.maxsize}}, the max value of an \sphinxcode{\sphinxupquote{int}} in Python)

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Type}: \sphinxcode{\sphinxupquote{int}}

\end{itemize}

\sphinxAtStartPar
By default, \sphinxcode{\sphinxupquote{list}}\sphinxhyphen{}nodes are traversed in Fagus when new items are inserted. New \sphinxcode{\sphinxupquote{list}}\sphinxhyphen{}nodes are only created if necessary. Consider the following example:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Fagus}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{insert\PYGZus{}1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{[0, [3, 4, \PYGZsq{}insert\PYGZus{}1\PYGZsq{}, 2]]}
\end{sphinxVerbatim}

\sphinxAtStartPar
The list \sphinxcode{\sphinxupquote{{[}5, 6{]}}} is overridden with the new value \sphinxcode{\sphinxupquote{"insert\_1"}}. In some cases it is desirable to insert a new value into one of the lists rather than just overwriting the existing value. This is where \sphinxcode{\sphinxupquote{list\_insert}} comes into the picture. For some background of how \sphinxcode{\sphinxupquote{list}}\sphinxhyphen{}indices work in \sphinxcode{\sphinxupquote{Fagus}}, you can check out {\hyperref[\detokenize{README:correctly-handling-list-indices}]{\sphinxcrossref{\DUrole{std,std-doc}{this section}}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Fagus}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{default\PYGZus{}node\PYGZus{}type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{l}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{insert\PYGZus{}2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{list\PYGZus{}insert}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} [5, 6] was not overridden here, insert\PYGZus{}2 is inserted before}
\PYG{g+go}{[0, [3, 4, \PYGZsq{}insert\PYGZus{}2\PYGZsq{}, [5, 6], 2]]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{insert\PYGZus{}3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{list\PYGZus{}insert}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} here, insert\PYGZus{}3 is inserted at the base level 0, again without overriding}
\PYG{g+go}{[0, [\PYGZsq{}insert\PYGZus{}3\PYGZsq{}], [3, 4, \PYGZsq{}insert\PYGZus{}2\PYGZsq{}, [5, 6], 2]]}
\end{sphinxVerbatim}

\sphinxAtStartPar
The parameter \sphinxcode{\sphinxupquote{list\_insert}} defines at which depth a new element should be inserted into the list. In line 2, \sphinxcode{\sphinxupquote{list\_insert}} is set to one, so \sphinxcode{\sphinxupquote{"insert\_2"}} is inserted in position two in the list at index 1 in the \sphinxcode{\sphinxupquote{Fagus}}\sphinxhyphen{}object. In line 4, the new element is inserted in the base\sphinxhyphen{}list at depth zero in the \sphinxcode{\sphinxupquote{Fagus}}\sphinxhyphen{}object. As another index is defined in \sphinxcode{\sphinxupquote{path}} (2), another list is created before \sphinxcode{\sphinxupquote{"insert\_3}} is inserted.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Fagus}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{insert\PYGZus{}4}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{list\PYGZus{}insert}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}2: \PYGZob{}1: 4, 3: [4, \PYGZsq{}insert\PYGZus{}4\PYGZsq{}, 6]\PYGZcb{}, \PYGZsq{}a\PYGZsq{}: \PYGZsq{}b\PYGZsq{}\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
In this last example, there is no list to be traversed at depth one. In that case, the insertion of \sphinxcode{\sphinxupquote{insert\_4}} is performed in the first list that is traversed above the indicated \sphinxcode{\sphinxupquote{list\_insert}}\sphinxhyphen{}depth (here one), which is at depth two.


\subsubsection{node\_types}
\label{\detokenize{README:node-types}}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{Default}: \sphinxcode{\sphinxupquote{""}}

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Type}: \sphinxcode{\sphinxupquote{str}}

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Allowed values}: Any string only containing the characters \sphinxcode{\sphinxupquote{"d"}}, \sphinxcode{\sphinxupquote{"l"}} and \sphinxcode{\sphinxupquote{" "}}

\end{itemize}

\sphinxAtStartPar
This parameter is used to precisely specify which types the new nodes to create when inserting a value at {\hyperref[\detokenize{README:the-path-parameter}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{path}}}}}} shall have. There are defined in three possible ways: \sphinxcode{\sphinxupquote{"l"}} for \sphinxcode{\sphinxupquote{list}}, \sphinxcode{\sphinxupquote{"d"}} for \sphinxcode{\sphinxupquote{dict}} or \sphinxcode{\sphinxupquote{" "}} for “don’t care”. Don’t care means that if the node exists, its type will be preserved if possible, however if a new node needs to be created because it doesn’t exist, {\hyperref[\detokenize{README:default-node-type}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{default\_node\_type}}}}}} will be used if possible. The examples below will make it more clear how this works. For an overview, also check the {\hyperref[\detokenize{README:basic-principles-for-modifying-the-tree}]{\sphinxcrossref{\DUrole{std,std-doc}{basic principles for modifying the tree}}}}.

\sphinxAtStartPar
\sphinxstylestrong{Example one: creating new nodes inside an empty object}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Fagus}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} a is a dict, as default\PYGZus{}node\PYGZus{}type by default generates a dict}
\PYG{g+go}{\PYGZob{}\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{k+kc}{False}\PYG{p}{,} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{node\PYGZus{}types}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dl}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}\PYGZsq{}a\PYGZsq{}: \PYGZob{}0: [False]\PYGZcb{}\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The root node, in the case above a \sphinxcode{\sphinxupquote{dict}}, can’t be changed, so \sphinxcode{\sphinxupquote{node\_types}} only affects the nodes that resign within the root node. Therefore, \sphinxcode{\sphinxupquote{node\_types}} is only defined for the second until last key in {\hyperref[\detokenize{README:the-path-parameter}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{path}}}}}}. For the second key in \sphinxcode{\sphinxupquote{path}}, here 0, it is defined in \sphinxcode{\sphinxupquote{node\_types}} that it should be a \sphinxcode{\sphinxupquote{dict}}, therefore a \sphinxcode{\sphinxupquote{dict}} is created. In that \sphinxcode{\sphinxupquote{dict}}, a \sphinxcode{\sphinxupquote{list}} is inserted at key 0 as the second letter in \sphinxcode{\sphinxupquote{node\_types}} is \sphinxcode{\sphinxupquote{"l"}}, and finally \sphinxcode{\sphinxupquote{False}} is inserted into that \textasciigrave{}list.

\sphinxAtStartPar
\sphinxstylestrong{Example two: clearly defined where to put lists and dicts at each level}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Fagus}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{3}\PYG{p}{:} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{5}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{]}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{q}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{k+kc}{True}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,} \PYG{n}{node\PYGZus{}types}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ldl}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}3: [\PYGZob{}7: [True]\PYGZcb{}, \PYGZob{}\PYGZsq{}a\PYGZsq{}: \PYGZsq{}q\PYGZsq{}\PYGZcb{}]\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
In this case, there already are nodes at the base of the position \sphinxcode{\sphinxupquote{path}} is pointing to. The first key in \sphinxcode{\sphinxupquote{path}}, 3, is traversed. For the second key in \sphinxcode{\sphinxupquote{path}}, here 0, it is defined in \sphinxcode{\sphinxupquote{node\_types}} that it should be a \sphinxcode{\sphinxupquote{list}} (\sphinxcode{\sphinxupquote{"l"}}), and in this case it actually is a list. The third key in \sphinxcode{\sphinxupquote{path}} is 7, and in \sphinxcode{\sphinxupquote{node\_types}} it is defined that there should be a \sphinxcode{\sphinxupquote{dict}} at this level. Therefore, the \sphinxcode{\sphinxupquote{list}} \sphinxcode{\sphinxupquote{{[}4, \{5: "c"\}{]}}} is overwritten with a new \sphinxcode{\sphinxupquote{dict}} with the key 7. The forth and last element in \sphinxcode{\sphinxupquote{path}} is 4, and in \sphinxcode{\sphinxupquote{node\_types}} it is defined that this node shall be a \sphinxcode{\sphinxupquote{list}} again. The value \sphinxcode{\sphinxupquote{True}} is then placed inside that \sphinxcode{\sphinxupquote{list}}.

\sphinxAtStartPar
\sphinxstylestrong{Example three: “don’t care” and other special cases}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Fagus}\PYG{p}{(}\PYG{n}{default\PYGZus{}node\PYGZus{}type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{l}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{k+kc}{True}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{6}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{[\PYGZob{}\PYGZsq{}a\PYGZsq{}: [True]\PYGZcb{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{k+kc}{None}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ddddddddd}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{[\PYGZob{}\PYGZsq{}a\PYGZsq{}: [True]\PYGZcb{}, \PYGZob{}5: None\PYGZcb{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{k+kc}{False}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{node\PYGZus{}types}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ d}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{[\PYGZob{}\PYGZsq{}a\PYGZsq{}: [True]\PYGZcb{}, \PYGZob{}5: None, 1: \PYGZob{}1: [False]\PYGZcb{}\PYGZcb{}]}
\end{sphinxVerbatim}

\sphinxAtStartPar
The first example in line two shows what happens if \sphinxcode{\sphinxupquote{node\_types}} is has not been defined. In that case, all the new nodes that are to be created are interpreted as “don’t care”, which means that if possible, new nodes of the type \sphinxcode{\sphinxupquote{default\_node\_type}} are created. Here, \sphinxcode{\sphinxupquote{default\_node\_type}} is \sphinxcode{\sphinxupquote{"l"}} (\sphinxcode{\sphinxupquote{list}}). There is no meaningful easy way to create an \sphinxcode{\sphinxupquote{int}}\sphinxhyphen{}\sphinxcode{\sphinxupquote{list}}\sphinxhyphen{}index from \sphinxcode{\sphinxupquote{"a"}}, therefore a \sphinxcode{\sphinxupquote{dict}} is inserted at \sphinxcode{\sphinxupquote{"a"}}. However, it is possible to create a list index from \sphinxcode{\sphinxupquote{"6"}} by using \sphinxcode{\sphinxupquote{str()}}, therefore a \sphinxcode{\sphinxupquote{list}} is created at key \sphinxcode{\sphinxupquote{"a"}}, in which \sphinxcode{\sphinxupquote{True}} finally is inserted.

\sphinxAtStartPar
The second example in line four shows what happens if \sphinxcode{\sphinxupquote{node\_types}} is defined for more than the length of \sphinxcode{\sphinxupquote{path}}. It’s actually no problem to do that, the remaining part of \sphinxcode{\sphinxupquote{node\_types}} is just ignored. The third example in line six shows what happens if \sphinxcode{\sphinxupquote{node\_types}} only is partly defined, in this case it is only defined to be “don’t care” for the second key in \sphinxcode{\sphinxupquote{path}} and \sphinxcode{\sphinxupquote{"d"}} for the third key in \sphinxcode{\sphinxupquote{path}}, but not for the last element. For all the keys in \sphinxcode{\sphinxupquote{path}} where \sphinxcode{\sphinxupquote{node\_types}} is undefined, it is treated as \sphinxcode{\sphinxupquote{"don\textquotesingle{}t care"}} when new nodes are created.


\subsubsection{path\_split}
\label{\detokenize{README:path-split}}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{Default}: \sphinxcode{\sphinxupquote{" "}}

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Type}: \sphinxcode{\sphinxupquote{str}}

\end{itemize}

\sphinxAtStartPar
The keys needed to traverse a \sphinxcode{\sphinxupquote{Fagus}}\sphinxhyphen{}object for getting or setting a value are passed as a \sphinxcode{\sphinxupquote{tuple}} or \sphinxcode{\sphinxupquote{list}} (line 2). \sphinxcode{\sphinxupquote{path\_split}} allows to alternatively specify all the keys in a single string, split by \sphinxcode{\sphinxupquote{path\_split}} (line 4). As shown in line 4, list indices can be specified in the path\sphinxhyphen{}string, they are automatically converted back to \sphinxcode{\sphinxupquote{int}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Fagus}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{k+kc}{True}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{q}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{p}{[}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{]}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a b 0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{g+go}{True}
\end{sphinxVerbatim}

\sphinxAtStartPar
By default, \sphinxcode{\sphinxupquote{path\_split}} is a single space \sphinxcode{\sphinxupquote{" "}}, but any other string can be used as a split character. If path string is set to \sphinxcode{\sphinxupquote{"\_"}}, the dot\sphinxhyphen{}notation can be used to get or set a node deeply inside a \sphinxcode{\sphinxupquote{Fagus}}\sphinxhyphen{}object.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Fagus}\PYG{p}{(}\PYG{n}{path\PYGZus{}split}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{a\PYGZus{}c\PYGZus{}1} \PYG{o}{=} \PYG{l+m+mi}{4}  \PYG{c+c1}{\PYGZsh{} \PYGZob{}\PYGZdq{}a\PYGZdq{}: \PYGZob{}\PYGZdq{}c\PYGZdq{}: \PYGZob{}\PYGZdq{}1\PYGZdq{}: 4\PYGZcb{}\PYGZcb{}\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Fagus}\PYG{p}{(}\PYG{n}{path\PYGZus{}split}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{default\PYGZus{}node\PYGZus{}type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{l}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{\PYGZus{}0\PYGZus{}2} \PYG{o}{=} \PYG{l+m+mi}{6}  \PYG{c+c1}{\PYGZsh{} [[6]], note that the str after . is prefixed with a \PYGZus{} for a list index}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Fagus}\PYG{p}{(}\PYG{n}{path\PYGZus{}split}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{example\PYGZus{}index\PYGZus{}\PYGZus{}another\PYGZus{}index} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{q}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{c+c1}{\PYGZsh{} \PYGZob{}\PYGZdq{}example\PYGZus{}index\PYGZdq{}: \PYGZob{}\PYGZdq{}another\PYGZus{}index\PYGZdq{}: \PYGZdq{}q\PYGZdq{}\PYGZcb{}\PYGZcb{}}
\end{sphinxVerbatim}


\section{Modifying the tree}
\label{\detokenize{README:modifying-the-tree}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Fagus}} does not only allow to easily retrieve elements deeply inside a tree of nested \sphinxcode{\sphinxupquote{dict}}\sphinxhyphen{} and \sphinxcode{\sphinxupquote{list}}\sphinxhyphen{}nodes using {\hyperref[\detokenize{README:the-path-parameter}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{get()}}}}}}. The tree can also be modified using the different functions shown below. Make sure to read {\hyperref[\detokenize{README:set-adding-and-overwriting-elements}]{\sphinxcrossref{\DUrole{std,std-doc}{set()}}}} first as its basic principles apply to all the other modifying functions.


\subsection{Basic principles for modifying the tree}
\label{\detokenize{README:basic-principles-for-modifying-the-tree}}
\sphinxAtStartPar
The following subsections show the logic behind the creation of new nodes in \sphinxcode{\sphinxupquote{Fagus}}. It is implemented in such a way that the tree is always modified as little as possible to perform the requested change.


\subsubsection{Correctly handling list indices}
\label{\detokenize{README:correctly-handling-list-indices}}
\sphinxAtStartPar
As demonstrated in the examples for the {\hyperref[\detokenize{README:the-path-parameter}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{path}}}}}}\sphinxhyphen{}parameter, \sphinxcode{\sphinxupquote{list}} indices can be positive and negative \sphinxcode{\sphinxupquote{int}}\sphinxhyphen{}nodes to access specific values in the list:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Fagus}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} some nested lists to demonstrate indices}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}1 2 1 1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} positive and negative indices can be used to get a value}
\PYG{g+go}{7}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0 \PYGZhy{}1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{two}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{c+c1}{\PYGZsh{} the value at index \PYGZhy{}1 is replaced with the new string}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[[[0, 1], \PYGZsq{}two\PYGZsq{}], [3, 4, [5, [6, 7]], 8]]}
\end{sphinxVerbatim}

\sphinxAtStartPar
When lists are modified, in many cases it might be desirable to append or prepend a value to the \sphinxcode{\sphinxupquote{list}} instead of overriding it as shown above. This can be done as shown below:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10000}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} 9 is appended as 10000 is bigger than len([3, 4, [5, [6, 7]], 8])}
\PYG{g+go}{[[[0, 1], \PYGZsq{}two\PYGZsq{}], [3, 4, [5, [6, 7]], 8, 9]]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{l+m+mf}{2.5}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1 \PYGZhy{}6}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} 2.5 is prepended before 3 as \PYGZhy{}6 is smaller than \PYGZhy{}len([3, 4, [5, [6, 7]], 8, 9])}
\PYG{g+go}{[[[0, 1], \PYGZsq{}two\PYGZsq{}], [2.5, 3, 4, [5, [6, 7]], 8, 9]]}
\end{sphinxVerbatim}

\sphinxAtStartPar
This shows how elements easily can be appended and prepended just by specifying an index which is bigger than the length of the list to append, or smaller than minus the length of the list to prepend. In order to make sure that a value is always appended / prepended without knowing the length of the list, \sphinxcode{\sphinxupquote{INF}} can be imported from the \sphinxcode{\sphinxupquote{fagus}}\sphinxhyphen{}module, it is just a reference to \sphinxcode{\sphinxupquote{sys.maxsize}}. The \sphinxcode{\sphinxupquote{FagusOption}} {\hyperref[\detokenize{README:list-insert}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{list\_insert}}}}}} can be used to insert a new value at an index in the middle of the \sphinxcode{\sphinxupquote{list}}.


\subsubsection{Create the correct type of node}
\label{\detokenize{README:create-the-correct-type-of-node}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Fagus}} is built around the concept of values being assigned to keys to build nested trees of \sphinxcode{\sphinxupquote{dict}}\sphinxhyphen{} and \sphinxcode{\sphinxupquote{list}}\sphinxhyphen{}nodes. The only supported operation in \sphinxcode{\sphinxupquote{set}}\sphinxhyphen{}nodes is checking whether it \sphinxcode{\sphinxupquote{contains}} a certain value, therefore \sphinxcode{\sphinxupquote{set}}\sphinxhyphen{}nodes cannot be traversed by {\hyperref[\detokenize{README:the-path-parameter}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{get()}}}}}} and are thus treated as leaf\sphinxhyphen{}nodes. Consequently, the only available nodes to create in the tree are \sphinxcode{\sphinxupquote{dict}} \sphinxcode{\sphinxupquote{"d"}} and \sphinxcode{\sphinxupquote{list}} \sphinxcode{\sphinxupquote{"l"}}.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{FagusOption}} {\hyperref[\detokenize{README:node-types}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{node\_types}}}}}} can be used to clearly specify which types the nodes at each level of the tree should have, see {\hyperref[\detokenize{README:node-types}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{node\_types}}}}}} example one. If \sphinxcode{\sphinxupquote{node\_types}} is not specified clearly or set to \sphinxcode{\sphinxupquote{" "}} (don’t care), {\hyperref[\detokenize{README:default-node-type}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{default\_node\_type}}}}}} determines which type of node will be created:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Fagus}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{k+kc}{True}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0 0 0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{default\PYGZus{}node\PYGZus{}type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{l}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} only lists are created, as default\PYGZus{}node\PYGZus{}type=\PYGZdq{}l\PYGZdq{}}
\PYG{g+go}{\PYGZob{}\PYGZsq{}0\PYGZsq{}: [[True]]\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{clear}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{k+kc}{True}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0 a 0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{default\PYGZus{}node\PYGZus{}type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{l}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} a dict is created at level 1 \PYGZhy{}\PYGZhy{}\PYGZgt{} can\PYGZsq{}t convert \PYGZdq{}a\PYGZdq{} to a list\PYGZhy{}index}
\PYG{g+go}{\PYGZob{}\PYGZsq{}0\PYGZsq{}: \PYGZob{}\PYGZsq{}a\PYGZsq{}: [True]\PYGZcb{}\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Fagus}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{k+kc}{True}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0 0 0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} only create dicts, as default\PYGZus{}node\PYGZus{}type is \PYGZdq{}d\PYGZdq{} by default}
\PYG{g+go}{\PYGZob{}\PYGZsq{}0\PYGZsq{}: \PYGZob{}\PYGZsq{}0\PYGZsq{}: \PYGZob{}\PYGZsq{}0\PYGZsq{}: True\PYGZcb{}\PYGZcb{}\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
From the example above, we can see the following two rules on how new nodes are created:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{list}} nodes are created when \sphinxcode{\sphinxupquote{default\_node\_type}} is \sphinxcode{\sphinxupquote{"l"}} and the key can be converted to an \sphinxcode{\sphinxupquote{int}} \textendash{}\textgreater{} create \sphinxcode{\sphinxupquote{list}} for keys like \sphinxcode{\sphinxupquote{8}} or \sphinxcode{\sphinxupquote{"\sphinxhyphen{}10"}}

\item {}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dict}} nodes are always created when \sphinxcode{\sphinxupquote{default\_node\_type}} is \sphinxcode{\sphinxupquote{d}}, even if the key could be converted to an \sphinxcode{\sphinxupquote{int}} \textendash{}\textgreater{} create \sphinxcode{\sphinxupquote{dict}} also for keys like \sphinxcode{\sphinxupquote{8}} or \sphinxcode{\sphinxupquote{"\sphinxhyphen{}10"}}

\end{enumerate}

\sphinxAtStartPar
But what happens if there already are existing nodes?

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Fagus}\PYG{p}{(}\PYG{p}{[}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{k+kc}{True}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{k+kc}{False}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} the new value False is appended to the list}
\PYG{g+go}{[\PYGZob{}\PYGZsq{}a\PYGZsq{}: [True, False]\PYGZcb{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0 a b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} could not convert \PYGZdq{}b\PYGZdq{} to list index, so [True, False] was replaced with \PYGZob{}\PYGZdq{}b\PYGZdq{}: 7\PYGZcb{}}
\PYG{g+go}{[\PYGZob{}\PYGZsq{}a\PYGZsq{}: \PYGZob{}\PYGZsq{}b\PYGZsq{}: 7\PYGZcb{}\PYGZcb{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0 a 2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{default\PYGZus{}node\PYGZus{}type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{l}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} did not convert \PYGZob{}\PYGZdq{}b\PYGZdq{}: 7\PYGZcb{} to list \PYGZhy{}\PYGZhy{}\PYGZgt{} if possible always try to keep node}
\PYG{g+go}{[\PYGZob{}\PYGZsq{}a\PYGZsq{}: \PYGZob{}\PYGZsq{}b\PYGZsq{}: 7, \PYGZsq{}2\PYGZsq{}: 3\PYGZcb{}\PYGZcb{}]}
\end{sphinxVerbatim}

\sphinxAtStartPar
This shows that as far as possible, \sphinxcode{\sphinxupquote{Fagus}} will keep the existing node and not change it like in line 6. An existing node is only overridden and changed if it is not possible to convert the provided key to a list\sphinxhyphen{}index.

\sphinxAtStartPar
It is possible to manually override this behaviour by clearly specifying if each node should be a \sphinxcode{\sphinxupquote{dict}} \sphinxcode{\sphinxupquote{"d"}} or a \sphinxcode{\sphinxupquote{list}} \sphinxcode{\sphinxupquote{"l"}}, check out the section about {\hyperref[\detokenize{README:node-types}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{node\_types}}}}}} for examples on this.


\subsubsection{Ensure that the required node can be modified}
\label{\detokenize{README:ensure-that-the-required-node-can-be-modified}}
\sphinxAtStartPar
In a nested structure of \sphinxcode{\sphinxupquote{dict}}\sphinxhyphen{} and \sphinxcode{\sphinxupquote{list}}\sphinxhyphen{}nodes, there can also be unmodifyable \sphinxcode{\sphinxupquote{list}}\sphinxhyphen{}nodes called \sphinxcode{\sphinxupquote{tuple}}. As values can’t be changed in a \sphinxcode{\sphinxupquote{tuple}}, it has to be converted into a \sphinxcode{\sphinxupquote{list}}. The following example shows how this is done in case of nested \sphinxcode{\sphinxupquote{tuple}}\sphinxhyphen{}nodes:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Fagus}\PYG{p}{(}\PYG{p}{(}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{seven}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1 2 1 1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} replacing the value 7 with the string \PYGZdq{}seven\PYGZdq{}}
\PYG{g+go}{(((1, 0), 2), [3, 4, [5, [6, \PYGZsq{}seven\PYGZsq{}]], 8])}
\end{sphinxVerbatim}

\sphinxAtStartPar
In order to replace the 7 with \sphinxcode{\sphinxupquote{"seven"}} in the \sphinxcode{\sphinxupquote{tuple}} \sphinxcode{\sphinxupquote{(6, 7)}}, it has to be converted into a modifyable \sphinxcode{\sphinxupquote{list}} first. \sphinxcode{\sphinxupquote{(6, 7)}} however resides in another \sphinxcode{\sphinxupquote{tuple}} \sphinxcode{\sphinxupquote{(5, (6, 7))}}, so that outer \sphinxcode{\sphinxupquote{tuple}} also has to be converted into a \sphinxcode{\sphinxupquote{list}}. As \sphinxcode{\sphinxupquote{(5, (6, 7))}} already lies in a \sphinxcode{\sphinxupquote{list}}, it can be  replaced with \sphinxcode{\sphinxupquote{{[}5, {[}6, "seven"{]}{]}}}. The key point is that \sphinxcode{\sphinxupquote{tuple}}\sphinxhyphen{}nodes are converted to \sphinxcode{\sphinxupquote{list}}\sphinxhyphen{}nodes as deeply as necessary. The outermost \sphinxcode{\sphinxupquote{tuple}} containing the whole tree \sphinxcode{\sphinxupquote{(((1, 0), 2), {[}3, 4, (5, (6, 7)), 8{]})}} is not touched, and thus remains a \sphinxcode{\sphinxupquote{tuple}}


\subsection{set() \textendash{} adding and overwriting elements}
\label{\detokenize{README:set-adding-and-overwriting-elements}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{set()}} function can be used to add or replace a value anywhere in the tree. This function is also used internally in \sphinxcode{\sphinxupquote{Fagus}} whereever new nodes need to be created. See {\hyperref[\detokenize{README:basic-principles-for-modifying-the-tree}]{\sphinxcrossref{\DUrole{std,std-doc}{Basic principles for modifying the tree}}}} and {\hyperref[\detokenize{README:node-types}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{node\_types}}}}}} for examples of how \sphinxcode{\sphinxupquote{set()}} can be fine\sphinxhyphen{}tuned. In case no further fine\sphinxhyphen{}tuning is used, the \sphinxcode{\sphinxupquote{set()}}\sphinxhyphen{}operation can also be done as shown below:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Fagus}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{path\PYGZus{}split}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hello}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0\PYGZus{}good\PYGZus{}morning}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{[\PYGZob{}\PYGZsq{}good\PYGZsq{}: \PYGZob{}\PYGZsq{}morning\PYGZsq{}: \PYGZsq{}hello\PYGZsq{}\PYGZcb{}\PYGZcb{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{\PYGZus{}1\PYGZus{}ciao} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{byebye}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{c+c1}{\PYGZsh{} the dot\PYGZhy{}notation for set() is available when path\PYGZus{}split is set to \PYGZdq{}\PYGZus{}\PYGZdq{} or \PYGZdq{}\PYGZus{}\PYGZus{}\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} note that the first index 1 above was prefixed with \PYGZus{}, as variable names can\PYGZsq{}t start with a digit in Python}
\PYG{g+go}{[\PYGZob{}\PYGZsq{}good\PYGZsq{}: \PYGZob{}\PYGZsq{}morning\PYGZsq{}: \PYGZsq{}hello\PYGZsq{}\PYGZcb{}\PYGZcb{}, \PYGZob{}\PYGZsq{}ciao\PYGZsq{}: \PYGZsq{}byebye\PYGZsq{}\PYGZcb{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0\PYGZus{}good\PYGZus{}evening}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{night}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{c+c1}{\PYGZsh{} the []\PYGZhy{}notation is always available for set(), a[(0, \PYGZdq{}evening\PYGZdq{})] would do the same}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[\PYGZob{}\PYGZsq{}good\PYGZsq{}: \PYGZob{}\PYGZsq{}morning\PYGZsq{}: \PYGZsq{}hello\PYGZsq{}, \PYGZsq{}evening\PYGZsq{}: \PYGZsq{}night\PYGZsq{}\PYGZcb{}\PYGZcb{}, \PYGZob{}\PYGZsq{}ciao\PYGZsq{}: \PYGZsq{}byebye\PYGZsq{}\PYGZcb{}]}
\end{sphinxVerbatim}


\subsection{append() \textendash{} adding a new element to a \sphinxstyleliteralintitle{\sphinxupquote{list}}}
\label{\detokenize{README:append-adding-a-new-element-to-a-list}}
\sphinxAtStartPar
There might be cases where it is desirable to collect all elements of a certain type in a \sphinxcode{\sphinxupquote{list}}. This can be done in only one step using \sphinxcode{\sphinxupquote{append()}}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plants} \PYG{o}{=} \PYG{n}{Fagus}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plants}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{daffodil}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{flowers}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} a new list is created in the node flowers}
\PYG{g+go}{\PYGZob{}\PYGZsq{}flowers\PYGZsq{}: [\PYGZsq{}daffodil\PYGZsq{}]\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plants}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pine}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{trees softwood}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} another list is created in the category trees softwood}
\PYG{g+go}{\PYGZob{}\PYGZsq{}flowers\PYGZsq{}: [\PYGZsq{}daffodil\PYGZsq{}], \PYGZsq{}trees\PYGZsq{}: \PYGZob{}\PYGZsq{}softwood\PYGZsq{}: [\PYGZsq{}pine\PYGZsq{}]\PYGZcb{}\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plants}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{rose}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{flowers}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} rose is added to the existing flowers list}
\PYG{g+go}{\PYGZob{}\PYGZsq{}flowers\PYGZsq{}: [\PYGZsq{}daffodil\PYGZsq{}, \PYGZsq{}rose\PYGZsq{}], \PYGZsq{}trees\PYGZsq{}: \PYGZob{}\PYGZsq{}softwood\PYGZsq{}: [\PYGZsq{}pine\PYGZsq{}]\PYGZcb{}\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plants}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{oak}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{trees hardwood}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} a new list is created for hardwood trees}
\PYG{g+go}{\PYGZob{}\PYGZsq{}flowers\PYGZsq{}: [\PYGZsq{}daffodil\PYGZsq{}, \PYGZsq{}rose\PYGZsq{}], \PYGZsq{}trees\PYGZsq{}: \PYGZob{}\PYGZsq{}softwood\PYGZsq{}: [\PYGZsq{}pine\PYGZsq{}], \PYGZsq{}hardwood\PYGZsq{}: [\PYGZsq{}oak\PYGZsq{}]\PYGZcb{}\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plants}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{beech}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{trees hardwood}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} beech is appended to the hardwood trees list}
\PYG{g+go}{\PYGZob{}\PYGZsq{}flowers\PYGZsq{}: [\PYGZsq{}daffodil\PYGZsq{}, \PYGZsq{}rose\PYGZsq{}], \PYGZsq{}trees\PYGZsq{}: \PYGZob{}\PYGZsq{}softwood\PYGZsq{}: [\PYGZsq{}pine\PYGZsq{}], \PYGZsq{}hardwood\PYGZsq{}: [\PYGZsq{}oak\PYGZsq{}, \PYGZsq{}beech\PYGZsq{}]\PYGZcb{}\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
As you can see, this function makes it easy to combine elements belonging to the same category in a \sphinxcode{\sphinxupquote{list}} inside the tree. The pratical thing here is that it isn’t necessary to worry about creating the \sphinxcode{\sphinxupquote{list}} initially \textendash{} if there already is a \sphinxcode{\sphinxupquote{list}}, the new element is appended and if there is no \sphinxcode{\sphinxupquote{list}}, a new one is created.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plants}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pine}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{trees}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{softwood}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} removing pine from list to put it as a single element (for next step)}
\PYG{g+go}{\PYGZob{}\PYGZsq{}flowers\PYGZsq{}: [\PYGZsq{}daffodil\PYGZsq{}, \PYGZsq{}rose\PYGZsq{}], \PYGZsq{}trees\PYGZsq{}: \PYGZob{}\PYGZsq{}softwood\PYGZsq{}: \PYGZsq{}pine\PYGZsq{}, \PYGZsq{}hardwood\PYGZsq{}: [\PYGZsq{}oak\PYGZsq{}, \PYGZsq{}beech\PYGZsq{}]\PYGZcb{}\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plants}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{fir}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{trees}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{softwood}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} pine is in this position already \PYGZhy{}\PYGZgt{} put pine in list, then append fir}
\PYG{g+go}{\PYGZob{}\PYGZsq{}flowers\PYGZsq{}: [\PYGZsq{}daffodil\PYGZsq{}, \PYGZsq{}rose\PYGZsq{}], \PYGZsq{}trees\PYGZsq{}: \PYGZob{}\PYGZsq{}softwood\PYGZsq{}: [\PYGZsq{}pine\PYGZsq{}, \PYGZsq{}fir\PYGZsq{}], \PYGZsq{}hardwood\PYGZsq{}: [\PYGZsq{}oak\PYGZsq{}, \PYGZsq{}beech\PYGZsq{}]\PYGZcb{}\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plants}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{forest}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{trees}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} node trees already present at path \PYGZhy{}\PYGZgt{} convert node to list \PYGZhy{}\PYGZgt{} append element}
\PYG{g+go}{\PYGZob{}\PYGZsq{}flowers\PYGZsq{}: [\PYGZsq{}daffodil\PYGZsq{}, \PYGZsq{}rose\PYGZsq{}], \PYGZsq{}trees\PYGZsq{}: [\PYGZsq{}softwood\PYGZsq{}, \PYGZsq{}hardwood\PYGZsq{}, \PYGZsq{}forest\PYGZsq{}]\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plants} \PYG{o}{=} \PYG{n}{Fagus}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{flowers}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{rose}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{daffodil}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{tulip}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} preparing the next step \PYGZhy{} flowers are now in a set}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} below another type of node is already at path (here a set) \PYGZhy{}\PYGZgt{} convert it to a list and then append the element}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plants}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sunflower}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{flowers}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{flowers}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{sort}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} sort list of flowers for doctest, irrelevant for example}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plants}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} as you can see, \PYGZob{}\PYGZdq{}rose\PYGZdq{}, \PYGZdq{}daffodil\PYGZdq{}, \PYGZdq{}tulip\PYGZdq{}\PYGZcb{} was converted to a list, then sunflower was added}
\PYG{g+go}{\PYGZob{}\PYGZsq{}flowers\PYGZsq{}: [\PYGZsq{}daffodil\PYGZsq{}, \PYGZsq{}rose\PYGZsq{}, \PYGZsq{}sunflower\PYGZsq{}, \PYGZsq{}tulip\PYGZsq{}]\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The examples above show that \sphinxcode{\sphinxupquote{append()}} is agile and makes the best out of any situation in the tree where it is called. If there is a single element already present at the node, that element is put in a \sphinxcode{\sphinxupquote{list}} before the new element is added. If there already is another type of node or another \sphinxcode{\sphinxupquote{Collection}} at the requested \sphinxcode{\sphinxupquote{path}}, convert that node into a \sphinxcode{\sphinxupquote{list}} and then append the new element.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plants}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{lily}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{flowers 4}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} set() with an index bigger than the length of the list can also be used to append}
\PYG{g+go}{\PYGZob{}\PYGZsq{}flowers\PYGZsq{}: [\PYGZsq{}daffodil\PYGZsq{}, \PYGZsq{}rose\PYGZsq{}, \PYGZsq{}sunflower\PYGZsq{}, \PYGZsq{}tulip\PYGZsq{}, \PYGZsq{}lily\PYGZsq{}]\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The example above shows that \sphinxcode{\sphinxupquote{set()}} can also be used to append an element to a \sphinxcode{\sphinxupquote{list}}. However, note that \sphinxcode{\sphinxupquote{set()}} in this case won’t create a new list if the node doesn’t exist yet. It won’t convert another node already present at \sphinxcode{\sphinxupquote{path}} into a \sphinxcode{\sphinxupquote{list}} neither.


\subsection{extend() \textendash{} extending a \sphinxstyleliteralintitle{\sphinxupquote{list}} with multiple elements}
\label{\detokenize{README:extend-extending-a-list-with-multiple-elements}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{extend()}} function works very similar to {\hyperref[\detokenize{README:append-adding-a-new-element-to-a-list}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{append()}}}}}}, the main difference here is that instead of appending one additional element, the list is extended with a collection of elements.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plants}\PYG{o}{.}\PYG{n}{extend}\PYG{p}{(}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{lavender}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{daisy}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{orchid}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{flowers}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} extend() works like append(), just adding more elements}
\PYG{g+go}{\PYGZob{}\PYGZsq{}flowers\PYGZsq{}: [\PYGZsq{}daffodil\PYGZsq{}, \PYGZsq{}rose\PYGZsq{}, \PYGZsq{}sunflower\PYGZsq{}, \PYGZsq{}tulip\PYGZsq{}, \PYGZsq{}lily\PYGZsq{}, \PYGZsq{}lavender\PYGZsq{}, \PYGZsq{}daisy\PYGZsq{}, \PYGZsq{}orchid\PYGZsq{}]\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
For further reading about when and how new \sphinxcode{\sphinxupquote{list}}\sphinxhyphen{}nodes are created, refer to the documentation of {\hyperref[\detokenize{README:append-adding-a-new-element-to-a-list}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{append()}}}}}} as \sphinxcode{\sphinxupquote{extend()}} works similar except from the fact that several new elements are added instead of one.


\subsection{insert() \textendash{} insert an element at a given index in a \sphinxstyleliteralintitle{\sphinxupquote{list}}}
\label{\detokenize{README:insert-insert-an-element-at-a-given-index-in-a-list}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{insert()}} function works similar to {\hyperref[\detokenize{README:append-adding-a-new-element-to-a-list}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{append()}}}}}}, the main difference is just that instead of appending the new element to the end of the \sphinxcode{\sphinxupquote{list}}, it can be inserted at any position. For an overview of how and when new \sphinxcode{\sphinxupquote{list}}\sphinxhyphen{}nodes are created before insertion, check out {\hyperref[\detokenize{README:append-adding-a-new-element-to-a-list}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{append()}}}}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plants} \PYG{o}{=} \PYG{n}{Fagus}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{flowers}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{daffodil}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rose}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sunflower}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plants}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{tulip}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{flowers}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} index parameter comes first, so the order if args is like in list().insert()}
\PYG{g+go}{\PYGZob{}\PYGZsq{}flowers\PYGZsq{}: [\PYGZsq{}daffodil\PYGZsq{}, \PYGZsq{}tulip\PYGZsq{}, \PYGZsq{}rose\PYGZsq{}, \PYGZsq{}sunflower\PYGZsq{}]\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The normal indexation of \sphinxcode{\sphinxupquote{list}}\sphinxhyphen{}nodes in \sphinxcode{\sphinxupquote{Fagus}} only allows appending or prepending elements if it is necessary to do so anywhere in {\hyperref[\detokenize{README:the-path-parameter}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{path}}}}}}, this is documented {\hyperref[\detokenize{README:correctly-handling-list-indices}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{here}}}}}}. Check out the {\hyperref[\detokenize{README:list-insert}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{list\_insert}}}}}} \sphinxcode{\sphinxupquote{FagusOption}} for examples on how to insert new nodes at any index in the list anywhere in \sphinxcode{\sphinxupquote{path}}.


\subsection{add() \textendash{} adding a new element to a \sphinxstyleliteralintitle{\sphinxupquote{set}}}
\label{\detokenize{README:add-adding-a-new-element-to-a-set}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{add()}} function works similar to {\hyperref[\detokenize{README:append-adding-a-new-element-to-a-list}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{append()}}}}}}, the main difference is just that instead of creating and appending to \sphinxcode{\sphinxupquote{list}}\sphinxhyphen{}nodes, \sphinxcode{\sphinxupquote{set}}\sphinxhyphen{}nodes are used. For detailed examples of the rules when and how new \sphinxcode{\sphinxupquote{set}}\sphinxhyphen{}nodes are created by this function, check out {\hyperref[\detokenize{README:append-adding-a-new-element-to-a-list}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{append()}}}}}} just replacing occurrences of \sphinxcode{\sphinxupquote{list}} with \sphinxcode{\sphinxupquote{set}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{tests}\PYG{n+nn}{.}\PYG{n+nn}{test\PYGZus{}fagus} \PYG{k+kn}{import} \PYG{n}{sorted\PYGZus{}set}  \PYG{c+c1}{\PYGZsh{} function needed for doctests to work with sets \PYGZhy{}\PYGZgt{} print the set sorted}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sorted\PYGZus{}set}\PYG{p}{(}\PYG{n}{plants}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{daisy}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{flowers}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} list is converted into a set, and then \PYGZdq{}daisy\PYGZdq{} is added to that set}
\PYG{g+go}{\PYGZob{}\PYGZsq{}flowers\PYGZsq{}: \PYGZob{}\PYGZsq{}daffodil\PYGZsq{}, \PYGZsq{}daisy\PYGZsq{}, \PYGZsq{}rose\PYGZsq{}, \PYGZsq{}sunflower\PYGZsq{}, \PYGZsq{}tulip\PYGZsq{}\PYGZcb{}\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sorted\PYGZus{}set}\PYG{p}{(}\PYG{n}{plants}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{oak}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{trees}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} node does not exist yet \PYGZhy{} create new empty set and add the new value to it}
\PYG{g+go}{\PYGZob{}\PYGZsq{}flowers\PYGZsq{}: \PYGZob{}\PYGZsq{}daffodil\PYGZsq{}, \PYGZsq{}daisy\PYGZsq{}, \PYGZsq{}rose\PYGZsq{}, \PYGZsq{}sunflower\PYGZsq{}, \PYGZsq{}tulip\PYGZsq{}\PYGZcb{}, \PYGZsq{}trees\PYGZsq{}: \PYGZob{}\PYGZsq{}oak\PYGZsq{}\PYGZcb{}\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{update() \textendash{} update multiple elements in a \sphinxstyleliteralintitle{\sphinxupquote{set}} or \sphinxstyleliteralintitle{\sphinxupquote{dict}}}
\label{\detokenize{README:update-update-multiple-elements-in-a-set-or-dict}}
\sphinxAtStartPar
This function works similar to {\hyperref[\detokenize{README:extend-extending-a-list-with-multiple-elements}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{extend()}}}}}} explained above, however the difference here is that the new elements now are added to a \sphinxcode{\sphinxupquote{set}} or \sphinxcode{\sphinxupquote{dict}}. As the function has the same name for \sphinxcode{\sphinxupquote{set}} and \sphinxcode{\sphinxupquote{dict}}\sphinxhyphen{}nodes, it has to determine what kind of node to create. Consider the following examples:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plants} \PYG{o}{=} \PYG{n}{Fagus}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} sorted\PYGZus{}set() is used to always print sets deterministic, this is needed internally for doctests}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sorted\PYGZus{}set}\PYG{p}{(}\PYG{n}{plants}\PYG{o}{.}\PYG{n}{update}\PYG{p}{(}\PYG{n+nb}{dict}\PYG{p}{(}\PYG{n}{softwood}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pine}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{hardwood}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{oak}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{trees}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} creating and updating dict}
\PYG{g+go}{\PYGZob{}\PYGZsq{}trees\PYGZsq{}: \PYGZob{}\PYGZsq{}softwood\PYGZsq{}: \PYGZsq{}pine\PYGZsq{}, \PYGZsq{}hardwood\PYGZsq{}: \PYGZsq{}oak\PYGZsq{}\PYGZcb{}\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sorted\PYGZus{}set}\PYG{p}{(}\PYG{n}{plants}\PYG{o}{.}\PYG{n}{update}\PYG{p}{(}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{tulip}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{daisy}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{daffodil}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{flowers}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} create set from tuple}
\PYG{g+go}{\PYGZob{}\PYGZsq{}trees\PYGZsq{}: \PYGZob{}\PYGZsq{}softwood\PYGZsq{}: \PYGZsq{}pine\PYGZsq{}, \PYGZsq{}hardwood\PYGZsq{}: \PYGZsq{}oak\PYGZsq{}\PYGZcb{}, \PYGZsq{}flowers\PYGZsq{}: \PYGZob{}\PYGZsq{}daffodil\PYGZsq{}, \PYGZsq{}daisy\PYGZsq{}, \PYGZsq{}tulip\PYGZsq{}\PYGZcb{}\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plants}\PYG{o}{.}\PYG{n}{clear}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{flowers}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} emptying this set to keep the example easily readable}
\PYG{g+go}{\PYGZob{}\PYGZsq{}trees\PYGZsq{}: \PYGZob{}\PYGZsq{}softwood\PYGZsq{}: \PYGZsq{}pine\PYGZsq{}, \PYGZsq{}hardwood\PYGZsq{}: \PYGZsq{}oak\PYGZsq{}\PYGZcb{}, \PYGZsq{}flowers\PYGZsq{}: set()\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sorted\PYGZus{}set}\PYG{p}{(}\PYG{n}{plants}\PYG{o}{.}\PYG{n}{update}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{garden flowers}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sunflower}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{flower trees}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{apple tree}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{flowers}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} comment below}
\PYG{g+go}{\PYGZob{}\PYGZsq{}trees\PYGZsq{}: \PYGZob{}\PYGZsq{}softwood\PYGZsq{}: \PYGZsq{}pine\PYGZsq{}, \PYGZsq{}hardwood\PYGZsq{}: \PYGZsq{}oak\PYGZsq{}\PYGZcb{}, \PYGZsq{}flowers\PYGZsq{}: \PYGZob{}\PYGZsq{}flower trees\PYGZsq{}, \PYGZsq{}garden flowers\PYGZsq{}\PYGZcb{}\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} as you can see, even though a dict was sent in as a parameter, the flowers node stayed a set, so only \PYGZdq{}flower}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} trees\PYGZdq{} and \PYGZdq{}garden flowers\PYGZdq{} were added, but not \PYGZdq{}apple tree\PYGZdq{} and \PYGZdq{}sunflower\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The examples above illustrate first two of the principles \sphinxcode{\sphinxupquote{update()}} operates after:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
If there already is a \sphinxcode{\sphinxupquote{dict}}\sphinxhyphen{} or \sphinxcode{\sphinxupquote{set}} object at {\hyperref[\detokenize{README:the-path-parameter}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{path}}}}}}, keep that node if possible.

\item {}
\sphinxAtStartPar
If there already exists a \sphinxcode{\sphinxupquote{set}}, and a \sphinxcode{\sphinxupquote{dict}} is passed to \sphinxcode{\sphinxupquote{update()}}, the \sphinxcode{\sphinxupquote{set}} is updated with the keys from the dict only (line 8).

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sorted\PYGZus{}set}\PYG{p}{(}\PYG{n}{plants}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{fruit trees}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{apple tree}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{lemon tree}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{trees}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} prepare the next example}
\PYG{g+go}{\PYGZob{}\PYGZsq{}trees\PYGZsq{}: \PYGZob{}\PYGZsq{}fruit trees\PYGZsq{}: [\PYGZsq{}apple tree\PYGZsq{}, \PYGZsq{}lemon tree\PYGZsq{}]\PYGZcb{}, \PYGZsq{}flowers\PYGZsq{}: \PYGZob{}\PYGZsq{}flower trees\PYGZsq{}, \PYGZsq{}garden flowers\PYGZsq{}\PYGZcb{}\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sorted\PYGZus{}set}\PYG{p}{(}\PYG{n}{plants}\PYG{o}{.}\PYG{n}{update}\PYG{p}{(}\PYG{p}{(}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hardwood}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{oak}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{softwood}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{fir}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{trees}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} comment below}
\PYG{g+go}{\PYGZob{}\PYGZsq{}trees\PYGZsq{}: \PYGZob{}(\PYGZsq{}hardwood\PYGZsq{}, \PYGZsq{}oak\PYGZsq{}), (\PYGZsq{}softwood\PYGZsq{}, \PYGZsq{}fir\PYGZsq{})\PYGZcb{}, \PYGZsq{}flowers\PYGZsq{}: \PYGZob{}\PYGZsq{}flower trees\PYGZsq{}, \PYGZsq{}garden flowers\PYGZsq{}\PYGZcb{}\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} it is not possible to update a dict from these tuples \PYGZhy{}\PYGZgt{} replace the previous dict with a new set with the tuples}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plants} \PYG{o}{=} \PYG{n}{Fagus}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{trees}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hardwood}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{beech}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{softwood}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{fir}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} making \PYGZdq{}trees\PYGZdq{} a dict again for next example}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sorted\PYGZus{}set}\PYG{p}{(}\PYG{n}{plants}\PYG{o}{.}\PYG{n}{update}\PYG{p}{(}\PYG{n+nb}{dict}\PYG{p}{(}\PYG{p}{(}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hardwood}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{oak}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{softwood}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pine}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{trees}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} comment below}
\PYG{g+go}{\PYGZob{}\PYGZsq{}trees\PYGZsq{}: \PYGZob{}\PYGZsq{}hardwood\PYGZsq{}: \PYGZsq{}oak\PYGZsq{}, \PYGZsq{}softwood\PYGZsq{}: \PYGZsq{}pine\PYGZsq{}\PYGZcb{}\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} Here it is shown how a dict can be updated based on a list of tuples with two elements, or e.g. the iterator}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} dict.items() returns. By passing the list of tuples to the dict() function first, Fagus detects your intention}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} to update a dict instead of overwriting it with a set}
\end{sphinxVerbatim}

\sphinxAtStartPar
The third principle \sphinxcode{\sphinxupquote{update()}} operates after is the following:
3. If you would like to update a \sphinxcode{\sphinxupquote{dict}}, you must pass a \sphinxcode{\sphinxupquote{Mapping}} (the type of key\sphinxhyphen{}value containers like \sphinxcode{\sphinxupquote{dict}}). If you just pass e.g. a \sphinxcode{\sphinxupquote{tuple}} of \sphinxcode{\sphinxupquote{tuple}}\sphinxhyphen{}nodes with two elements or \sphinxcode{\sphinxupquote{dict.items()}}, the \sphinxcode{\sphinxupquote{dict}} will be overwritten with a \sphinxcode{\sphinxupquote{set}}. To update the dict, just pass e.g. the \sphinxcode{\sphinxupquote{tuple}} of \sphinxcode{\sphinxupquote{tuple}}\sphinxhyphen{}nodes through \sphinxcode{\sphinxupquote{dict()}} before passing it to \sphinxcode{\sphinxupquote{update()}}. For any \sphinxcode{\sphinxupquote{Iterable}} that is not a \sphinxcode{\sphinxupquote{Mapping}}, the \sphinxcode{\sphinxupquote{Mapping}} will be removed and a \sphinxcode{\sphinxupquote{set}} will be created.

\sphinxAtStartPar
Especially this last principle may seem tedious, however it was chosen to implement it that way to prevent ambiguity, and the main reason for that is the \sphinxcode{\sphinxupquote{update()}} function being used in \sphinxcode{\sphinxupquote{set}}\sphinxhyphen{}nodes as well as \sphinxcode{\sphinxupquote{dict}}\sphinxhyphen{}nodes.


\subsection{remove(), delete() and pop()}
\label{\detokenize{README:remove-delete-and-pop}}

\subsection{serialize() \textendash{} ensure that a tree is json\sphinxhyphen{} or yaml\sphinxhyphen{}serializable}
\label{\detokenize{README:serialize-ensure-that-a-tree-is-json-or-yaml-serializable}}

\subsection{mod() \textendash{} modifying elements}
\label{\detokenize{README:mod-modifying-elements}}

\section{Iterating over nested objects}
\label{\detokenize{README:iterating-over-nested-objects}}

\subsection{Skipping nodes in iteration.}
\label{\detokenize{README:skipping-nodes-in-iteration}}

\section{Filtering nested objects}
\label{\detokenize{README:filtering-nested-objects}}
\sphinxstepscope


\chapter{fagus package}
\label{\detokenize{fagus:module-fagus}}\label{\detokenize{fagus:fagus-package}}\label{\detokenize{fagus::doc}}\index{module@\spxentry{module}!fagus@\spxentry{fagus}}\index{fagus@\spxentry{fagus}!module@\spxentry{module}}
\sphinxAtStartPar
Library to easily create, edit and traverse nested objects of dicts and lists in Python
\begin{description}
\item[{The following objects can be imported directly from this module:}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
{\hyperref[\detokenize{fagus:fagus.Fagus}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fagus}}}}}: a wrapper\sphinxhyphen{}class for complex, nested objects of dicts and lists

\item {}
\sphinxAtStartPar
{\hyperref[\detokenize{fagus.filters:fagus.filters.Fil}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fil}}}}}, {\hyperref[\detokenize{fagus.filters:fagus.filters.CFil}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CFil}}}}} and {\hyperref[\detokenize{fagus.filters:fagus.filters.VFil}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{VFil}}}}} are filter\sphinxhyphen{}objects that can
be used to filter {\hyperref[\detokenize{fagus:fagus.Fagus}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fagus}}}}}\sphinxhyphen{}objects

\item {}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{INF}}: alias for \sphinxcode{\sphinxupquote{sys.maxsize}}, used e.g. to indicate that an element should be appended to
a list

\end{itemize}

\item[{Submodules in {\hyperref[\detokenize{fagus:module-fagus}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fagus}}}}}:}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
{\hyperref[\detokenize{fagus.fagus:module-fagus.fagus}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fagus}}}}}: Base\sphinxhyphen{}module that contains the {\hyperref[\detokenize{fagus:fagus.Fagus}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fagus}}}}}\sphinxhyphen{}class

\item {}
\sphinxAtStartPar
{\hyperref[\detokenize{fagus.filters:module-fagus.filters}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{filters}}}}}: filter\sphinxhyphen{}classes for filtering {\hyperref[\detokenize{fagus:fagus.Fagus}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fagus}}}}}\sphinxhyphen{}objects

\item {}
\sphinxAtStartPar
{\hyperref[\detokenize{fagus.iterators:module-fagus.iterators}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{iterators}}}}}: iterator\sphinxhyphen{}classes for iterating on {\hyperref[\detokenize{fagus:fagus.Fagus}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fagus}}}}}

\item {}
\sphinxAtStartPar
{\hyperref[\detokenize{fagus.utils:module-fagus.utils}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{utils}}}}}: helper classes and methods for {\hyperref[\detokenize{fagus:fagus.Fagus}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fagus}}}}}

\end{itemize}

\end{description}
\index{Fagus (class in fagus)@\spxentry{Fagus}\spxextra{class in fagus}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{fagus.}}\sphinxbfcode{\sphinxupquote{Fagus}}}{\emph{\DUrole{n}{root}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Optional\DUrole{p}{{[}}Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{None}}, \emph{\DUrole{n}{node\_types}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{list\_insert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}int\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{default\_node\_type}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{default}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{if\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{iter\_fill}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{mod\_functions}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}Mapping\DUrole{p}{{[}}Union\DUrole{p}{{[}}type\DUrole{p}{,}\DUrole{w}{  }Tuple\DUrole{p}{{[}}type\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }str\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }Callable\DUrole{p}{{[}}\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }Any\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{collections.abc.MutableMapping}}, \sphinxcode{\sphinxupquote{collections.abc.MutableSequence}}, \sphinxcode{\sphinxupquote{collections.abc.MutableSet}}

\sphinxAtStartPar
Fagus is a wrapper\sphinxhyphen{}class for complex, nested objects of dicts and lists in Python

\sphinxAtStartPar
Fagus can be used as an object by instantiating it, but it’s also possible to use all methods statically without
even an object, so that a = \{\}; Fagus.set(a, “top med”, 1) and a = Fagus(\{\}); a.set(1, “top med”) do the same.

\sphinxAtStartPar
The root node is always modified directly. If you don’t want to change the root node, all the functions where it
makes sense support to rather modify a copy, and return that modified copy using the copy\sphinxhyphen{}parameter.

\sphinxAtStartPar
\sphinxstylestrong{FagusOptions}:
Several parameters used in functions in Fagus work as options so that you don’t have to specify them each time you
run a function. In the docstrings, these options are marked with a *, e.g. the fagus parameter is an option.
Options can be specified at three levels with increasing precedence: at class\sphinxhyphen{}level (Fagus.fagus = True), at
object\sphinxhyphen{}level (a = Fagus(), a.fagus = True) and in each function\sphinxhyphen{}call (a.get(“b”, fagus=True)). If you generally want
to change an option, change it at class\sphinxhyphen{}level \sphinxhyphen{} all objects in that file will inherit this option. If you want to
change the option specifically for one object, change the option at object\sphinxhyphen{}level. If you only want to change the
option for one single run of a function, put it as a function\sphinxhyphen{}parameter. More thorough examples of options can be
found in README.md.
\index{\_\_init\_\_() (fagus.Fagus method)@\spxentry{\_\_init\_\_()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{n}{root}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Optional\DUrole{p}{{[}}Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{None}}, \emph{\DUrole{n}{node\_types}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{list\_insert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}int\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{default\_node\_type}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{default}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{if\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{iter\_fill}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{mod\_functions}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}Mapping\DUrole{p}{{[}}Union\DUrole{p}{{[}}type\DUrole{p}{,}\DUrole{w}{  }Tuple\DUrole{p}{{[}}type\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }str\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }Callable\DUrole{p}{{[}}\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }Any\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Constructor for Fagus, a wrapper\sphinxhyphen{}class for complex, nested objects of dicts and lists in Python

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{root}} \textendash{} object (like dict / list) to wrap Fagus around. If this is None, an empty node of the type
default\_node\_type will be used. Default None

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_types}} \textendash{} * Can be used to manually define if the nodes along path are supposed to be (l)ists or
(d)icts. E.g. “dll” to create a dict at level 1, and lists at level 2 and 3. ” ” can also be used \sphinxhyphen{}
space doesn’t enforce a node\sphinxhyphen{}type like d or l. For ” “, existing nodes are traversed if possible,
otherwise default\_node\_type is used to create new nodes. Default “”, interpreted as ” ” at each level.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{list\_insert}} \textendash{} * Level at which a new node shall be inserted into the list instead of traversing the
existing node in the list at that index. See README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a string, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * this option is used to determine whether nodes in the returned object should be returned as
Fagus\sphinxhyphen{}objects. This can be useful e.g. if you want to use Fagus in an iteration. Check the particular
function you want to use for a more thorough explanation of what this does in each case

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default\_node\_type}} \textendash{} * determines if new nodes by default should be created as (d)ict or (l)ist. Must be
either “d” or “l”, default “d”

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default}} \textendash{} * \textasciitilde{} is used in get and other functions if a path doesn’t exist

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{if\_}} \textendash{} * only set value if it meets the condition specified here, otherwise do nothing. The condition can be
a lambda, any value or a tuple of accepted values. Default \_None (don’t check value)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{iter\_fill}} \textendash{} * Fill up tuples with iter\_fill (can be any object, e.g. None) to ensure that all the tuples
iter() returns are exactly max\_items long. See iter()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mod\_functions}} \textendash{} * \textasciitilde{} is used to define how different types of objects are supposed to be serialized. This is
defined in a dict. The keys are either a type (like IPAddress) or a tuple of different types
(IPv4Address, IPv6Address). The values are function pointers, or lambdas, which are supposed to convert
e.g. an IPv4Address into a string. Check out TFunc if you want to call more complicated functions with
several arguments. See README for examples

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} \textasciitilde{} creates a copy of the root node before Fagus is initialized. Makes sure that changes on this Fagus
won’t modify the root node that was passed here itself. Default False

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{get() (fagus.Fagus method)@\spxentry{get()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.get}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{default}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ Any}}
\pysigstopsignatures
\sphinxAtStartPar
Retrieves value at path. If the value doesn’t exist, default is returned.

\sphinxAtStartPar
To get “hello” from x = Fagus(\{“a”: {[}“b”, \{“c”: “d”\}{]}, e: {[}“f”, “g”{]}\}), you can use x{[}(“a”, 1, “c”){]}. The tuple
(“a”, 1, “c”) is the path\sphinxhyphen{}parameter that is used to traverse x. At first, the list at “a” is picked in the
top\sphinxhyphen{}most dict, and then the 2nd element \{“c”: “d”\} is picked from that list. Then, “d” is picked from \{“c”: “d”\}
and returned. The path\sphinxhyphen{}parameter can be a tuple or list, the keys must be either integers for lists, or any
hashable objects for dicts. For convenience, the keys can also be put in a single string separated by
path\_split (default ” “), so a{[}“a 1 c”{]} also returns “d”.

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} List/Tuple of key\sphinxhyphen{}values to recursively traverse self. Can also be specified as string, that is split
into a tuple using path\_split

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default}} \textendash{} * returned if path doesn’t exist in self

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * returns a Fagus\sphinxhyphen{}object if the value at path is a list or dict

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} Option to return a copy of the returned value. The default behaviour is that if there are subnodes
(dicts, lists) in the returned values, and you make changes to these nodes, these changes will also be
applied in the root node from which values() was called. If you want the returned values to be
independent, use copy to get a shallow copy of the returned value

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the value if the path exists, or default if it doesn’t exist

\end{description}\end{quote}

\end{fulllineitems}

\index{iter() (fagus.Fagus method)@\spxentry{iter()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.iter}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{iter}}}{\emph{\DUrole{n}{max\_depth}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{9223372036854775807}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{filter\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Optional\DUrole{p}{{[}}{\hyperref[\detokenize{fagus.filters:fagus.filters.Fil}]{\sphinxcrossref{fagus.filters.Fil}}}\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{None}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{iter\_fill}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{select}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Optional\DUrole{p}{{[}}Union\DUrole{p}{{[}}int\DUrole{p}{,}\DUrole{w}{  }Iterable\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{None}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{iter\_nodes}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{filter\_ends}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ {\hyperref[\detokenize{fagus.iterators:fagus.iterators.FagusIterator}]{\sphinxcrossref{fagus.iterators.FagusIterator}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Recursively iterate through Fagus\sphinxhyphen{}object, starting at path

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max\_depth}} \textendash{} Can be used to limit how deep the iteration goes. Example: a = \{“a”: {[}“b”, {[}“c”, “d”{]}{]}, “e”: “f”\}
If max\_depth is sys.max\_size, all the nodes are traversed: {[}(“a”, “b”, “c”), (“a”, “b”, “d”{]}),
(“e”, “f”){]}. If max\_depth is 1, iter returns {[}(“a”, “b”, {[}“c”, “d”{]}), (“e”, “f”){]}, so {[}“c”, “d”{]} is not
iterated through but returned as a node. If max\_depth is 0, iter returns {[}(“a”, {[}“b”, {[}“c”, “d”{]}{]}),
(“e”, “f”){]}, effectively the same as dict.items(). Default sys.maxitems (iterate as deeply as possible)
A negative number (e.g. \sphinxhyphen{}1) is treated as sys.maxitems.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} Start iterating at path. Internally calls get(path), and iterates on the node get returns. See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{filter\_}} \textendash{} Only iterate over specific nodes defined using Fil (see README.md and Fil for more info)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * If the leaf in the tuple is a dict or list, return it as a Fagus\sphinxhyphen{}object. This option has no
effect if max\_items is sys.maxitems.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{iter\_fill}} \textendash{} * Fill up tuples with iter\_fill (can be any object, e.g. None) to ensure that all the tuples
iter() returns are exactly max\_items long. This can be useful if you want to unpack the keys / leaves
from the tuples in a loop, which fails if the count of items in the tuples varies. This option has no
effect if max\_items is \sphinxhyphen{}1. The default value is …, meaning that the tuples are not filled, and the
length of the tuples can vary. See README.md for a more thorough example.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{select}} \textendash{} Extract only some specified values from the tuples. E.g. if \textasciitilde{} is \sphinxhyphen{}1, only the leaf\sphinxhyphen{}values are
returned. \textasciitilde{} can also be a list of indices. Default None (don’t reduce the tuples)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} Iterate on a shallow\sphinxhyphen{}copy to make sure that you can edit root node without disturbing the iteration

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{iter\_nodes}} \textendash{} * includes the traversed nodes into the resulting tuples, order is then:
node1, key1, node2, key2, …, leaf\_value

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{filter\_ends}} \textendash{} Affects the end dict/list that is returned if max\_items is used. Normally, filters are not
applied on that end node. If you would like to get the end node filtered too, set this to True. If this
is set to True, the last nodes will always be copies (if unfiltered they are references)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
FagusIterator with one tuple for each leaf\sphinxhyphen{}node, containing the keys of the parent\sphinxhyphen{}nodes until the leaf

\end{description}\end{quote}

\end{fulllineitems}

\index{filter() (fagus.Fagus method)@\spxentry{filter()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.filter}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{filter}}}{\emph{\DUrole{n}{filter\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{{\hyperref[\detokenize{fagus.filters:fagus.filters.Fil}]{\sphinxcrossref{fagus.filters.Fil}}}}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{default}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Filters self, only keeping the nodes that pass the filter

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{filter\_}} \textendash{} Fil\sphinxhyphen{}object in which the filtering\sphinxhyphen{}criteria are specified

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} at this point in self, the filtering will start (apply filter\_ relatively from this point).
Default “”, meaning that the root node is filtered, see get() and README for examples

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * return the filtered self as Fagus\sphinxhyphen{}object (default is just to return the filtered node)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} Create a copy and filter on that copy. Default is to modify the self directly

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default}} \textendash{} * returned if path doesn’t exist in self, or the value at path can’t be filtered

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the filtered object, starting at path

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if the root node needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{description}\end{quote}

\end{fulllineitems}

\index{split() (fagus.Fagus method)@\spxentry{split()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.split}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{split}}}{\emph{\DUrole{n}{filter\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Optional\DUrole{p}{{[}}{\hyperref[\detokenize{fagus.filters:fagus.filters.Fil}]{\sphinxcrossref{fagus.filters.Fil}}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{default}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ Union\DUrole{p}{{[}}Tuple\DUrole{p}{{[}}Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }Tuple\DUrole{p}{{[}}Any\DUrole{p}{,}\DUrole{w}{  }Any\DUrole{p}{{]}}\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Splits self into nodes that pass the filter, and nodes that don’t pass the filter

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{filter\_}} \textendash{} Fil\sphinxhyphen{}object in which the filtering\sphinxhyphen{}criteria are specified

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} at this position in self, the splitting will start (apply filter\_ relatively from this point).
Default “”, meaning that the root node is split, see get() and README for examples

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * return the filtered self as Fagus\sphinxhyphen{}object (default is just to return the filtered node)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} Create a copy and filter on that copy. Default is to modify the object directly

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default}} \textendash{} * returned if path doesn’t exist in self, or the

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a tuple, where the first element is the nodes that pass the filter, and the second element is the nodes that
don’t pass the filter

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if the root node needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{description}\end{quote}

\end{fulllineitems}

\index{set() (fagus.Fagus method)@\spxentry{set()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.set}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set}}}{\emph{\DUrole{n}{value}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Iterable\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}, \emph{\DUrole{n}{node\_types}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{list\_insert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}int\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{if\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{default\_node\_type}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Create (if they don’t already exist) all sub\sphinxhyphen{}nodes in path, and finally set value at leaf\sphinxhyphen{}node

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value}} \textendash{} \textasciitilde{} is placed at path, after creating new nodes if necessary. An existing value at path is overwritten

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} List/Tuple of key\sphinxhyphen{}values that are traversed in self. If no nodes exist at the keys, new nodes are
created. Can also be specified as a string, that is split into a tuple using path\_split. See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_types}} \textendash{} * Can be used to manually define if the nodes along path are supposed to be (l)ists or
(d)icts. E.g. “dll” to create a dict at level 1, and lists at level 2 and 3. ” ” can also be used \sphinxhyphen{}
space doesn’t enforce a node\sphinxhyphen{}type like d or l. For ” “, existing nodes are traversed if possible,
otherwise default\_node\_type is used to create new nodes. Default “”, interpreted as ” ” at each level.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{list\_insert}} \textendash{} * Level at which a new node shall be inserted into the list instead of traversing the
existing node in the list at that index. See README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a string, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * return self as a Fagus\sphinxhyphen{}object if it is a node (tuple / list / dict), default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{if\_}} \textendash{} * only set value if it meets the condition specified here, otherwise do nothing. The condition can be
a lambda, any value or a tuple of accepted values. Default \_None (don’t check value)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default\_node\_type}} \textendash{} * determines if new nodes by default should be created as (d)ict or (l)ist. Must be
either “d” or “l”, default “d”

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} if this is set, a copy of self is modified and then returned (thus self is not modified)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
self as a node if fagus is set, or a modified copy of self if copy is set

\item[{Raises}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if it isn’t possible to parse an int\sphinxhyphen{}index from the provided key in a position where node\sphinxhyphen{}types
    defines that the node shall be a list (if node\sphinxhyphen{}types is not l, the node will be replaced with a dict)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if the root node needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{append() (fagus.Fagus method)@\spxentry{append()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.append}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{append}}}{\emph{\DUrole{n}{value}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{node\_types}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{list\_insert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}int\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{if\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{default\_node\_type}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Create (if they don’t already exist) all sub\sphinxhyphen{}nodes in path, and finally append value to a list at leaf\sphinxhyphen{}node

\sphinxAtStartPar
If the leaf\sphinxhyphen{}node is a set, tuple or other value it is converted to a list. Then the new value is appended.

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value}} \textendash{} \textasciitilde{} is appended to list at path, after creating new nodes along path as necessary

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} List/Tuple of key\sphinxhyphen{}values that are traversed in self. If no nodes exist at the keys, new nodes are
created. Can also be specified as a string, that is split into a tuple using path\_split. See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_types}} \textendash{} * Can be used to manually define if the nodes along path are supposed to be (l)ists or
(d)icts. E.g. “dll” to create a dict at level 1, and lists at level 2 and 3. ” ” can also be used \sphinxhyphen{}
space doesn’t enforce a node\sphinxhyphen{}type like d or l. For ” “, existing nodes are traversed if possible,
otherwise default\_node\_type is used to create new nodes. Default “”, interpreted as ” ” at each level.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{list\_insert}} \textendash{} * Level at which a new node shall be inserted into the list instead of traversing the
existing node in the list at that index. See README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a string, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * return self as a Fagus\sphinxhyphen{}object if it is a node (tuple / list / dict), default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{if\_}} \textendash{} * only append value if it meets the condition specified here, otherwise do nothing. The condition can
be a lambda, any value or a tuple of accepted values. Default \_None (don’t check value)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default\_node\_type}} \textendash{} * determines if new nodes by default should be created as (d)ict or (l)ist. Must be
either “d” or “l”, default “d”

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} if this is set, a copy of self is modified and then returned (thus self is not modified)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
self as a node if fagus is set, or a modified copy of self if copy is set

\item[{Raises}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if it isn’t possible to parse an int\sphinxhyphen{}index from the provided key in a position where node\sphinxhyphen{}types
    defines that the node shall be a list (if node\sphinxhyphen{}types is not l, the node will be replaced with a dict)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if path is empty and the root node is not a list (can’t append to a dict, tuple or set) or the
    root node needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{extend() (fagus.Fagus method)@\spxentry{extend()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.extend}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{extend}}}{\emph{\DUrole{n}{values}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Iterable\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{node\_types}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{list\_insert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}int\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{if\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{default\_node\_type}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Create (if they don’t already exist) all sub\sphinxhyphen{}nodes in path. Then extend list at leaf\sphinxhyphen{}node with the new values

\sphinxAtStartPar
If the leaf\sphinxhyphen{}node is a set, tuple or other value it is converted to a list, which is extended with the new values

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{values}} \textendash{} the list at path is extended with \textasciitilde{}, after creating new nodes along path as necessary

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} List/Tuple of key\sphinxhyphen{}values that are traversed in self. If no nodes exist at the keys, new nodes are
created. Can also be specified as a string, that is split into a tuple using path\_split. See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_types}} \textendash{} * Can be used to manually define if the nodes along path are supposed to be (l)ists or
(d)icts. E.g. “dll” to create a dict at level 1, and lists at level 2 and 3. ” ” can also be used \sphinxhyphen{}
space doesn’t enforce a node\sphinxhyphen{}type like d or l. For ” “, existing nodes are traversed if possible,
otherwise default\_node\_type is used to create new nodes. Default “”, interpreted as ” ” at each level.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{list\_insert}} \textendash{} * Level at which a new node shall be inserted into the list instead of traversing the
existing node in the list at that index. See README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a string, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * return self as a Fagus\sphinxhyphen{}object if it is a node (tuple / list / dict), default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{if\_}} \textendash{} * only extend with values if they meet the condition specified here, otherwise do nothing. The
condition can be a lambda, any value or a tuple of accepted values. Default \_None (don’t check values)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default\_node\_type}} \textendash{} * determines if new nodes by default should be created as (d)ict or (l)ist. Must be
either “d” or “l”, default “d”

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} if this is set, a copy of self is modified and then returned (thus self is not modified)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
self as a node if fagus is set, or a modified copy of self if copy is set

\item[{Raises}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if it isn’t possible to parse an int\sphinxhyphen{}index from the provided key in a position where node\sphinxhyphen{}types
    defines that the node shall be a list (if node\sphinxhyphen{}types is not l, the node will be replaced with a dict)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if path is empty and the root node is not a list (can’t extend a dict, tuple or set) or the
    root node needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{insert() (fagus.Fagus method)@\spxentry{insert()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.insert}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{insert}}}{\emph{\DUrole{n}{index}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{value}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{node\_types}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{list\_insert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}int\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{if\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{default\_node\_type}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Create (if they don’t already exist) all sub\sphinxhyphen{}nodes in path. Insert new value at index in list at leaf\sphinxhyphen{}node

\sphinxAtStartPar
If the leaf\sphinxhyphen{}node is a set, tuple or other value it is converted to a list, in which the new value is inserted at
index

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{index}} \textendash{} \textasciitilde{} at which the value shall be inserted in the list at path

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value}} \textendash{} \textasciitilde{} is inserted at index into list at path, after creating new nodes along path as necessary

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} List/Tuple of key\sphinxhyphen{}values that are traversed in self. If no nodes exist at the keys, new nodes are
created. Can also be specified as a string, that is split into a tuple using path\_split. See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_types}} \textendash{} * Can be used to manually define if the nodes along path are supposed to be (l)ists or
(d)icts. E.g. “dll” to create a dict at level 1, and lists at level 2 and 3. ” ” can also be used \sphinxhyphen{}
space doesn’t enforce a node\sphinxhyphen{}type like d or l. For ” “, existing nodes are traversed if possible,
otherwise default\_node\_type is used to create new nodes. Default “”, interpreted as ” ” at each level.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{list\_insert}} \textendash{} * Level at which a new node shall be inserted into the list instead of traversing the
existing node in the list at that index. See README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a string, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * return self as a Fagus\sphinxhyphen{}object if it is a node (tuple / list / dict), default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{if\_}} \textendash{} * only insert value if it meets the condition specified here, otherwise do nothing. The condition can
be a lambda, any value or a tuple of accepted values. Default \_None (don’t check value)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default\_node\_type}} \textendash{} * determines if new nodes by default should be created as (d)ict or (l)ist. Must be
either “d” or “l”, default “d”

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} if this is set, a copy of self is modified and then returned (thus self is not modified)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
self as a node if fagus is set, or a modified copy of self if copy is set

\item[{Raises}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if it isn’t possible to parse an int\sphinxhyphen{}index from the provided key in a position where node\sphinxhyphen{}types
    defines that the node shall be a list (if node\sphinxhyphen{}types is not l, the node will be replaced with a dict)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if path is empty and the root node is not a list (can’t insert into dict, tuple or set) or the
    root node needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{add() (fagus.Fagus method)@\spxentry{add()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.add}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add}}}{\emph{\DUrole{n}{value}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{node\_types}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{list\_insert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}int\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{if\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{default\_node\_type}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Create (if they don’t already exist) all sub\sphinxhyphen{}nodes in path, and finally add new value to set at leaf\sphinxhyphen{}node

\sphinxAtStartPar
If the leaf\sphinxhyphen{}node is a list, tuple or other value it is converted to a set, to which the new value is added

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value}} \textendash{} \textasciitilde{} is added to set at path, after creating new nodes along path as necessary

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} List/Tuple of key\sphinxhyphen{}values that are traversed in self. If no nodes exist at the keys, new nodes are
created. Can also be specified as a string, that is split into a tuple using path\_split. See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_types}} \textendash{} * Can be used to manually define if the nodes along path are supposed to be (l)ists or
(d)icts. E.g. “dll” to create a dict at level 1, and lists at level 2 and 3. ” ” can also be used \sphinxhyphen{}
space doesn’t enforce a node\sphinxhyphen{}type like d or l. For ” “, existing nodes are traversed if possible,
otherwise default\_node\_type is used to create new nodes. Default “”, interpreted as ” ” at each level.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{list\_insert}} \textendash{} * Level at which a new node shall be inserted into the list instead of traversing the
existing node in the list at that index. See README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a string, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * return self as a Fagus\sphinxhyphen{}object if it is a node (tuple / list / dict), default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{if\_}} \textendash{} * only add value if it meets the condition specified here, otherwise do nothing. The condition can be
a lambda, any value or a tuple of accepted values. Default \_None (don’t check value)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default\_node\_type}} \textendash{} * determines if new nodes by default should be created as (d)ict or (l)ist. Must be
either “d” or “l”, default “d”

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} if this is set, a copy of self is modified and then returned (thus self is not modified)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
self as a node if fagus is set, or a modified copy of self if copy is set

\item[{Raises}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if it isn’t possible to parse an int\sphinxhyphen{}index from the provided key in a position where node\sphinxhyphen{}types
    defines that the node shall be a list (if node\sphinxhyphen{}types is not l, the node will be replaced with a dict)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if path is empty and the root node is not a set (can’t add to list or dict) or the root node
    needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{update() (fagus.Fagus method)@\spxentry{update()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.update}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{update}}}{\emph{\DUrole{n}{values}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Iterable\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{node\_types}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{list\_insert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}int\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{if\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{default\_node\_type}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Create (if they don’t already exist) all sub\sphinxhyphen{}nodes in path, then update set at leaf\sphinxhyphen{}node with new values

\sphinxAtStartPar
If the leaf\sphinxhyphen{}node is a list, tuple or other value it is converted to a set. That set is then updated with the new
values. If the node at path is a dict, and values also is a dict, the node\sphinxhyphen{}dict is updated with the new values.

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{values}} \textendash{} the set/dict at path is updated with \textasciitilde{}, after creating new nodes along path as necessary

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} List/Tuple of key\sphinxhyphen{}values that are traversed in self. If no nodes exist at the keys, new nodes are
created. Can also be specified as a string, that is split into a tuple using path\_split. See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_types}} \textendash{} * Can be used to manually define if the nodes along path are supposed to be (l)ists or
(d)icts. E.g. “dll” to create a dict at level 1, and lists at level 2 and 3. ” ” can also be used \sphinxhyphen{}
space doesn’t enforce a node\sphinxhyphen{}type like d or l. For ” “, existing nodes are traversed if possible,
otherwise default\_node\_type is used to create new nodes. Default “”, interpreted as ” ” at each level.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{list\_insert}} \textendash{} * Level at which a new node shall be inserted into the list instead of traversing the
existing node in the list at that index. See README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a string, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * return self as a Fagus\sphinxhyphen{}object if it is a node (tuple / list / dict), default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{if\_}} \textendash{} * only update with values if they meet the condition specified here, otherwise do nothing. The
condition can be a lambda, any value or a tuple of accepted values. Default \_None (don’t check values)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default\_node\_type}} \textendash{} * determines if new nodes by default should be created as (d)ict or (l)ist. Must be
either “d” or “l”, default “d”

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} if this is set, a copy of self is modified and then returned (thus self is not modified)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
self as a node if fagus is set, or a modified copy of self if copy is set

\item[{Raises}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if it isn’t possible to parse an int\sphinxhyphen{}index from the provided key in a position where node\sphinxhyphen{}types
    defines that the node shall be a list (if node\sphinxhyphen{}types is not l, the node will be replaced with a dict)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if path is empty and the root node is not a set or dict (can’t update list) or the root node
    needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{setdefault() (fagus.Fagus method)@\spxentry{setdefault()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.setdefault}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setdefault}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{default}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{node\_types}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{list\_insert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}int\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{default\_node\_type}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ Any}}
\pysigstopsignatures
\sphinxAtStartPar
Get value at path and return it. If there is no value at path, set default at path, and return default

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} position in self where default shall be set / from where value shall be fetched. See get() and README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default}} \textendash{} * returned if path doesn’t exist in self

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * return self as a Fagus\sphinxhyphen{}object if it is a node (tuple / list / dict), default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_types}} \textendash{} * Can be used to manually define if the nodes along path are supposed to be (l)ists or
(d)icts. E.g. “dll” to create a dict at level 1, and lists at level 2 and 3. ” ” can also be used \sphinxhyphen{}
space doesn’t enforce a node\sphinxhyphen{}type like d or l. For ” “, existing nodes are traversed if possible,
otherwise default\_node\_type is used to create new nodes. Default “”, interpreted as ” ” at each level.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{list\_insert}} \textendash{} * Level at which a new node shall be inserted into the list instead of traversing the
existing node in the list at that index. See README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default\_node\_type}} \textendash{} * determines if new nodes by default should be created as (d)ict or (l)ist. Must be
either “d” or “l”, default “d”

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
value at path if it exists, otherwise default is set at path and returned

\item[{Raises}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if it isn’t possible to parse an int\sphinxhyphen{}index from the provided key in a position where node\sphinxhyphen{}types
    defines that the node shall be a list (if node\sphinxhyphen{}types is not l, the node will be replaced with a dict)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if the root node needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{mod() (fagus.Fagus method)@\spxentry{mod()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.mod}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mod}}}{\emph{\DUrole{n}{mod\_function}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Callable\DUrole{p}{{[}}\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }Any\DUrole{p}{{]}}}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Iterable\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}, \emph{\DUrole{n}{default}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{replace\_value}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{True}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{node\_types}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{list\_insert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}int\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{default\_node\_type}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ Any}}
\pysigstopsignatures
\sphinxAtStartPar
Modifies the value at path using the function\sphinxhyphen{}pointer mod\_function

\sphinxAtStartPar
mod can be used like this Fagus.mod(obj, “kitchen spoon”, lambda x: x + 1, 1) to count the number of spoons in
the kitchen. If there is no value to modify, the default value (here 1) will be set at the node.

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mod\_function}} \textendash{} A function pointer or lambda that modifies the existing value at path. TFunc can be used to
call more complex functions requiring several arguments.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} position in self at which the value shall be modified. Defined as a list/Tuple of key\sphinxhyphen{}values to
recursively traverse self. Can also be specified as string which is split into a tuple using path\_split

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default}} \textendash{} * this value is set in path if it doesn’t exist

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * Return new value as a Fagus\sphinxhyphen{}object if it is a node (tuple / list / dict), default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{replace\_value}} \textendash{} Replace the old value with what mod\_function returns. Can be deactivated e.g. if mod\_function
changes the object, but returns None (if \textasciitilde{} stays on, the object is replaced with None). Default True.
If no value exists at path, the default value is always set at path (independent of \textasciitilde{})

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_types}} \textendash{} * Can be used to manually define if the nodes along path are supposed to be (l)ists or
(d)icts. E.g. “dll” to create a dict at level 1, and lists at level 2 and 3. ” ” can also be used \sphinxhyphen{}
space doesn’t enforce a node\sphinxhyphen{}type like d or l. For ” “, existing nodes are traversed if possible,
otherwise default\_node\_type is used to create new nodes. Default “”, interpreted as ” ” at each level.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{list\_insert}} \textendash{} * Level at which a new node shall be inserted into the list instead of traversing the
existing node in the list at that index. See README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default\_node\_type}} \textendash{} * determines if new nodes by default should be created as (d)ict or (l)ist. Must be
either “d” or “l”, default “d”

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the new value that was returned by the mod\_function, or default if there was no value at path

\item[{Raises}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if it isn’t possible to parse an int\sphinxhyphen{}index from the provided key in a position where node\sphinxhyphen{}types
    defines that the node shall be a list (if node\sphinxhyphen{}types is not l, the node will be replaced with a dict)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if the root node needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{mod\_all() (fagus.Fagus method)@\spxentry{mod\_all()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.mod_all}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mod\_all}}}{\emph{\DUrole{n}{mod\_function}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Callable\DUrole{p}{{[}}\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }Any\DUrole{p}{{]}}}}, \emph{\DUrole{n}{filter\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Optional\DUrole{p}{{[}}{\hyperref[\detokenize{fagus.filters:fagus.filters.Fil}]{\sphinxcrossref{fagus.filters.Fil}}}\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{None}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{replace\_value}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{True}}, \emph{\DUrole{n}{default}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{max\_depth}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{9223372036854775807}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ Any}}
\pysigstopsignatures
\sphinxAtStartPar
Modify all the leaf\sphinxhyphen{}values that match a certain filter

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mod\_function}} \textendash{} A function pointer or lambda that modifies the existing value at path. TFunc can be used to
call more complex functions requiring several arguments.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{filter\_}} \textendash{} used to select which leaves shall be modified. Default None (all leaves are modified)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} position in self at which the value shall be modified. See get() / README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default}} \textendash{} * this value is returned if path doesn’t exist, or if no leaves match the filter

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * Return new value as a Fagus\sphinxhyphen{}object if it is a node (tuple / list / dict), default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{replace\_value}} \textendash{} Replace the old value with what mod\_function returns. Can be deactivated e.g. if mod\_function
changes the object, but returns None (if \textasciitilde{} stays on, the object is replaced with None). Default True.
If no value exists at path, the default value is always set at path (independent of \textasciitilde{})

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max\_depth}} \textendash{} Defines the maximum depth for the iteration. See Fagus.iter max\_depth for more information

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} Can be ued to make sure that the node at path is not modified (instead a modified copy is returned)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the node at path where all the leaves matching filter\_ are modified, or default if it didn’t exist

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if the root node needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{description}\end{quote}

\end{fulllineitems}

\index{serialize() (fagus.Fagus method)@\spxentry{serialize()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.serialize}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{serialize}}}{\emph{\DUrole{n}{mod\_functions}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Optional\DUrole{p}{{[}}Mapping\DUrole{p}{{[}}Union\DUrole{p}{{[}}type\DUrole{p}{,}\DUrole{w}{  }Tuple\DUrole{p}{{[}}type\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }str\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }Callable\DUrole{p}{{[}}\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }Any\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{None}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{node\_types}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{list\_insert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}int\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ Union\DUrole{p}{{[}}Dict\DUrole{p}{{[}}Any\DUrole{p}{,}\DUrole{w}{  }Any\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }List\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Makes sure the object can be serialized so that it can be converted to JSON, YAML etc.

\sphinxAtStartPar
The only allowed data\sphinxhyphen{}types for serialization are: dict, list, bool, float, int, str, None

\sphinxAtStartPar
Sets and tuples are converted into lists. Other objects whose types are not allowed in serialized objects are
modified to a type that is allowed using the mod\_functions\sphinxhyphen{}parameter. mod\_functions is a dict, with the type
of object like IPv4Address or a tuple of types like (IPv4Address, IPv6Address). The values are function pointers
or lambdas, that are executed to convert e.g. an IPv4Address to one of the allowed data types mentioned above.

\sphinxAtStartPar
The default mod\_functions are: \{datetime: lambda x: x.isoformat(), date: lambda x: x.isoformat(), time:
lambda x: x.isoformat(), “default”: lambda x: str(x)\}

\sphinxAtStartPar
By default, date, datetime and time\sphinxhyphen{}objects are replaced by their isoformat\sphinxhyphen{}string. All other objects whose
types don’t appear in mod\_functions are modified by the function behind the key “default”. By default, this
function is lambda x: str(x) that replaces the object with its string\sphinxhyphen{}representation.

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mod\_functions}} \textendash{} * \textasciitilde{} is used to define how different types of objects are supposed to be serialized. This is
defined in a dict. The keys are either a type (like IPAddress) or a tuple of different types
(IPv4Address, IPv6Address). The values are function pointers, or lambdas, which are supposed to convert
e.g. an IPv4Address into a string. Check out TFunc if you want to call more complicated functions with
several arguments. See README for examples

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} position in self at which the value shall be modified. See get() / README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_types}} \textendash{} * Can be used to manually define if the nodes along path are supposed to be (l)ists or
(d)icts. E.g. “dll” to create a dict at level 1, and lists at level 2 and 3. ” ” can also be used \sphinxhyphen{}
space doesn’t enforce a node\sphinxhyphen{}type like d or l. For ” “, existing nodes are traversed if possible,
otherwise default\_node\_type is used to create new nodes. Default “”, interpreted as ” ” at each level.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{list\_insert}} \textendash{} * Level at which a new node shall be inserted into the list instead of traversing the
existing node in the list at that index. See README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} Create a copy and make that copy serializable. Default is to modify self directly

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a serializable object that only contains types allowed in json or yaml

\item[{Raises}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if root node is not a dict or list (serialize can’t fix that for the root node)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if tuple\_keys is not defined in mod\_functions and a dict has tuples as keys

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Exception}} \textendash{} Can raise any exception if it occurs in one of the mod\_functions

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{merge() (fagus.Fagus method)@\spxentry{merge()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.merge}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{merge}}}{\emph{\DUrole{n}{obj}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}{\hyperref[\detokenize{fagus.iterators:fagus.iterators.FagusIterator}]{\sphinxcrossref{fagus.iterators.FagusIterator}}}\DUrole{p}{,}\DUrole{w}{  }Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{new\_value\_action}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}r\textquotesingle{}}}, \emph{\DUrole{n}{extend\_from}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{9223372036854775807}}, \emph{\DUrole{n}{update\_from}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{9223372036854775807}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{copy\_obj}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{node\_types}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{list\_insert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}int\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{default\_node\_type}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Merges two or more tree\sphinxhyphen{}objects to update and extend the root node
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{obj}} \textendash{} tree\sphinxhyphen{}object that shall be merged. Can also be a FagusIterator returned from iter() to only merge
values matching a filter defined in iter()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} position in root where the new objects shall be merged, default “”

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{new\_value\_action}} \textendash{} This parameter defines what merge is supposed to do if a value at a path is present in the
root and in one of the objects to merge. The possible values are: (r)eplace \sphinxhyphen{} the value in the root is
replaced with the new value, this is the default behaviour; (i)gnore \sphinxhyphen{} the value in the root is not
updated; (a)ppend \sphinxhyphen{} the old and new value are both put into a list, and thus aggregated

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{extend\_from}} \textendash{} By default, lists are traversed, so the value at index i will be compared in both lists. If
at some point you rather want to just append the contents from the objects to be merged, use this
parameter to define the level (count of keys) from which lists should be extended isf traversed. Default
infinite (never extend lists)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{update\_from}} \textendash{} Like extend\_from, but for dicts. Allows you to define at which level the contents of the root
should just be updated with the contents of the objects instead of traversing and comparing each value

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} whether the returned tree\sphinxhyphen{}object should be returned as Fagus

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} Don’t modify the root node, modify and return a copy instead

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy\_obj}} \textendash{} The objects to be merged are not modified, but references to subnodes of the objects can be
put into the root node. Set this to True to prevent that and keep root and objects independent

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_types}} \textendash{} * Can be used to manually define if the nodes along path are supposed to be (l)ists or
(d)icts. E.g. “dll” to create a dict at level 1, and lists at level 2 and 3. ” ” can also be used \sphinxhyphen{}
space doesn’t enforce a node\sphinxhyphen{}type like d or l. For ” “, existing nodes are traversed if possible,
otherwise default\_node\_type is used to create new nodes. Default “”, interpreted as ” ” at each level.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{list\_insert}} \textendash{} * Level at which a new node shall be inserted into the list instead of traversing the
existing node in the list at that index. See README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default\_node\_type}} \textendash{} * determines if new nodes by default should be created as (d)ict or (l)ist. Must be
either “d” or “l”, default “d”

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a reference to the modified root node, or a modified copy of the root node (see copy\sphinxhyphen{}parameter)

\item[{Raises}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if it isn’t possible to parse an int\sphinxhyphen{}index from the provided key in a position where node\sphinxhyphen{}types
    defines that the node shall be a list (if node\sphinxhyphen{}types is not l, the node will be replaced with a dict)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if obj is not either a FagusIterator or a Collection. Also raised if you try to merge different
    types of nodes at root level, e.g. a dict can only be merged with another Mapping, and a list can only
    be merged with another Iterable. \textasciitilde{} is also raised if a not modifiable root node needs to be modified

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{pop() (fagus.Fagus method)@\spxentry{pop()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.pop}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pop}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{default}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ Any}}
\pysigstopsignatures
\sphinxAtStartPar
Deletes the value at path and returns it

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} pop value at this position in self, or don’t do anything if path doesn’t exist in self

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default}} \textendash{} * returned if path doesn’t exist in self

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * return the result as Fagus\sphinxhyphen{}object if possible (default is just to return the result)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
value at path if it exists, or default if it doesn’t

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if the root node needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{description}\end{quote}

\end{fulllineitems}

\index{popitem() (fagus.Fagus method)@\spxentry{popitem()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.popitem}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{popitem}}}{}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
This function is not implemented in Fagus

\sphinxAtStartPar
Implementing this would require to cache the value, which was not prioritized to keep memory usage low.

\end{fulllineitems}

\index{discard() (fagus.Fagus method)@\spxentry{discard()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.discard}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{discard}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Deletes the value at path if it exists

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} pop value at this position in self, or don’t do anything if path doesn’t exist in self

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\end{itemize}

\end{description}\end{quote}

\sphinxAtStartPar
Returns: None

\end{fulllineitems}

\index{remove() (fagus.Fagus method)@\spxentry{remove()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.remove}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{remove}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Deletes the value at path if it exists, raises KeyError if it doesn’t

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} pop value at this position in self, or don’t do anything if path doesn’t exist in self

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\end{itemize}

\end{description}\end{quote}

\sphinxAtStartPar
Returns: None
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{KeyError}} \textendash{} if the value at path doesn’t exist

\end{description}\end{quote}

\end{fulllineitems}

\index{keys() (fagus.Fagus method)@\spxentry{keys()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.keys}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{keys}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ Iterable\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Returns keys for the node at path, or None if that node is a set or doesn’t exist / doesn’t have keys

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} get keys for node at this position in self. Default “” (gets values from the root node), See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
keys for the node at path, or an empty tuple if that node is a set or doesn’t exist / doesn’t have keys

\end{description}\end{quote}

\end{fulllineitems}

\index{values() (fagus.Fagus method)@\spxentry{values()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.values}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{values}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ Iterable\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Returns values for node at path

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} get values at this position in self, default “” (gets values from the root node). See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * converts sub\sphinxhyphen{}nodes into Fagus\sphinxhyphen{}objects in the returned list of values, default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} \textasciitilde{} creates a copy of the node before values() are returned. This can be beneficial if you want to make
changes to the returned nodes, but you don’t want to change self. Default False

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
values for the node at path. Returns an empty tuple if the value doesn’t exist, or just the value in a
tuple if the node isn’t iterable.

\end{description}\end{quote}

\end{fulllineitems}

\index{items() (fagus.Fagus method)@\spxentry{items()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.items}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{items}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ Iterable\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Returns in iterator of (key, value)\sphinxhyphen{}tuples in self, like dict.items()

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} get items at this position in self, Default “” (gets values from the root node). See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * converts sub\sphinxhyphen{}nodes into Fagus\sphinxhyphen{}objects in the returned iterator, default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} \textasciitilde{} creates a copy of the node before items() are returned. This can be beneficial if you want to make
changes to the returned nodes, but you don’t want to change self. Default False

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
iterator of (key, value)\sphinxhyphen{}tuples in self, like dict.items()

\end{description}\end{quote}

\end{fulllineitems}

\index{clear() (fagus.Fagus method)@\spxentry{clear()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.clear}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{clear}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Removes all elements from node at path.

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} clear at this position in self, Default “” (gets values from the root node). See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} if \textasciitilde{} is set, a copy of self is modified and then returned (thus self is not modified), default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * return self as a Fagus\sphinxhyphen{}object if it is a node (tuple / list / dict), default False

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
self as a node if fagus is set, or a modified copy of self if copy is set

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if the root node needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{description}\end{quote}

\end{fulllineitems}

\index{contains() (fagus.Fagus method)@\spxentry{contains()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.contains}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{contains}}}{\emph{\DUrole{n}{value}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ bool}}
\pysigstopsignatures
\sphinxAtStartPar
Check if value is present in the node at path

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value}} \textendash{} value to check

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} check if value is in node at this position in self, Default “” (checks root node). See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
whether value is in node at path in self. returns value == node if the node isn’t iterable, and false if
path doesn’t exit in self

\end{description}\end{quote}

\end{fulllineitems}

\index{count() (fagus.Fagus method)@\spxentry{count()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.count}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{count}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ int}}
\pysigstopsignatures
\sphinxAtStartPar
Check the number of elements in the node at path

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} position in self where the number of elements shall be found.Default “” (checks root node). See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the number of elements in the node at path. if there is no node at path, 0 is returned. If the element
at path is not a node, 1 is returned

\end{description}\end{quote}

\end{fulllineitems}

\index{index() (fagus.Fagus method)@\spxentry{index()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.index}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{index}}}{\emph{\DUrole{n}{value}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}, \emph{\DUrole{n}{start}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}int\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{stop}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}int\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{all\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}Union\DUrole{p}{{[}}int\DUrole{p}{,}\DUrole{w}{  }Any\DUrole{p}{,}\DUrole{w}{  }Sequence\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Returns the index / key of the specified value in the node at path if it exists
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value}} \textendash{} \textasciitilde{} to search index for

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{start}} \textendash{} start searching at this index. Only applicable if the node at path is a list / tuple

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{stop}} \textendash{} stop searching at this index. Only applicable if the node at path is a list / tuple

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} position in self where the node shall be searched for value. Default “” (checks root node). See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{all\_}} \textendash{} returns all matching indices / keys in a generator (instead of only the first)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
The first index of value if the node at path is a list, or the first key containing value if the node at
path is a dict. True if the node at path is a Set and contains value. If the element can’t be found in the
node at path, or there is no Collection at path, None is returned (instead of a ValueError).

\end{description}\end{quote}

\end{fulllineitems}

\index{isdisjoint() (fagus.Fagus method)@\spxentry{isdisjoint()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.isdisjoint}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{isdisjoint}}}{\emph{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Iterable\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{dict\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}keys\textquotesingle{}}}}{{ $\rightarrow$ bool}}
\pysigstopsignatures
\sphinxAtStartPar
Returns whether the other iterable is disjoint (has no common items) with the node at path

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{other}} \textendash{} other object to check

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} check if the node at this position in self, is disjoint from other

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dict\_}} \textendash{} use (k)eys, (v)alues or (i)tems for if value is a dict. Default keys

\end{itemize}

\end{description}\end{quote}
\begin{description}
\item[{Returns: whether the other iterable is disjoint from the value at path. If value is a dict, the keys are used.}] \leavevmode
\sphinxAtStartPar
Checks if value is present in other if value isn’t iterable. Returns True if there is no value at path.

\end{description}

\end{fulllineitems}

\index{child() (fagus.Fagus method)@\spxentry{child()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.child}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{child}}}{\emph{\DUrole{n}{obj}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Optional\DUrole{p}{{[}}Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{{ $\rightarrow$ {\hyperref[\detokenize{fagus.fagus:fagus.fagus.Fagus}]{\sphinxcrossref{fagus.fagus.Fagus}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Creates a Fagus\sphinxhyphen{}object for obj that has the same options as self

\end{fulllineitems}

\index{reversed() (fagus.Fagus method)@\spxentry{reversed()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.reversed}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reversed}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ Iterator\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Get reversed child\sphinxhyphen{}node at path if that node is a list

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} position in self where a list / tuple shall be returned reversed

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * converts sub\sphinxhyphen{}nodes into Fagus\sphinxhyphen{}objects in the returned iterator, default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} \textasciitilde{} creates a copy of the node before it is returned reversed(). This can be beneficial if you want to
make changes to the returned nodes, but you don’t want to change self. Default False

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a reversed iterator on the node at path (empty if path doesn’t exist)

\end{description}\end{quote}

\end{fulllineitems}

\index{reverse() (fagus.Fagus method)@\spxentry{reverse()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.reverse}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reverse}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Reverse child\sphinxhyphen{}node at path if that node exists and is reversible

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} position in self where a list / tuple shall be reversed

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * converts sub\sphinxhyphen{}nodes into Fagus\sphinxhyphen{}objects in the returned iterator, default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} \textasciitilde{} creates a copy of the node before it is returned reversed(). This can be beneficial if you want to
make changes to the returned nodes, but you don’t want to change self. Default False

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
self as a node if fagus is set, or a modified copy of self if copy is set

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if the root node needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (fagus.Fagus method)@\spxentry{copy()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.copy}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{\DUrole{n}{deep}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Creates a copy of self. Creates a recursive shallow copy by default, or a copy.deepcopy() if deep is set.

\end{fulllineitems}

\index{options() (fagus.Fagus method)@\spxentry{options()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.options}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{options}}}{\emph{\DUrole{n}{options}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Optional\DUrole{p}{{[}}Dict\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }Any\DUrole{p}{{]}}\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{None}}, \emph{\DUrole{n}{get\_default\_options}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{reset}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ Dict\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Function to set multiple Fagus\sphinxhyphen{}options in one line
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{options}} \textendash{} dict with options that shall be set

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{get\_default\_options}} \textendash{} return all options (include default\sphinxhyphen{}values). Default: only return options that are set

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{reset}} \textendash{} if \textasciitilde{} is set, all options are reset before options is set

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a dict of options that are set, or all options if get\_default\_options is set

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_copy\_\_() (fagus.Fagus method)@\spxentry{\_\_copy\_\_()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.__copy__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_copy\_\_}}}{\emph{\DUrole{n}{recursive}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Recursively creates a shallow\sphinxhyphen{}copy of self

\end{fulllineitems}

\index{\_\_call\_\_() (fagus.Fagus method)@\spxentry{\_\_call\_\_()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.__call__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_call\_\_}}}{}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Calling the Fagus\sphinxhyphen{}object returns the root node the Fagus\sphinxhyphen{}object is wrapped around (equivalent to .root)
\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{fagus} \PYG{k+kn}{import} \PYG{n}{Fagus}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Fagus}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{q}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}
\PYG{g+go}{Fagus(\PYGZob{}\PYGZsq{}f\PYGZsq{}: \PYGZsq{}q\PYGZsq{}\PYGZcb{})}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}\PYGZsq{}f\PYGZsq{}: \PYGZsq{}q\PYGZsq{}\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{root}  \PYG{c+c1}{\PYGZsh{} .root returns the root\PYGZhy{}object in the same way as ()}
\PYG{g+go}{\PYGZob{}\PYGZsq{}f\PYGZsq{}: \PYGZsq{}q\PYGZsq{}\PYGZcb{}}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
the root object Fagus is wrapped around

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_getattr\_\_() (fagus.Fagus method)@\spxentry{\_\_getattr\_\_()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.__getattr__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_getattr\_\_}}}{\emph{\DUrole{n}{attr}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}}}{{ $\rightarrow$ Any}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_getitem\_\_() (fagus.Fagus method)@\spxentry{\_\_getitem\_\_()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.__getitem__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_getitem\_\_}}}{\emph{\DUrole{n}{item}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}}{{ $\rightarrow$ Any}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_setattr\_\_() (fagus.Fagus method)@\spxentry{\_\_setattr\_\_()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.__setattr__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_setattr\_\_}}}{\emph{\DUrole{n}{attr}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}}, \emph{\DUrole{n}{value}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Implement setattr(self, name, value).

\end{fulllineitems}

\index{\_\_setitem\_\_() (fagus.Fagus method)@\spxentry{\_\_setitem\_\_()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.__setitem__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_setitem\_\_}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}, \emph{\DUrole{n}{value}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_delattr\_\_() (fagus.Fagus method)@\spxentry{\_\_delattr\_\_()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.__delattr__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_delattr\_\_}}}{\emph{\DUrole{n}{attr}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Implement delattr(self, name).

\end{fulllineitems}

\index{\_\_delitem\_\_() (fagus.Fagus method)@\spxentry{\_\_delitem\_\_()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.__delitem__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_delitem\_\_}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_iter\_\_() (fagus.Fagus method)@\spxentry{\_\_iter\_\_()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.__iter__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_iter\_\_}}}{}{{ $\rightarrow$ Iterator\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_hash\_\_() (fagus.Fagus method)@\spxentry{\_\_hash\_\_()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.__hash__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_hash\_\_}}}{}{{ $\rightarrow$ int}}
\pysigstopsignatures
\sphinxAtStartPar
Return hash(self).

\end{fulllineitems}

\index{\_\_eq\_\_() (fagus.Fagus method)@\spxentry{\_\_eq\_\_()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.__eq__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_eq\_\_}}}{\emph{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}}{{ $\rightarrow$ bool}}
\pysigstopsignatures
\sphinxAtStartPar
Return self==value.

\end{fulllineitems}

\index{\_\_ne\_\_() (fagus.Fagus method)@\spxentry{\_\_ne\_\_()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.__ne__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_ne\_\_}}}{\emph{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}}{{ $\rightarrow$ bool}}
\pysigstopsignatures
\sphinxAtStartPar
Return self!=value.

\end{fulllineitems}

\index{\_\_lt\_\_() (fagus.Fagus method)@\spxentry{\_\_lt\_\_()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.__lt__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_lt\_\_}}}{\emph{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}}{{ $\rightarrow$ bool}}
\pysigstopsignatures
\sphinxAtStartPar
Return self\textless{}value.

\end{fulllineitems}

\index{\_\_le\_\_() (fagus.Fagus method)@\spxentry{\_\_le\_\_()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.__le__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_le\_\_}}}{\emph{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}}{{ $\rightarrow$ bool}}
\pysigstopsignatures
\sphinxAtStartPar
Return self\textless{}=value.

\end{fulllineitems}

\index{\_\_gt\_\_() (fagus.Fagus method)@\spxentry{\_\_gt\_\_()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.__gt__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_gt\_\_}}}{\emph{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}}{{ $\rightarrow$ bool}}
\pysigstopsignatures
\sphinxAtStartPar
Return self\textgreater{}value.

\end{fulllineitems}

\index{\_\_ge\_\_() (fagus.Fagus method)@\spxentry{\_\_ge\_\_()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.__ge__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_ge\_\_}}}{\emph{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}}{{ $\rightarrow$ bool}}
\pysigstopsignatures
\sphinxAtStartPar
Return self\textgreater{}=value.

\end{fulllineitems}

\index{\_\_contains\_\_() (fagus.Fagus method)@\spxentry{\_\_contains\_\_()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.__contains__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_contains\_\_}}}{\emph{\DUrole{n}{value}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}}{{ $\rightarrow$ bool}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_len\_\_() (fagus.Fagus method)@\spxentry{\_\_len\_\_()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.__len__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_len\_\_}}}{}{{ $\rightarrow$ int}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_bool\_\_() (fagus.Fagus method)@\spxentry{\_\_bool\_\_()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.__bool__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_bool\_\_}}}{}{{ $\rightarrow$ bool}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_repr\_\_() (fagus.Fagus method)@\spxentry{\_\_repr\_\_()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.__repr__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_repr\_\_}}}{}{{ $\rightarrow$ str}}
\pysigstopsignatures
\sphinxAtStartPar
Return repr(self).

\end{fulllineitems}

\index{\_\_str\_\_() (fagus.Fagus method)@\spxentry{\_\_str\_\_()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.__str__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_str\_\_}}}{}{{ $\rightarrow$ str}}
\pysigstopsignatures
\sphinxAtStartPar
Return str(self).

\end{fulllineitems}

\index{\_\_iadd\_\_() (fagus.Fagus method)@\spxentry{\_\_iadd\_\_()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.__iadd__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_iadd\_\_}}}{\emph{\DUrole{n}{value}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_add\_\_() (fagus.Fagus method)@\spxentry{\_\_add\_\_()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.__add__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_add\_\_}}}{\emph{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_radd\_\_() (fagus.Fagus method)@\spxentry{\_\_radd\_\_()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.__radd__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_radd\_\_}}}{\emph{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_isub\_\_() (fagus.Fagus method)@\spxentry{\_\_isub\_\_()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.__isub__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_isub\_\_}}}{\emph{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_sub\_\_() (fagus.Fagus method)@\spxentry{\_\_sub\_\_()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.__sub__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_sub\_\_}}}{\emph{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_rsub\_\_() (fagus.Fagus method)@\spxentry{\_\_rsub\_\_()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.__rsub__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_rsub\_\_}}}{\emph{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_imul\_\_() (fagus.Fagus method)@\spxentry{\_\_imul\_\_()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.__imul__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_imul\_\_}}}{\emph{\DUrole{n}{times}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_mul\_\_() (fagus.Fagus method)@\spxentry{\_\_mul\_\_()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.__mul__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_mul\_\_}}}{\emph{\DUrole{n}{times}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}}{{ $\rightarrow$ Union\DUrole{p}{{[}}Tuple\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }List\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{{]}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_rmul\_\_() (fagus.Fagus method)@\spxentry{\_\_rmul\_\_()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.__rmul__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_rmul\_\_}}}{\emph{\DUrole{n}{times}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}}{{ $\rightarrow$ Union\DUrole{p}{{[}}Tuple\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }List\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{{]}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_abstractmethods\_\_ (fagus.Fagus attribute)@\spxentry{\_\_abstractmethods\_\_}\spxextra{fagus.Fagus attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.__abstractmethods__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_abstractmethods\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }frozenset(\{\})}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_dict\_\_ (fagus.Fagus attribute)@\spxentry{\_\_dict\_\_}\spxextra{fagus.Fagus attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.__dict__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_dict\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }mappingproxy(\{\textquotesingle{}\_\_module\_\_\textquotesingle{}: \textquotesingle{}fagus.fagus\textquotesingle{}, \textquotesingle{}\_\_doc\_\_\textquotesingle{}: \textquotesingle{}Fagus is a wrapper\sphinxhyphen{}class for complex, nested objects of dicts and lists in Python\textbackslash{}n\textbackslash{}n    Fagus can be used as an object by instantiating it, but it\textbackslash{}\textquotesingle{}s also possible to use all methods statically without\textbackslash{}n    even an object, so that a = \{\}; Fagus.set(a, "top med", 1) and a = Fagus(\{\}); a.set(1, "top med") do the same.\textbackslash{}n\textbackslash{}n    The root node is always modified directly. If you don\textbackslash{}\textquotesingle{}t want to change the root node, all the functions where it\textbackslash{}n    makes sense support to rather modify a copy, and return that modified copy using the copy\sphinxhyphen{}parameter.\textbackslash{}n\textbackslash{}n    **FagusOptions**:\textbackslash{}n    Several parameters used in functions in Fagus work as options so that you don\textbackslash{}\textquotesingle{}t have to specify them each time you\textbackslash{}n    run a function. In the docstrings, these options are marked with a \textbackslash{}\textbackslash{}*, e.g. the fagus parameter is an option.\textbackslash{}n    Options can be specified at three levels with increasing precedence: at class\sphinxhyphen{}level (Fagus.fagus = True), at\textbackslash{}n    object\sphinxhyphen{}level (a = Fagus(), a.fagus = True) and in each function\sphinxhyphen{}call (a.get("b", fagus=True)). If you generally want\textbackslash{}n    to change an option, change it at class\sphinxhyphen{}level \sphinxhyphen{} all objects in that file will inherit this option. If you want to\textbackslash{}n    change the option specifically for one object, change the option at object\sphinxhyphen{}level. If you only want to change the\textbackslash{}n    option for one single run of a function, put it as a function\sphinxhyphen{}parameter. More thorough examples of options can be\textbackslash{}n    found in README.md.\textbackslash{}n    \textquotesingle{}, \textquotesingle{}\_\_init\_\_\textquotesingle{}: \textless{}function Fagus.\_\_init\_\_\textgreater{}, \textquotesingle{}get\textquotesingle{}: \textless{}function Fagus.get\textgreater{}, \textquotesingle{}iter\textquotesingle{}: \textless{}function Fagus.iter\textgreater{}, \textquotesingle{}filter\textquotesingle{}: \textless{}function Fagus.filter\textgreater{}, \textquotesingle{}split\textquotesingle{}: \textless{}function Fagus.split\textgreater{}, \textquotesingle{}\_split\_r\textquotesingle{}: \textless{}staticmethod(\textless{}function Fagus.\_split\_r\textgreater{})\textgreater{}, \textquotesingle{}set\textquotesingle{}: \textless{}function Fagus.set\textgreater{}, \textquotesingle{}append\textquotesingle{}: \textless{}function Fagus.append\textgreater{}, \textquotesingle{}extend\textquotesingle{}: \textless{}function Fagus.extend\textgreater{}, \textquotesingle{}insert\textquotesingle{}: \textless{}function Fagus.insert\textgreater{}, \textquotesingle{}add\textquotesingle{}: \textless{}function Fagus.add\textgreater{}, \textquotesingle{}update\textquotesingle{}: \textless{}function Fagus.update\textgreater{}, \textquotesingle{}\_build\_node\textquotesingle{}: \textless{}function Fagus.\_build\_node\textgreater{}, \textquotesingle{}\_put\_value\textquotesingle{}: \textless{}staticmethod(\textless{}function Fagus.\_put\_value\textgreater{})\textgreater{}, \textquotesingle{}setdefault\textquotesingle{}: \textless{}function Fagus.setdefault\textgreater{}, \textquotesingle{}mod\textquotesingle{}: \textless{}function Fagus.mod\textgreater{}, \textquotesingle{}mod\_all\textquotesingle{}: \textless{}function Fagus.mod\_all\textgreater{}, \textquotesingle{}serialize\textquotesingle{}: \textless{}function Fagus.serialize\textgreater{}, \textquotesingle{}\_serialize\_r\textquotesingle{}: \textless{}staticmethod(\textless{}function Fagus.\_serialize\_r\textgreater{})\textgreater{}, \textquotesingle{}\_serializable\_value\textquotesingle{}: \textless{}staticmethod(\textless{}function Fagus.\_serializable\_value\textgreater{})\textgreater{}, \textquotesingle{}merge\textquotesingle{}: \textless{}function Fagus.merge\textgreater{}, \textquotesingle{}pop\textquotesingle{}: \textless{}function Fagus.pop\textgreater{}, \textquotesingle{}popitem\textquotesingle{}: \textless{}function Fagus.popitem\textgreater{}, \textquotesingle{}discard\textquotesingle{}: \textless{}function Fagus.discard\textgreater{}, \textquotesingle{}remove\textquotesingle{}: \textless{}function Fagus.remove\textgreater{}, \textquotesingle{}keys\textquotesingle{}: \textless{}function Fagus.keys\textgreater{}, \textquotesingle{}values\textquotesingle{}: \textless{}function Fagus.values\textgreater{}, \textquotesingle{}items\textquotesingle{}: \textless{}function Fagus.items\textgreater{}, \textquotesingle{}clear\textquotesingle{}: \textless{}function Fagus.clear\textgreater{}, \textquotesingle{}contains\textquotesingle{}: \textless{}function Fagus.contains\textgreater{}, \textquotesingle{}count\textquotesingle{}: \textless{}function Fagus.count\textgreater{}, \textquotesingle{}index\textquotesingle{}: \textless{}function Fagus.index\textgreater{}, \textquotesingle{}isdisjoint\textquotesingle{}: \textless{}function Fagus.isdisjoint\textgreater{}, \textquotesingle{}child\textquotesingle{}: \textless{}function Fagus.child\textgreater{}, \textquotesingle{}reversed\textquotesingle{}: \textless{}function Fagus.reversed\textgreater{}, \textquotesingle{}reverse\textquotesingle{}: \textless{}function Fagus.reverse\textgreater{}, \textquotesingle{}copy\textquotesingle{}: \textless{}function Fagus.copy\textgreater{}, \textquotesingle{}options\textquotesingle{}: \textless{}function Fagus.options\textgreater{}, \textquotesingle{}\_opt\textquotesingle{}: \textless{}function Fagus.\_opt\textgreater{}, \textquotesingle{}\_ensure\_mutable\_node\textquotesingle{}: \textless{}staticmethod(\textless{}function Fagus.\_ensure\_mutable\_node\textgreater{})\textgreater{}, \textquotesingle{}\_get\_mutable\_node\textquotesingle{}: \textless{}function Fagus.\_get\_mutable\_node\textgreater{}, \textquotesingle{}\_mutable\_node\_type\textquotesingle{}: \textless{}staticmethod(\textless{}function Fagus.\_mutable\_node\_type\textgreater{})\textgreater{}, \textquotesingle{}\_node\_type\textquotesingle{}: \textless{}staticmethod(\textless{}function Fagus.\_node\_type\textgreater{})\textgreater{}, \textquotesingle{}\_hash\textquotesingle{}: \textless{}function Fagus.\_hash\textgreater{}, \textquotesingle{}\_\_copy\_\_\textquotesingle{}: \textless{}function Fagus.\_\_copy\_\_\textgreater{}, \textquotesingle{}\_\_call\_\_\textquotesingle{}: \textless{}function Fagus.\_\_call\_\_\textgreater{}, \textquotesingle{}\_\_getattr\_\_\textquotesingle{}: \textless{}function Fagus.\_\_getattr\_\_\textgreater{}, \textquotesingle{}\_\_getitem\_\_\textquotesingle{}: \textless{}function Fagus.\_\_getitem\_\_\textgreater{}, \textquotesingle{}\_\_setattr\_\_\textquotesingle{}: \textless{}function Fagus.\_\_setattr\_\_\textgreater{}, \textquotesingle{}\_\_setitem\_\_\textquotesingle{}: \textless{}function Fagus.\_\_setitem\_\_\textgreater{}, \textquotesingle{}\_\_delattr\_\_\textquotesingle{}: \textless{}function Fagus.\_\_delattr\_\_\textgreater{}, \textquotesingle{}\_\_delitem\_\_\textquotesingle{}: \textless{}function Fagus.\_\_delitem\_\_\textgreater{}, \textquotesingle{}\_\_iter\_\_\textquotesingle{}: \textless{}function Fagus.\_\_iter\_\_\textgreater{}, \textquotesingle{}\_\_hash\_\_\textquotesingle{}: \textless{}function Fagus.\_\_hash\_\_\textgreater{}, \textquotesingle{}\_\_eq\_\_\textquotesingle{}: \textless{}function Fagus.\_\_eq\_\_\textgreater{}, \textquotesingle{}\_\_ne\_\_\textquotesingle{}: \textless{}function Fagus.\_\_ne\_\_\textgreater{}, \textquotesingle{}\_\_lt\_\_\textquotesingle{}: \textless{}function Fagus.\_\_lt\_\_\textgreater{}, \textquotesingle{}\_\_le\_\_\textquotesingle{}: \textless{}function Fagus.\_\_le\_\_\textgreater{}, \textquotesingle{}\_\_gt\_\_\textquotesingle{}: \textless{}function Fagus.\_\_gt\_\_\textgreater{}, \textquotesingle{}\_\_ge\_\_\textquotesingle{}: \textless{}function Fagus.\_\_ge\_\_\textgreater{}, \textquotesingle{}\_\_contains\_\_\textquotesingle{}: \textless{}function Fagus.\_\_contains\_\_\textgreater{}, \textquotesingle{}\_\_len\_\_\textquotesingle{}: \textless{}function Fagus.\_\_len\_\_\textgreater{}, \textquotesingle{}\_\_bool\_\_\textquotesingle{}: \textless{}function Fagus.\_\_bool\_\_\textgreater{}, \textquotesingle{}\_\_repr\_\_\textquotesingle{}: \textless{}function Fagus.\_\_repr\_\_\textgreater{}, \textquotesingle{}\_\_str\_\_\textquotesingle{}: \textless{}function Fagus.\_\_str\_\_\textgreater{}, \textquotesingle{}\_\_iadd\_\_\textquotesingle{}: \textless{}function Fagus.\_\_iadd\_\_\textgreater{}, \textquotesingle{}\_\_add\_\_\textquotesingle{}: \textless{}function Fagus.\_\_add\_\_\textgreater{}, \textquotesingle{}\_\_radd\_\_\textquotesingle{}: \textless{}function Fagus.\_\_radd\_\_\textgreater{}, \textquotesingle{}\_\_isub\_\_\textquotesingle{}: \textless{}function Fagus.\_\_isub\_\_\textgreater{}, \textquotesingle{}\_\_sub\_\_\textquotesingle{}: \textless{}function Fagus.\_\_sub\_\_\textgreater{}, \textquotesingle{}\_\_rsub\_\_\textquotesingle{}: \textless{}function Fagus.\_\_rsub\_\_\textgreater{}, \textquotesingle{}\_\_imul\_\_\textquotesingle{}: \textless{}function Fagus.\_\_imul\_\_\textgreater{}, \textquotesingle{}\_\_mul\_\_\textquotesingle{}: \textless{}function Fagus.\_\_mul\_\_\textgreater{}, \textquotesingle{}\_\_rmul\_\_\textquotesingle{}: \textless{}function Fagus.\_\_rmul\_\_\textgreater{}, \textquotesingle{}\_\_reversed\_\_\textquotesingle{}: \textless{}function Fagus.\_\_reversed\_\_\textgreater{}, \textquotesingle{}\_\_reduce\_\_\textquotesingle{}: \textless{}function Fagus.\_\_reduce\_\_\textgreater{}, \textquotesingle{}\_\_reduce\_ex\_\_\textquotesingle{}: \textless{}function Fagus.\_\_reduce\_ex\_\_\textgreater{}, \textquotesingle{}\_\_dict\_\_\textquotesingle{}: \textless{}attribute \textquotesingle{}\_\_dict\_\_\textquotesingle{} of \textquotesingle{}Fagus\textquotesingle{} objects\textgreater{}, \textquotesingle{}\_\_weakref\_\_\textquotesingle{}: \textless{}attribute \textquotesingle{}\_\_weakref\_\_\textquotesingle{} of \textquotesingle{}Fagus\textquotesingle{} objects\textgreater{}, \textquotesingle{}\_\_abstractmethods\_\_\textquotesingle{}: frozenset(), \textquotesingle{}\_abc\_impl\textquotesingle{}: \textless{}\_abc.\_abc\_data object\textgreater{}, \textquotesingle{}\_\_annotations\_\_\textquotesingle{}: \{\textquotesingle{}root\textquotesingle{}: \textquotesingle{}Collection{[}Any{]}\textquotesingle{}, \textquotesingle{}\_options\textquotesingle{}: \textquotesingle{}Optional{[}Dict{[}str, Any{]}{]}\textquotesingle{}\}\})}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_module\_\_ (fagus.Fagus attribute)@\spxentry{\_\_module\_\_}\spxextra{fagus.Fagus attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.__module__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_module\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }\textquotesingle{}fagus.fagus\textquotesingle{}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_reversed\_\_() (fagus.Fagus method)@\spxentry{\_\_reversed\_\_()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.__reversed__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_reversed\_\_}}}{}{{ $\rightarrow$ Iterator\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_weakref\_\_ (fagus.Fagus attribute)@\spxentry{\_\_weakref\_\_}\spxextra{fagus.Fagus attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.__weakref__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_weakref\_\_}}}
\pysigstopsignatures
\sphinxAtStartPar
list of weak references to the object (if defined)

\end{fulllineitems}

\index{\_\_default\_options\_\_ (fagus.Fagus attribute)@\spxentry{\_\_default\_options\_\_}\spxextra{fagus.Fagus attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.__default_options__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_default\_options\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }\{\textquotesingle{}default\textquotesingle{}: \textless{}fagus.utils.FagusOption object\textgreater{}, \textquotesingle{}default\_node\_type\textquotesingle{}: \textless{}fagus.utils.FagusOption object\textgreater{}, \textquotesingle{}fagus\textquotesingle{}: \textless{}fagus.utils.FagusOption object\textgreater{}, \textquotesingle{}if\_\textquotesingle{}: \textless{}fagus.utils.FagusOption object\textgreater{}, \textquotesingle{}iter\_fill\textquotesingle{}: \textless{}fagus.utils.FagusOption object\textgreater{}, \textquotesingle{}iter\_nodes\textquotesingle{}: \textless{}fagus.utils.FagusOption object\textgreater{}, \textquotesingle{}list\_insert\textquotesingle{}: \textless{}fagus.utils.FagusOption object\textgreater{}, \textquotesingle{}node\_types\textquotesingle{}: \textless{}fagus.utils.FagusOption object\textgreater{}, \textquotesingle{}path\_split\textquotesingle{}: \textless{}fagus.utils.FagusOption object\textgreater{}\}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{no\_node (fagus.Fagus attribute)@\spxentry{no\_node}\spxextra{fagus.Fagus attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.no_node}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{no\_node}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }(\textless{}class \textquotesingle{}str\textquotesingle{}\textgreater{}, \textless{}class \textquotesingle{}bytes\textquotesingle{}\textgreater{}, \textless{}class \textquotesingle{}bytearray\textquotesingle{}\textgreater{})}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_reduce\_\_() (fagus.Fagus method)@\spxentry{\_\_reduce\_\_()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.__reduce__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_reduce\_\_}}}{}{{ $\rightarrow$ Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }Tuple\DUrole{p}{{[}}Any\DUrole{p}{,}\DUrole{w}{  }\DUrole{p}{...}\DUrole{p}{{]}}\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Helper for pickle.

\end{fulllineitems}

\index{\_\_reduce\_ex\_\_() (fagus.Fagus method)@\spxentry{\_\_reduce\_ex\_\_()}\spxextra{fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fagus.__reduce_ex__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_reduce\_ex\_\_}}}{\emph{\DUrole{n}{protocol}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}}{{ $\rightarrow$ Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }Tuple\DUrole{p}{{[}}Any\DUrole{p}{,}\DUrole{w}{  }\DUrole{p}{...}\DUrole{p}{{]}}\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Helper for pickle.

\end{fulllineitems}


\end{fulllineitems}

\index{Fil (class in fagus)@\spxentry{Fil}\spxextra{class in fagus}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fil}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{fagus.}}\sphinxbfcode{\sphinxupquote{Fil}}}{\emph{\DUrole{o}{*}\DUrole{n}{filter\_args}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}, \emph{\DUrole{n}{inexclude}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{str\_as\_re}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{fagus.filters:fagus.filters.KFil}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fagus.filters.KFil}}}}}

\sphinxAtStartPar
TFilter \sphinxhyphen{} what matches this filter will actually be visible in the result. See README
\index{\_\_module\_\_ (fagus.Fil attribute)@\spxentry{\_\_module\_\_}\spxextra{fagus.Fil attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.Fil.__module__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_module\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }\textquotesingle{}fagus.filters\textquotesingle{}}}}
\pysigstopsignatures
\end{fulllineitems}


\end{fulllineitems}

\index{CFil (class in fagus)@\spxentry{CFil}\spxextra{class in fagus}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.CFil}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{fagus.}}\sphinxbfcode{\sphinxupquote{CFil}}}{\emph{\DUrole{o}{*}\DUrole{n}{filter\_args}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}, \emph{\DUrole{n}{inexclude}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{str\_as\_re}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{invert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{fagus.filters:fagus.filters.KFil}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fagus.filters.KFil}}}}}

\sphinxAtStartPar
CFil \sphinxhyphen{} can be used to select nodes based on values that shall not appear in the result. See README
\index{\_\_init\_\_() (fagus.CFil method)@\spxentry{\_\_init\_\_()}\spxextra{fagus.CFil method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.CFil.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{o}{*}\DUrole{n}{filter\_args}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}, \emph{\DUrole{n}{inexclude}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{str\_as\_re}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{invert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Initializes KeyFilter and verifies the arguments passed to it
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{*filter\_args}} \textendash{} Each argument filters one key in the tree, the last argument filters the leaf\sphinxhyphen{}value. You can
put a list of values to match different values in the same filter. In this list, you can also specify
subfilters to match different grains differently.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{inexclude}} \textendash{} In some cases it’s easier to specify that a filter shall match everything except b, rather than
match a. \textasciitilde{} can be used to specify for each argument if the filter shall include it (+) or exclude it
(\sphinxhyphen{}). Valid example: “++\sphinxhyphen{}+”. If this parameter isn’t specified, all args will be treated as (+).

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{str\_as\_re}} \textendash{} If this is set to True, it will be evaluated for all str’s if they’d match differently as a
regex, and in the latter case match these strings as regex patterns. E.g. re.match(“a.*”, b) will match
differently than “a.*” == b. In this case, “a.*” will be used as a regex\sphinxhyphen{}pattern. However
re.match(“abc”, b) will give the same result as “abc” == b, so here “abc” == b will be used.

\end{itemize}

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if the filters are not stacked correctly, or stacked in a way that doesn’t make sense

\end{description}\end{quote}

\end{fulllineitems}

\index{match\_node() (fagus.CFil method)@\spxentry{match\_node()}\spxextra{fagus.CFil method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.CFil.match_node}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{match\_node}}}{\emph{\DUrole{n}{node}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}, \emph{\DUrole{n}{index}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{0}}}{{ $\rightarrow$ bool}}
\pysigstopsignatures
\sphinxAtStartPar
Recursive function to completely verify a node and its subnodes in CFil
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node}} \textendash{} node to check

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{index}} \textendash{} index in filter to check (filter is self)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
bool whether the filter matched

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_annotations\_\_ (fagus.CFil attribute)@\spxentry{\_\_annotations\_\_}\spxextra{fagus.CFil attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.CFil.__annotations__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_annotations\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }\{\}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_module\_\_ (fagus.CFil attribute)@\spxentry{\_\_module\_\_}\spxextra{fagus.CFil attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.CFil.__module__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_module\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }\textquotesingle{}fagus.filters\textquotesingle{}}}}
\pysigstopsignatures
\end{fulllineitems}


\end{fulllineitems}

\index{VFil (class in fagus)@\spxentry{VFil}\spxextra{class in fagus}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.VFil}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{fagus.}}\sphinxbfcode{\sphinxupquote{VFil}}}{\emph{\DUrole{o}{*}\DUrole{n}{filter\_args}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}, \emph{\DUrole{n}{inexclude}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{invert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{fagus.filters:fagus.filters.FilBase}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fagus.filters.FilBase}}}}}

\sphinxAtStartPar
ValueFilter \sphinxhyphen{} This special type of filter can be used to inspect the entire node

\sphinxAtStartPar
It can be used to e.g. select all the nodes that contain at least 10 elements. See README for an example
\index{\_\_init\_\_() (fagus.VFil method)@\spxentry{\_\_init\_\_()}\spxextra{fagus.VFil method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.VFil.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{o}{*}\DUrole{n}{filter\_args}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}, \emph{\DUrole{n}{inexclude}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{invert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ None}}
\pysigstopsignatures\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{*filter\_args}} \textendash{} Each argument filters one key in the tree, the last argument filters the leaf\sphinxhyphen{}value. You can
put a list of values to match different values in the same filter. In this list, you can also specify
subfilters to match different grains differently.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{inexclude}} \textendash{} In some cases it’s easier to specify that a filter shall match everything except b, rather than
match a. \textasciitilde{} can be used to specify for each argument if the filter shall include it (+) or exclude it
(\sphinxhyphen{}). Valid example: “++\sphinxhyphen{}+”. If this parameter isn’t specified, all args will be treated as (+).

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{invert}} \textendash{} Invert this whole filter to match if it doesn’t match. E.g. if you want to select all the nodes
that don’t have a certain property.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{match\_node() (fagus.VFil method)@\spxentry{match\_node()}\spxextra{fagus.VFil method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.VFil.match_node}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{match\_node}}}{\emph{\DUrole{n}{node}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}, \emph{\DUrole{n}{\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{None}}}{{ $\rightarrow$ bool}}
\pysigstopsignatures
\sphinxAtStartPar
Verify that a node matches ValueFilter
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node}} \textendash{} node to check

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{\_}} \textendash{} this argument is ignored

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
bool whether the filter matched

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_annotations\_\_ (fagus.VFil attribute)@\spxentry{\_\_annotations\_\_}\spxextra{fagus.VFil attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.VFil.__annotations__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_annotations\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }\{\}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_module\_\_ (fagus.VFil attribute)@\spxentry{\_\_module\_\_}\spxextra{fagus.VFil attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus:fagus.VFil.__module__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_module\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }\textquotesingle{}fagus.filters\textquotesingle{}}}}
\pysigstopsignatures
\end{fulllineitems}


\end{fulllineitems}



\section{Submodules}
\label{\detokenize{fagus:submodules}}
\sphinxstepscope


\subsection{fagus.fagus module}
\label{\detokenize{fagus.fagus:module-fagus.fagus}}\label{\detokenize{fagus.fagus:fagus-fagus-module}}\label{\detokenize{fagus.fagus::doc}}\index{module@\spxentry{module}!fagus.fagus@\spxentry{fagus.fagus}}\index{fagus.fagus@\spxentry{fagus.fagus}!module@\spxentry{module}}
\sphinxAtStartPar
Base\sphinxhyphen{}module that contains the {\hyperref[\detokenize{fagus:fagus.Fagus}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fagus}}}}}\sphinxhyphen{}class
\index{Fagus (class in fagus.fagus)@\spxentry{Fagus}\spxextra{class in fagus.fagus}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{fagus.fagus.}}\sphinxbfcode{\sphinxupquote{Fagus}}}{\emph{\DUrole{n}{root}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Optional\DUrole{p}{{[}}Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{None}}, \emph{\DUrole{n}{node\_types}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{list\_insert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}int\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{default\_node\_type}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{default}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{if\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{iter\_fill}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{mod\_functions}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}Mapping\DUrole{p}{{[}}Union\DUrole{p}{{[}}type\DUrole{p}{,}\DUrole{w}{  }Tuple\DUrole{p}{{[}}type\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }str\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }Callable\DUrole{p}{{[}}\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }Any\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{collections.abc.MutableMapping}}, \sphinxcode{\sphinxupquote{collections.abc.MutableSequence}}, \sphinxcode{\sphinxupquote{collections.abc.MutableSet}}

\sphinxAtStartPar
Fagus is a wrapper\sphinxhyphen{}class for complex, nested objects of dicts and lists in Python

\sphinxAtStartPar
Fagus can be used as an object by instantiating it, but it’s also possible to use all methods statically without
even an object, so that a = \{\}; Fagus.set(a, “top med”, 1) and a = Fagus(\{\}); a.set(1, “top med”) do the same.

\sphinxAtStartPar
The root node is always modified directly. If you don’t want to change the root node, all the functions where it
makes sense support to rather modify a copy, and return that modified copy using the copy\sphinxhyphen{}parameter.

\sphinxAtStartPar
\sphinxstylestrong{FagusOptions}:
Several parameters used in functions in Fagus work as options so that you don’t have to specify them each time you
run a function. In the docstrings, these options are marked with a *, e.g. the fagus parameter is an option.
Options can be specified at three levels with increasing precedence: at class\sphinxhyphen{}level (Fagus.fagus = True), at
object\sphinxhyphen{}level (a = Fagus(), a.fagus = True) and in each function\sphinxhyphen{}call (a.get(“b”, fagus=True)). If you generally want
to change an option, change it at class\sphinxhyphen{}level \sphinxhyphen{} all objects in that file will inherit this option. If you want to
change the option specifically for one object, change the option at object\sphinxhyphen{}level. If you only want to change the
option for one single run of a function, put it as a function\sphinxhyphen{}parameter. More thorough examples of options can be
found in README.md.
\index{\_\_init\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_init\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{n}{root}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Optional\DUrole{p}{{[}}Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{None}}, \emph{\DUrole{n}{node\_types}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{list\_insert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}int\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{default\_node\_type}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{default}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{if\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{iter\_fill}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{mod\_functions}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}Mapping\DUrole{p}{{[}}Union\DUrole{p}{{[}}type\DUrole{p}{,}\DUrole{w}{  }Tuple\DUrole{p}{{[}}type\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }str\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }Callable\DUrole{p}{{[}}\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }Any\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Constructor for Fagus, a wrapper\sphinxhyphen{}class for complex, nested objects of dicts and lists in Python

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{root}} \textendash{} object (like dict / list) to wrap Fagus around. If this is None, an empty node of the type
default\_node\_type will be used. Default None

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_types}} \textendash{} * Can be used to manually define if the nodes along path are supposed to be (l)ists or
(d)icts. E.g. “dll” to create a dict at level 1, and lists at level 2 and 3. ” ” can also be used \sphinxhyphen{}
space doesn’t enforce a node\sphinxhyphen{}type like d or l. For ” “, existing nodes are traversed if possible,
otherwise default\_node\_type is used to create new nodes. Default “”, interpreted as ” ” at each level.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{list\_insert}} \textendash{} * Level at which a new node shall be inserted into the list instead of traversing the
existing node in the list at that index. See README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a string, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * this option is used to determine whether nodes in the returned object should be returned as
Fagus\sphinxhyphen{}objects. This can be useful e.g. if you want to use Fagus in an iteration. Check the particular
function you want to use for a more thorough explanation of what this does in each case

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default\_node\_type}} \textendash{} * determines if new nodes by default should be created as (d)ict or (l)ist. Must be
either “d” or “l”, default “d”

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default}} \textendash{} * \textasciitilde{} is used in get and other functions if a path doesn’t exist

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{if\_}} \textendash{} * only set value if it meets the condition specified here, otherwise do nothing. The condition can be
a lambda, any value or a tuple of accepted values. Default \_None (don’t check value)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{iter\_fill}} \textendash{} * Fill up tuples with iter\_fill (can be any object, e.g. None) to ensure that all the tuples
iter() returns are exactly max\_items long. See iter()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mod\_functions}} \textendash{} * \textasciitilde{} is used to define how different types of objects are supposed to be serialized. This is
defined in a dict. The keys are either a type (like IPAddress) or a tuple of different types
(IPv4Address, IPv6Address). The values are function pointers, or lambdas, which are supposed to convert
e.g. an IPv4Address into a string. Check out TFunc if you want to call more complicated functions with
several arguments. See README for examples

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} \textasciitilde{} creates a copy of the root node before Fagus is initialized. Makes sure that changes on this Fagus
won’t modify the root node that was passed here itself. Default False

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{root (fagus.fagus.Fagus attribute)@\spxentry{root}\spxextra{fagus.fagus.Fagus attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.root}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{root}}\sphinxbfcode{\sphinxupquote{\DUrole{p}{:}\DUrole{w}{  }Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{get() (fagus.fagus.Fagus method)@\spxentry{get()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.get}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{default}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ Any}}
\pysigstopsignatures
\sphinxAtStartPar
Retrieves value at path. If the value doesn’t exist, default is returned.

\sphinxAtStartPar
To get “hello” from x = Fagus(\{“a”: {[}“b”, \{“c”: “d”\}{]}, e: {[}“f”, “g”{]}\}), you can use x{[}(“a”, 1, “c”){]}. The tuple
(“a”, 1, “c”) is the path\sphinxhyphen{}parameter that is used to traverse x. At first, the list at “a” is picked in the
top\sphinxhyphen{}most dict, and then the 2nd element \{“c”: “d”\} is picked from that list. Then, “d” is picked from \{“c”: “d”\}
and returned. The path\sphinxhyphen{}parameter can be a tuple or list, the keys must be either integers for lists, or any
hashable objects for dicts. For convenience, the keys can also be put in a single string separated by
path\_split (default ” “), so a{[}“a 1 c”{]} also returns “d”.

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} List/Tuple of key\sphinxhyphen{}values to recursively traverse self. Can also be specified as string, that is split
into a tuple using path\_split

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default}} \textendash{} * returned if path doesn’t exist in self

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * returns a Fagus\sphinxhyphen{}object if the value at path is a list or dict

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} Option to return a copy of the returned value. The default behaviour is that if there are subnodes
(dicts, lists) in the returned values, and you make changes to these nodes, these changes will also be
applied in the root node from which values() was called. If you want the returned values to be
independent, use copy to get a shallow copy of the returned value

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the value if the path exists, or default if it doesn’t exist

\end{description}\end{quote}

\end{fulllineitems}

\index{iter() (fagus.fagus.Fagus method)@\spxentry{iter()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.iter}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{iter}}}{\emph{\DUrole{n}{max\_depth}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{9223372036854775807}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{filter\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Optional\DUrole{p}{{[}}{\hyperref[\detokenize{fagus.filters:fagus.filters.Fil}]{\sphinxcrossref{fagus.filters.Fil}}}\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{None}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{iter\_fill}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{select}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Optional\DUrole{p}{{[}}Union\DUrole{p}{{[}}int\DUrole{p}{,}\DUrole{w}{  }Iterable\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{None}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{iter\_nodes}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{filter\_ends}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ {\hyperref[\detokenize{fagus.iterators:fagus.iterators.FagusIterator}]{\sphinxcrossref{fagus.iterators.FagusIterator}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Recursively iterate through Fagus\sphinxhyphen{}object, starting at path

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max\_depth}} \textendash{} Can be used to limit how deep the iteration goes. Example: a = \{“a”: {[}“b”, {[}“c”, “d”{]}{]}, “e”: “f”\}
If max\_depth is sys.max\_size, all the nodes are traversed: {[}(“a”, “b”, “c”), (“a”, “b”, “d”{]}),
(“e”, “f”){]}. If max\_depth is 1, iter returns {[}(“a”, “b”, {[}“c”, “d”{]}), (“e”, “f”){]}, so {[}“c”, “d”{]} is not
iterated through but returned as a node. If max\_depth is 0, iter returns {[}(“a”, {[}“b”, {[}“c”, “d”{]}{]}),
(“e”, “f”){]}, effectively the same as dict.items(). Default sys.maxitems (iterate as deeply as possible)
A negative number (e.g. \sphinxhyphen{}1) is treated as sys.maxitems.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} Start iterating at path. Internally calls get(path), and iterates on the node get returns. See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{filter\_}} \textendash{} Only iterate over specific nodes defined using Fil (see README.md and Fil for more info)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * If the leaf in the tuple is a dict or list, return it as a Fagus\sphinxhyphen{}object. This option has no
effect if max\_items is sys.maxitems.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{iter\_fill}} \textendash{} * Fill up tuples with iter\_fill (can be any object, e.g. None) to ensure that all the tuples
iter() returns are exactly max\_items long. This can be useful if you want to unpack the keys / leaves
from the tuples in a loop, which fails if the count of items in the tuples varies. This option has no
effect if max\_items is \sphinxhyphen{}1. The default value is …, meaning that the tuples are not filled, and the
length of the tuples can vary. See README.md for a more thorough example.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{select}} \textendash{} Extract only some specified values from the tuples. E.g. if \textasciitilde{} is \sphinxhyphen{}1, only the leaf\sphinxhyphen{}values are
returned. \textasciitilde{} can also be a list of indices. Default None (don’t reduce the tuples)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} Iterate on a shallow\sphinxhyphen{}copy to make sure that you can edit root node without disturbing the iteration

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{iter\_nodes}} \textendash{} * includes the traversed nodes into the resulting tuples, order is then:
node1, key1, node2, key2, …, leaf\_value

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{filter\_ends}} \textendash{} Affects the end dict/list that is returned if max\_items is used. Normally, filters are not
applied on that end node. If you would like to get the end node filtered too, set this to True. If this
is set to True, the last nodes will always be copies (if unfiltered they are references)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
FagusIterator with one tuple for each leaf\sphinxhyphen{}node, containing the keys of the parent\sphinxhyphen{}nodes until the leaf

\end{description}\end{quote}

\end{fulllineitems}

\index{filter() (fagus.fagus.Fagus method)@\spxentry{filter()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.filter}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{filter}}}{\emph{\DUrole{n}{filter\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{{\hyperref[\detokenize{fagus.filters:fagus.filters.Fil}]{\sphinxcrossref{fagus.filters.Fil}}}}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{default}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Filters self, only keeping the nodes that pass the filter

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{filter\_}} \textendash{} Fil\sphinxhyphen{}object in which the filtering\sphinxhyphen{}criteria are specified

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} at this point in self, the filtering will start (apply filter\_ relatively from this point).
Default “”, meaning that the root node is filtered, see get() and README for examples

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * return the filtered self as Fagus\sphinxhyphen{}object (default is just to return the filtered node)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} Create a copy and filter on that copy. Default is to modify the self directly

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default}} \textendash{} * returned if path doesn’t exist in self, or the value at path can’t be filtered

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the filtered object, starting at path

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if the root node needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{description}\end{quote}

\end{fulllineitems}

\index{split() (fagus.fagus.Fagus method)@\spxentry{split()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.split}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{split}}}{\emph{\DUrole{n}{filter\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Optional\DUrole{p}{{[}}{\hyperref[\detokenize{fagus.filters:fagus.filters.Fil}]{\sphinxcrossref{fagus.filters.Fil}}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{default}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ Union\DUrole{p}{{[}}Tuple\DUrole{p}{{[}}Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }Tuple\DUrole{p}{{[}}Any\DUrole{p}{,}\DUrole{w}{  }Any\DUrole{p}{{]}}\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Splits self into nodes that pass the filter, and nodes that don’t pass the filter

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{filter\_}} \textendash{} Fil\sphinxhyphen{}object in which the filtering\sphinxhyphen{}criteria are specified

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} at this position in self, the splitting will start (apply filter\_ relatively from this point).
Default “”, meaning that the root node is split, see get() and README for examples

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * return the filtered self as Fagus\sphinxhyphen{}object (default is just to return the filtered node)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} Create a copy and filter on that copy. Default is to modify the object directly

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default}} \textendash{} * returned if path doesn’t exist in self, or the

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a tuple, where the first element is the nodes that pass the filter, and the second element is the nodes that
don’t pass the filter

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if the root node needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{description}\end{quote}

\end{fulllineitems}

\index{set() (fagus.fagus.Fagus method)@\spxentry{set()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.set}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set}}}{\emph{\DUrole{n}{value}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Iterable\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}, \emph{\DUrole{n}{node\_types}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{list\_insert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}int\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{if\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{default\_node\_type}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Create (if they don’t already exist) all sub\sphinxhyphen{}nodes in path, and finally set value at leaf\sphinxhyphen{}node

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value}} \textendash{} \textasciitilde{} is placed at path, after creating new nodes if necessary. An existing value at path is overwritten

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} List/Tuple of key\sphinxhyphen{}values that are traversed in self. If no nodes exist at the keys, new nodes are
created. Can also be specified as a string, that is split into a tuple using path\_split. See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_types}} \textendash{} * Can be used to manually define if the nodes along path are supposed to be (l)ists or
(d)icts. E.g. “dll” to create a dict at level 1, and lists at level 2 and 3. ” ” can also be used \sphinxhyphen{}
space doesn’t enforce a node\sphinxhyphen{}type like d or l. For ” “, existing nodes are traversed if possible,
otherwise default\_node\_type is used to create new nodes. Default “”, interpreted as ” ” at each level.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{list\_insert}} \textendash{} * Level at which a new node shall be inserted into the list instead of traversing the
existing node in the list at that index. See README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a string, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * return self as a Fagus\sphinxhyphen{}object if it is a node (tuple / list / dict), default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{if\_}} \textendash{} * only set value if it meets the condition specified here, otherwise do nothing. The condition can be
a lambda, any value or a tuple of accepted values. Default \_None (don’t check value)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default\_node\_type}} \textendash{} * determines if new nodes by default should be created as (d)ict or (l)ist. Must be
either “d” or “l”, default “d”

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} if this is set, a copy of self is modified and then returned (thus self is not modified)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
self as a node if fagus is set, or a modified copy of self if copy is set

\item[{Raises}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if it isn’t possible to parse an int\sphinxhyphen{}index from the provided key in a position where node\sphinxhyphen{}types
    defines that the node shall be a list (if node\sphinxhyphen{}types is not l, the node will be replaced with a dict)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if the root node needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{append() (fagus.fagus.Fagus method)@\spxentry{append()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.append}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{append}}}{\emph{\DUrole{n}{value}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{node\_types}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{list\_insert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}int\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{if\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{default\_node\_type}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Create (if they don’t already exist) all sub\sphinxhyphen{}nodes in path, and finally append value to a list at leaf\sphinxhyphen{}node

\sphinxAtStartPar
If the leaf\sphinxhyphen{}node is a set, tuple or other value it is converted to a list. Then the new value is appended.

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value}} \textendash{} \textasciitilde{} is appended to list at path, after creating new nodes along path as necessary

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} List/Tuple of key\sphinxhyphen{}values that are traversed in self. If no nodes exist at the keys, new nodes are
created. Can also be specified as a string, that is split into a tuple using path\_split. See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_types}} \textendash{} * Can be used to manually define if the nodes along path are supposed to be (l)ists or
(d)icts. E.g. “dll” to create a dict at level 1, and lists at level 2 and 3. ” ” can also be used \sphinxhyphen{}
space doesn’t enforce a node\sphinxhyphen{}type like d or l. For ” “, existing nodes are traversed if possible,
otherwise default\_node\_type is used to create new nodes. Default “”, interpreted as ” ” at each level.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{list\_insert}} \textendash{} * Level at which a new node shall be inserted into the list instead of traversing the
existing node in the list at that index. See README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a string, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * return self as a Fagus\sphinxhyphen{}object if it is a node (tuple / list / dict), default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{if\_}} \textendash{} * only append value if it meets the condition specified here, otherwise do nothing. The condition can
be a lambda, any value or a tuple of accepted values. Default \_None (don’t check value)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default\_node\_type}} \textendash{} * determines if new nodes by default should be created as (d)ict or (l)ist. Must be
either “d” or “l”, default “d”

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} if this is set, a copy of self is modified and then returned (thus self is not modified)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
self as a node if fagus is set, or a modified copy of self if copy is set

\item[{Raises}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if it isn’t possible to parse an int\sphinxhyphen{}index from the provided key in a position where node\sphinxhyphen{}types
    defines that the node shall be a list (if node\sphinxhyphen{}types is not l, the node will be replaced with a dict)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if path is empty and the root node is not a list (can’t append to a dict, tuple or set) or the
    root node needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{extend() (fagus.fagus.Fagus method)@\spxentry{extend()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.extend}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{extend}}}{\emph{\DUrole{n}{values}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Iterable\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{node\_types}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{list\_insert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}int\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{if\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{default\_node\_type}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Create (if they don’t already exist) all sub\sphinxhyphen{}nodes in path. Then extend list at leaf\sphinxhyphen{}node with the new values

\sphinxAtStartPar
If the leaf\sphinxhyphen{}node is a set, tuple or other value it is converted to a list, which is extended with the new values

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{values}} \textendash{} the list at path is extended with \textasciitilde{}, after creating new nodes along path as necessary

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} List/Tuple of key\sphinxhyphen{}values that are traversed in self. If no nodes exist at the keys, new nodes are
created. Can also be specified as a string, that is split into a tuple using path\_split. See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_types}} \textendash{} * Can be used to manually define if the nodes along path are supposed to be (l)ists or
(d)icts. E.g. “dll” to create a dict at level 1, and lists at level 2 and 3. ” ” can also be used \sphinxhyphen{}
space doesn’t enforce a node\sphinxhyphen{}type like d or l. For ” “, existing nodes are traversed if possible,
otherwise default\_node\_type is used to create new nodes. Default “”, interpreted as ” ” at each level.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{list\_insert}} \textendash{} * Level at which a new node shall be inserted into the list instead of traversing the
existing node in the list at that index. See README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a string, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * return self as a Fagus\sphinxhyphen{}object if it is a node (tuple / list / dict), default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{if\_}} \textendash{} * only extend with values if they meet the condition specified here, otherwise do nothing. The
condition can be a lambda, any value or a tuple of accepted values. Default \_None (don’t check values)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default\_node\_type}} \textendash{} * determines if new nodes by default should be created as (d)ict or (l)ist. Must be
either “d” or “l”, default “d”

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} if this is set, a copy of self is modified and then returned (thus self is not modified)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
self as a node if fagus is set, or a modified copy of self if copy is set

\item[{Raises}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if it isn’t possible to parse an int\sphinxhyphen{}index from the provided key in a position where node\sphinxhyphen{}types
    defines that the node shall be a list (if node\sphinxhyphen{}types is not l, the node will be replaced with a dict)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if path is empty and the root node is not a list (can’t extend a dict, tuple or set) or the
    root node needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{insert() (fagus.fagus.Fagus method)@\spxentry{insert()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.insert}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{insert}}}{\emph{\DUrole{n}{index}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{value}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{node\_types}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{list\_insert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}int\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{if\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{default\_node\_type}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Create (if they don’t already exist) all sub\sphinxhyphen{}nodes in path. Insert new value at index in list at leaf\sphinxhyphen{}node

\sphinxAtStartPar
If the leaf\sphinxhyphen{}node is a set, tuple or other value it is converted to a list, in which the new value is inserted at
index

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{index}} \textendash{} \textasciitilde{} at which the value shall be inserted in the list at path

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value}} \textendash{} \textasciitilde{} is inserted at index into list at path, after creating new nodes along path as necessary

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} List/Tuple of key\sphinxhyphen{}values that are traversed in self. If no nodes exist at the keys, new nodes are
created. Can also be specified as a string, that is split into a tuple using path\_split. See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_types}} \textendash{} * Can be used to manually define if the nodes along path are supposed to be (l)ists or
(d)icts. E.g. “dll” to create a dict at level 1, and lists at level 2 and 3. ” ” can also be used \sphinxhyphen{}
space doesn’t enforce a node\sphinxhyphen{}type like d or l. For ” “, existing nodes are traversed if possible,
otherwise default\_node\_type is used to create new nodes. Default “”, interpreted as ” ” at each level.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{list\_insert}} \textendash{} * Level at which a new node shall be inserted into the list instead of traversing the
existing node in the list at that index. See README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a string, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * return self as a Fagus\sphinxhyphen{}object if it is a node (tuple / list / dict), default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{if\_}} \textendash{} * only insert value if it meets the condition specified here, otherwise do nothing. The condition can
be a lambda, any value or a tuple of accepted values. Default \_None (don’t check value)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default\_node\_type}} \textendash{} * determines if new nodes by default should be created as (d)ict or (l)ist. Must be
either “d” or “l”, default “d”

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} if this is set, a copy of self is modified and then returned (thus self is not modified)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
self as a node if fagus is set, or a modified copy of self if copy is set

\item[{Raises}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if it isn’t possible to parse an int\sphinxhyphen{}index from the provided key in a position where node\sphinxhyphen{}types
    defines that the node shall be a list (if node\sphinxhyphen{}types is not l, the node will be replaced with a dict)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if path is empty and the root node is not a list (can’t insert into dict, tuple or set) or the
    root node needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{add() (fagus.fagus.Fagus method)@\spxentry{add()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.add}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add}}}{\emph{\DUrole{n}{value}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{node\_types}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{list\_insert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}int\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{if\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{default\_node\_type}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Create (if they don’t already exist) all sub\sphinxhyphen{}nodes in path, and finally add new value to set at leaf\sphinxhyphen{}node

\sphinxAtStartPar
If the leaf\sphinxhyphen{}node is a list, tuple or other value it is converted to a set, to which the new value is added

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value}} \textendash{} \textasciitilde{} is added to set at path, after creating new nodes along path as necessary

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} List/Tuple of key\sphinxhyphen{}values that are traversed in self. If no nodes exist at the keys, new nodes are
created. Can also be specified as a string, that is split into a tuple using path\_split. See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_types}} \textendash{} * Can be used to manually define if the nodes along path are supposed to be (l)ists or
(d)icts. E.g. “dll” to create a dict at level 1, and lists at level 2 and 3. ” ” can also be used \sphinxhyphen{}
space doesn’t enforce a node\sphinxhyphen{}type like d or l. For ” “, existing nodes are traversed if possible,
otherwise default\_node\_type is used to create new nodes. Default “”, interpreted as ” ” at each level.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{list\_insert}} \textendash{} * Level at which a new node shall be inserted into the list instead of traversing the
existing node in the list at that index. See README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a string, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * return self as a Fagus\sphinxhyphen{}object if it is a node (tuple / list / dict), default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{if\_}} \textendash{} * only add value if it meets the condition specified here, otherwise do nothing. The condition can be
a lambda, any value or a tuple of accepted values. Default \_None (don’t check value)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default\_node\_type}} \textendash{} * determines if new nodes by default should be created as (d)ict or (l)ist. Must be
either “d” or “l”, default “d”

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} if this is set, a copy of self is modified and then returned (thus self is not modified)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
self as a node if fagus is set, or a modified copy of self if copy is set

\item[{Raises}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if it isn’t possible to parse an int\sphinxhyphen{}index from the provided key in a position where node\sphinxhyphen{}types
    defines that the node shall be a list (if node\sphinxhyphen{}types is not l, the node will be replaced with a dict)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if path is empty and the root node is not a set (can’t add to list or dict) or the root node
    needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{update() (fagus.fagus.Fagus method)@\spxentry{update()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.update}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{update}}}{\emph{\DUrole{n}{values}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Iterable\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{node\_types}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{list\_insert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}int\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{if\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{default\_node\_type}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Create (if they don’t already exist) all sub\sphinxhyphen{}nodes in path, then update set at leaf\sphinxhyphen{}node with new values

\sphinxAtStartPar
If the leaf\sphinxhyphen{}node is a list, tuple or other value it is converted to a set. That set is then updated with the new
values. If the node at path is a dict, and values also is a dict, the node\sphinxhyphen{}dict is updated with the new values.

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{values}} \textendash{} the set/dict at path is updated with \textasciitilde{}, after creating new nodes along path as necessary

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} List/Tuple of key\sphinxhyphen{}values that are traversed in self. If no nodes exist at the keys, new nodes are
created. Can also be specified as a string, that is split into a tuple using path\_split. See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_types}} \textendash{} * Can be used to manually define if the nodes along path are supposed to be (l)ists or
(d)icts. E.g. “dll” to create a dict at level 1, and lists at level 2 and 3. ” ” can also be used \sphinxhyphen{}
space doesn’t enforce a node\sphinxhyphen{}type like d or l. For ” “, existing nodes are traversed if possible,
otherwise default\_node\_type is used to create new nodes. Default “”, interpreted as ” ” at each level.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{list\_insert}} \textendash{} * Level at which a new node shall be inserted into the list instead of traversing the
existing node in the list at that index. See README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a string, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * return self as a Fagus\sphinxhyphen{}object if it is a node (tuple / list / dict), default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{if\_}} \textendash{} * only update with values if they meet the condition specified here, otherwise do nothing. The
condition can be a lambda, any value or a tuple of accepted values. Default \_None (don’t check values)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default\_node\_type}} \textendash{} * determines if new nodes by default should be created as (d)ict or (l)ist. Must be
either “d” or “l”, default “d”

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} if this is set, a copy of self is modified and then returned (thus self is not modified)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
self as a node if fagus is set, or a modified copy of self if copy is set

\item[{Raises}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if it isn’t possible to parse an int\sphinxhyphen{}index from the provided key in a position where node\sphinxhyphen{}types
    defines that the node shall be a list (if node\sphinxhyphen{}types is not l, the node will be replaced with a dict)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if path is empty and the root node is not a set or dict (can’t update list) or the root node
    needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{setdefault() (fagus.fagus.Fagus method)@\spxentry{setdefault()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.setdefault}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setdefault}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{default}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{node\_types}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{list\_insert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}int\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{default\_node\_type}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ Any}}
\pysigstopsignatures
\sphinxAtStartPar
Get value at path and return it. If there is no value at path, set default at path, and return default

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} position in self where default shall be set / from where value shall be fetched. See get() and README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default}} \textendash{} * returned if path doesn’t exist in self

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * return self as a Fagus\sphinxhyphen{}object if it is a node (tuple / list / dict), default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_types}} \textendash{} * Can be used to manually define if the nodes along path are supposed to be (l)ists or
(d)icts. E.g. “dll” to create a dict at level 1, and lists at level 2 and 3. ” ” can also be used \sphinxhyphen{}
space doesn’t enforce a node\sphinxhyphen{}type like d or l. For ” “, existing nodes are traversed if possible,
otherwise default\_node\_type is used to create new nodes. Default “”, interpreted as ” ” at each level.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{list\_insert}} \textendash{} * Level at which a new node shall be inserted into the list instead of traversing the
existing node in the list at that index. See README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default\_node\_type}} \textendash{} * determines if new nodes by default should be created as (d)ict or (l)ist. Must be
either “d” or “l”, default “d”

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
value at path if it exists, otherwise default is set at path and returned

\item[{Raises}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if it isn’t possible to parse an int\sphinxhyphen{}index from the provided key in a position where node\sphinxhyphen{}types
    defines that the node shall be a list (if node\sphinxhyphen{}types is not l, the node will be replaced with a dict)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if the root node needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{mod() (fagus.fagus.Fagus method)@\spxentry{mod()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.mod}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mod}}}{\emph{\DUrole{n}{mod\_function}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Callable\DUrole{p}{{[}}\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }Any\DUrole{p}{{]}}}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Iterable\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}, \emph{\DUrole{n}{default}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{replace\_value}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{True}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{node\_types}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{list\_insert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}int\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{default\_node\_type}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ Any}}
\pysigstopsignatures
\sphinxAtStartPar
Modifies the value at path using the function\sphinxhyphen{}pointer mod\_function

\sphinxAtStartPar
mod can be used like this Fagus.mod(obj, “kitchen spoon”, lambda x: x + 1, 1) to count the number of spoons in
the kitchen. If there is no value to modify, the default value (here 1) will be set at the node.

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mod\_function}} \textendash{} A function pointer or lambda that modifies the existing value at path. TFunc can be used to
call more complex functions requiring several arguments.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} position in self at which the value shall be modified. Defined as a list/Tuple of key\sphinxhyphen{}values to
recursively traverse self. Can also be specified as string which is split into a tuple using path\_split

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default}} \textendash{} * this value is set in path if it doesn’t exist

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * Return new value as a Fagus\sphinxhyphen{}object if it is a node (tuple / list / dict), default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{replace\_value}} \textendash{} Replace the old value with what mod\_function returns. Can be deactivated e.g. if mod\_function
changes the object, but returns None (if \textasciitilde{} stays on, the object is replaced with None). Default True.
If no value exists at path, the default value is always set at path (independent of \textasciitilde{})

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_types}} \textendash{} * Can be used to manually define if the nodes along path are supposed to be (l)ists or
(d)icts. E.g. “dll” to create a dict at level 1, and lists at level 2 and 3. ” ” can also be used \sphinxhyphen{}
space doesn’t enforce a node\sphinxhyphen{}type like d or l. For ” “, existing nodes are traversed if possible,
otherwise default\_node\_type is used to create new nodes. Default “”, interpreted as ” ” at each level.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{list\_insert}} \textendash{} * Level at which a new node shall be inserted into the list instead of traversing the
existing node in the list at that index. See README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default\_node\_type}} \textendash{} * determines if new nodes by default should be created as (d)ict or (l)ist. Must be
either “d” or “l”, default “d”

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the new value that was returned by the mod\_function, or default if there was no value at path

\item[{Raises}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if it isn’t possible to parse an int\sphinxhyphen{}index from the provided key in a position where node\sphinxhyphen{}types
    defines that the node shall be a list (if node\sphinxhyphen{}types is not l, the node will be replaced with a dict)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if the root node needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{mod\_all() (fagus.fagus.Fagus method)@\spxentry{mod\_all()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.mod_all}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mod\_all}}}{\emph{\DUrole{n}{mod\_function}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Callable\DUrole{p}{{[}}\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }Any\DUrole{p}{{]}}}}, \emph{\DUrole{n}{filter\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Optional\DUrole{p}{{[}}{\hyperref[\detokenize{fagus.filters:fagus.filters.Fil}]{\sphinxcrossref{fagus.filters.Fil}}}\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{None}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{replace\_value}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{True}}, \emph{\DUrole{n}{default}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{max\_depth}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{9223372036854775807}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ Any}}
\pysigstopsignatures
\sphinxAtStartPar
Modify all the leaf\sphinxhyphen{}values that match a certain filter

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mod\_function}} \textendash{} A function pointer or lambda that modifies the existing value at path. TFunc can be used to
call more complex functions requiring several arguments.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{filter\_}} \textendash{} used to select which leaves shall be modified. Default None (all leaves are modified)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} position in self at which the value shall be modified. See get() / README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default}} \textendash{} * this value is returned if path doesn’t exist, or if no leaves match the filter

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * Return new value as a Fagus\sphinxhyphen{}object if it is a node (tuple / list / dict), default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{replace\_value}} \textendash{} Replace the old value with what mod\_function returns. Can be deactivated e.g. if mod\_function
changes the object, but returns None (if \textasciitilde{} stays on, the object is replaced with None). Default True.
If no value exists at path, the default value is always set at path (independent of \textasciitilde{})

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max\_depth}} \textendash{} Defines the maximum depth for the iteration. See Fagus.iter max\_depth for more information

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} Can be ued to make sure that the node at path is not modified (instead a modified copy is returned)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the node at path where all the leaves matching filter\_ are modified, or default if it didn’t exist

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if the root node needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{description}\end{quote}

\end{fulllineitems}

\index{serialize() (fagus.fagus.Fagus method)@\spxentry{serialize()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.serialize}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{serialize}}}{\emph{\DUrole{n}{mod\_functions}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Optional\DUrole{p}{{[}}Mapping\DUrole{p}{{[}}Union\DUrole{p}{{[}}type\DUrole{p}{,}\DUrole{w}{  }Tuple\DUrole{p}{{[}}type\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }str\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }Callable\DUrole{p}{{[}}\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }Any\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{None}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{node\_types}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{list\_insert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}int\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ Union\DUrole{p}{{[}}Dict\DUrole{p}{{[}}Any\DUrole{p}{,}\DUrole{w}{  }Any\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }List\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Makes sure the object can be serialized so that it can be converted to JSON, YAML etc.

\sphinxAtStartPar
The only allowed data\sphinxhyphen{}types for serialization are: dict, list, bool, float, int, str, None

\sphinxAtStartPar
Sets and tuples are converted into lists. Other objects whose types are not allowed in serialized objects are
modified to a type that is allowed using the mod\_functions\sphinxhyphen{}parameter. mod\_functions is a dict, with the type
of object like IPv4Address or a tuple of types like (IPv4Address, IPv6Address). The values are function pointers
or lambdas, that are executed to convert e.g. an IPv4Address to one of the allowed data types mentioned above.

\sphinxAtStartPar
The default mod\_functions are: \{datetime: lambda x: x.isoformat(), date: lambda x: x.isoformat(), time:
lambda x: x.isoformat(), “default”: lambda x: str(x)\}

\sphinxAtStartPar
By default, date, datetime and time\sphinxhyphen{}objects are replaced by their isoformat\sphinxhyphen{}string. All other objects whose
types don’t appear in mod\_functions are modified by the function behind the key “default”. By default, this
function is lambda x: str(x) that replaces the object with its string\sphinxhyphen{}representation.

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mod\_functions}} \textendash{} * \textasciitilde{} is used to define how different types of objects are supposed to be serialized. This is
defined in a dict. The keys are either a type (like IPAddress) or a tuple of different types
(IPv4Address, IPv6Address). The values are function pointers, or lambdas, which are supposed to convert
e.g. an IPv4Address into a string. Check out TFunc if you want to call more complicated functions with
several arguments. See README for examples

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} position in self at which the value shall be modified. See get() / README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_types}} \textendash{} * Can be used to manually define if the nodes along path are supposed to be (l)ists or
(d)icts. E.g. “dll” to create a dict at level 1, and lists at level 2 and 3. ” ” can also be used \sphinxhyphen{}
space doesn’t enforce a node\sphinxhyphen{}type like d or l. For ” “, existing nodes are traversed if possible,
otherwise default\_node\_type is used to create new nodes. Default “”, interpreted as ” ” at each level.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{list\_insert}} \textendash{} * Level at which a new node shall be inserted into the list instead of traversing the
existing node in the list at that index. See README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} Create a copy and make that copy serializable. Default is to modify self directly

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a serializable object that only contains types allowed in json or yaml

\item[{Raises}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if root node is not a dict or list (serialize can’t fix that for the root node)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if tuple\_keys is not defined in mod\_functions and a dict has tuples as keys

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Exception}} \textendash{} Can raise any exception if it occurs in one of the mod\_functions

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{merge() (fagus.fagus.Fagus method)@\spxentry{merge()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.merge}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{merge}}}{\emph{\DUrole{n}{obj}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}{\hyperref[\detokenize{fagus.iterators:fagus.iterators.FagusIterator}]{\sphinxcrossref{fagus.iterators.FagusIterator}}}\DUrole{p}{,}\DUrole{w}{  }Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{new\_value\_action}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}r\textquotesingle{}}}, \emph{\DUrole{n}{extend\_from}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{9223372036854775807}}, \emph{\DUrole{n}{update\_from}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{9223372036854775807}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{copy\_obj}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{node\_types}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{list\_insert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}int\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{default\_node\_type}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Merges two or more tree\sphinxhyphen{}objects to update and extend the root node
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{obj}} \textendash{} tree\sphinxhyphen{}object that shall be merged. Can also be a FagusIterator returned from iter() to only merge
values matching a filter defined in iter()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} position in root where the new objects shall be merged, default “”

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{new\_value\_action}} \textendash{} This parameter defines what merge is supposed to do if a value at a path is present in the
root and in one of the objects to merge. The possible values are: (r)eplace \sphinxhyphen{} the value in the root is
replaced with the new value, this is the default behaviour; (i)gnore \sphinxhyphen{} the value in the root is not
updated; (a)ppend \sphinxhyphen{} the old and new value are both put into a list, and thus aggregated

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{extend\_from}} \textendash{} By default, lists are traversed, so the value at index i will be compared in both lists. If
at some point you rather want to just append the contents from the objects to be merged, use this
parameter to define the level (count of keys) from which lists should be extended isf traversed. Default
infinite (never extend lists)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{update\_from}} \textendash{} Like extend\_from, but for dicts. Allows you to define at which level the contents of the root
should just be updated with the contents of the objects instead of traversing and comparing each value

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} whether the returned tree\sphinxhyphen{}object should be returned as Fagus

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} Don’t modify the root node, modify and return a copy instead

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy\_obj}} \textendash{} The objects to be merged are not modified, but references to subnodes of the objects can be
put into the root node. Set this to True to prevent that and keep root and objects independent

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_types}} \textendash{} * Can be used to manually define if the nodes along path are supposed to be (l)ists or
(d)icts. E.g. “dll” to create a dict at level 1, and lists at level 2 and 3. ” ” can also be used \sphinxhyphen{}
space doesn’t enforce a node\sphinxhyphen{}type like d or l. For ” “, existing nodes are traversed if possible,
otherwise default\_node\_type is used to create new nodes. Default “”, interpreted as ” ” at each level.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{list\_insert}} \textendash{} * Level at which a new node shall be inserted into the list instead of traversing the
existing node in the list at that index. See README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default\_node\_type}} \textendash{} * determines if new nodes by default should be created as (d)ict or (l)ist. Must be
either “d” or “l”, default “d”

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a reference to the modified root node, or a modified copy of the root node (see copy\sphinxhyphen{}parameter)

\item[{Raises}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if it isn’t possible to parse an int\sphinxhyphen{}index from the provided key in a position where node\sphinxhyphen{}types
    defines that the node shall be a list (if node\sphinxhyphen{}types is not l, the node will be replaced with a dict)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if obj is not either a FagusIterator or a Collection. Also raised if you try to merge different
    types of nodes at root level, e.g. a dict can only be merged with another Mapping, and a list can only
    be merged with another Iterable. \textasciitilde{} is also raised if a not modifiable root node needs to be modified

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{pop() (fagus.fagus.Fagus method)@\spxentry{pop()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.pop}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pop}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{default}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ Any}}
\pysigstopsignatures
\sphinxAtStartPar
Deletes the value at path and returns it

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} pop value at this position in self, or don’t do anything if path doesn’t exist in self

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default}} \textendash{} * returned if path doesn’t exist in self

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * return the result as Fagus\sphinxhyphen{}object if possible (default is just to return the result)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
value at path if it exists, or default if it doesn’t

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if the root node needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{description}\end{quote}

\end{fulllineitems}

\index{popitem() (fagus.fagus.Fagus method)@\spxentry{popitem()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.popitem}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{popitem}}}{}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
This function is not implemented in Fagus

\sphinxAtStartPar
Implementing this would require to cache the value, which was not prioritized to keep memory usage low.

\end{fulllineitems}

\index{discard() (fagus.fagus.Fagus method)@\spxentry{discard()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.discard}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{discard}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Deletes the value at path if it exists

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} pop value at this position in self, or don’t do anything if path doesn’t exist in self

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\end{itemize}

\end{description}\end{quote}

\sphinxAtStartPar
Returns: None

\end{fulllineitems}

\index{remove() (fagus.fagus.Fagus method)@\spxentry{remove()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.remove}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{remove}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Deletes the value at path if it exists, raises KeyError if it doesn’t

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} pop value at this position in self, or don’t do anything if path doesn’t exist in self

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\end{itemize}

\end{description}\end{quote}

\sphinxAtStartPar
Returns: None
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{KeyError}} \textendash{} if the value at path doesn’t exist

\end{description}\end{quote}

\end{fulllineitems}

\index{keys() (fagus.fagus.Fagus method)@\spxentry{keys()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.keys}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{keys}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ Iterable\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Returns keys for the node at path, or None if that node is a set or doesn’t exist / doesn’t have keys

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} get keys for node at this position in self. Default “” (gets values from the root node), See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
keys for the node at path, or an empty tuple if that node is a set or doesn’t exist / doesn’t have keys

\end{description}\end{quote}

\end{fulllineitems}

\index{values() (fagus.fagus.Fagus method)@\spxentry{values()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.values}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{values}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ Iterable\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Returns values for node at path

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} get values at this position in self, default “” (gets values from the root node). See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * converts sub\sphinxhyphen{}nodes into Fagus\sphinxhyphen{}objects in the returned list of values, default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} \textasciitilde{} creates a copy of the node before values() are returned. This can be beneficial if you want to make
changes to the returned nodes, but you don’t want to change self. Default False

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
values for the node at path. Returns an empty tuple if the value doesn’t exist, or just the value in a
tuple if the node isn’t iterable.

\end{description}\end{quote}

\end{fulllineitems}

\index{items() (fagus.fagus.Fagus method)@\spxentry{items()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.items}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{items}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ Iterable\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Returns in iterator of (key, value)\sphinxhyphen{}tuples in self, like dict.items()

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} get items at this position in self, Default “” (gets values from the root node). See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * converts sub\sphinxhyphen{}nodes into Fagus\sphinxhyphen{}objects in the returned iterator, default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} \textasciitilde{} creates a copy of the node before items() are returned. This can be beneficial if you want to make
changes to the returned nodes, but you don’t want to change self. Default False

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
iterator of (key, value)\sphinxhyphen{}tuples in self, like dict.items()

\end{description}\end{quote}

\end{fulllineitems}

\index{clear() (fagus.fagus.Fagus method)@\spxentry{clear()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.clear}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{clear}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Removes all elements from node at path.

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} clear at this position in self, Default “” (gets values from the root node). See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} if \textasciitilde{} is set, a copy of self is modified and then returned (thus self is not modified), default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * return self as a Fagus\sphinxhyphen{}object if it is a node (tuple / list / dict), default False

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
self as a node if fagus is set, or a modified copy of self if copy is set

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if the root node needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{description}\end{quote}

\end{fulllineitems}

\index{contains() (fagus.fagus.Fagus method)@\spxentry{contains()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.contains}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{contains}}}{\emph{\DUrole{n}{value}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ bool}}
\pysigstopsignatures
\sphinxAtStartPar
Check if value is present in the node at path

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value}} \textendash{} value to check

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} check if value is in node at this position in self, Default “” (checks root node). See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
whether value is in node at path in self. returns value == node if the node isn’t iterable, and false if
path doesn’t exit in self

\end{description}\end{quote}

\end{fulllineitems}

\index{count() (fagus.fagus.Fagus method)@\spxentry{count()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.count}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{count}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ int}}
\pysigstopsignatures
\sphinxAtStartPar
Check the number of elements in the node at path

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} position in self where the number of elements shall be found.Default “” (checks root node). See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the number of elements in the node at path. if there is no node at path, 0 is returned. If the element
at path is not a node, 1 is returned

\end{description}\end{quote}

\end{fulllineitems}

\index{index() (fagus.fagus.Fagus method)@\spxentry{index()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.index}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{index}}}{\emph{\DUrole{n}{value}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}, \emph{\DUrole{n}{start}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}int\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{stop}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}int\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{all\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}Union\DUrole{p}{{[}}int\DUrole{p}{,}\DUrole{w}{  }Any\DUrole{p}{,}\DUrole{w}{  }Sequence\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Returns the index / key of the specified value in the node at path if it exists
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value}} \textendash{} \textasciitilde{} to search index for

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{start}} \textendash{} start searching at this index. Only applicable if the node at path is a list / tuple

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{stop}} \textendash{} stop searching at this index. Only applicable if the node at path is a list / tuple

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} position in self where the node shall be searched for value. Default “” (checks root node). See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{all\_}} \textendash{} returns all matching indices / keys in a generator (instead of only the first)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
The first index of value if the node at path is a list, or the first key containing value if the node at
path is a dict. True if the node at path is a Set and contains value. If the element can’t be found in the
node at path, or there is no Collection at path, None is returned (instead of a ValueError).

\end{description}\end{quote}

\end{fulllineitems}

\index{isdisjoint() (fagus.fagus.Fagus method)@\spxentry{isdisjoint()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.isdisjoint}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{isdisjoint}}}{\emph{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Iterable\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{dict\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}keys\textquotesingle{}}}}{{ $\rightarrow$ bool}}
\pysigstopsignatures
\sphinxAtStartPar
Returns whether the other iterable is disjoint (has no common items) with the node at path

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{other}} \textendash{} other object to check

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} check if the node at this position in self, is disjoint from other

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dict\_}} \textendash{} use (k)eys, (v)alues or (i)tems for if value is a dict. Default keys

\end{itemize}

\end{description}\end{quote}
\begin{description}
\item[{Returns: whether the other iterable is disjoint from the value at path. If value is a dict, the keys are used.}] \leavevmode
\sphinxAtStartPar
Checks if value is present in other if value isn’t iterable. Returns True if there is no value at path.

\end{description}

\end{fulllineitems}

\index{child() (fagus.fagus.Fagus method)@\spxentry{child()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.child}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{child}}}{\emph{\DUrole{n}{obj}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Optional\DUrole{p}{{[}}Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{{ $\rightarrow$ {\hyperref[\detokenize{fagus.fagus:fagus.fagus.Fagus}]{\sphinxcrossref{fagus.fagus.Fagus}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Creates a Fagus\sphinxhyphen{}object for obj that has the same options as self

\end{fulllineitems}

\index{reversed() (fagus.fagus.Fagus method)@\spxentry{reversed()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.reversed}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reversed}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ Iterator\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Get reversed child\sphinxhyphen{}node at path if that node is a list

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} position in self where a list / tuple shall be returned reversed

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * converts sub\sphinxhyphen{}nodes into Fagus\sphinxhyphen{}objects in the returned iterator, default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} \textasciitilde{} creates a copy of the node before it is returned reversed(). This can be beneficial if you want to
make changes to the returned nodes, but you don’t want to change self. Default False

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a reversed iterator on the node at path (empty if path doesn’t exist)

\end{description}\end{quote}

\end{fulllineitems}

\index{reverse() (fagus.fagus.Fagus method)@\spxentry{reverse()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.reverse}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reverse}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{path\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }ellipsis\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Reverse child\sphinxhyphen{}node at path if that node exists and is reversible

\sphinxAtStartPar
* means that the parameter is a FagusOption, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} position in self where a list / tuple shall be reversed

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * converts sub\sphinxhyphen{}nodes into Fagus\sphinxhyphen{}objects in the returned iterator, default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} \textasciitilde{} creates a copy of the node before it is returned reversed(). This can be beneficial if you want to
make changes to the returned nodes, but you don’t want to change self. Default False

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
self as a node if fagus is set, or a modified copy of self if copy is set

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if the root node needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (fagus.fagus.Fagus method)@\spxentry{copy()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.copy}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{\DUrole{n}{deep}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Creates a copy of self. Creates a recursive shallow copy by default, or a copy.deepcopy() if deep is set.

\end{fulllineitems}

\index{options() (fagus.fagus.Fagus method)@\spxentry{options()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.options}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{options}}}{\emph{\DUrole{n}{options}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Optional\DUrole{p}{{[}}Dict\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }Any\DUrole{p}{{]}}\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{None}}, \emph{\DUrole{n}{get\_default\_options}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{reset}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ Dict\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Function to set multiple Fagus\sphinxhyphen{}options in one line
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{options}} \textendash{} dict with options that shall be set

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{get\_default\_options}} \textendash{} return all options (include default\sphinxhyphen{}values). Default: only return options that are set

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{reset}} \textendash{} if \textasciitilde{} is set, all options are reset before options is set

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a dict of options that are set, or all options if get\_default\_options is set

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_copy\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_copy\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__copy__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_copy\_\_}}}{\emph{\DUrole{n}{recursive}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Recursively creates a shallow\sphinxhyphen{}copy of self

\end{fulllineitems}

\index{\_\_call\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_call\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__call__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_call\_\_}}}{}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Calling the Fagus\sphinxhyphen{}object returns the root node the Fagus\sphinxhyphen{}object is wrapped around (equivalent to .root)
\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{fagus} \PYG{k+kn}{import} \PYG{n}{Fagus}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Fagus}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{q}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}
\PYG{g+go}{Fagus(\PYGZob{}\PYGZsq{}f\PYGZsq{}: \PYGZsq{}q\PYGZsq{}\PYGZcb{})}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}\PYGZsq{}f\PYGZsq{}: \PYGZsq{}q\PYGZsq{}\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{root}  \PYG{c+c1}{\PYGZsh{} .root returns the root\PYGZhy{}object in the same way as ()}
\PYG{g+go}{\PYGZob{}\PYGZsq{}f\PYGZsq{}: \PYGZsq{}q\PYGZsq{}\PYGZcb{}}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
the root object Fagus is wrapped around

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_getattr\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_getattr\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__getattr__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_getattr\_\_}}}{\emph{\DUrole{n}{attr}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}}}{{ $\rightarrow$ Any}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_getitem\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_getitem\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__getitem__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_getitem\_\_}}}{\emph{\DUrole{n}{item}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}}{{ $\rightarrow$ Any}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_setattr\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_setattr\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__setattr__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_setattr\_\_}}}{\emph{\DUrole{n}{attr}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}}, \emph{\DUrole{n}{value}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Implement setattr(self, name, value).

\end{fulllineitems}

\index{\_\_setitem\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_setitem\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__setitem__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_setitem\_\_}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}, \emph{\DUrole{n}{value}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_delattr\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_delattr\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__delattr__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_delattr\_\_}}}{\emph{\DUrole{n}{attr}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Implement delattr(self, name).

\end{fulllineitems}

\index{\_\_delitem\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_delitem\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__delitem__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_delitem\_\_}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_iter\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_iter\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__iter__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_iter\_\_}}}{}{{ $\rightarrow$ Iterator\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_hash\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_hash\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__hash__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_hash\_\_}}}{}{{ $\rightarrow$ int}}
\pysigstopsignatures
\sphinxAtStartPar
Return hash(self).

\end{fulllineitems}

\index{\_\_eq\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_eq\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__eq__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_eq\_\_}}}{\emph{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}}{{ $\rightarrow$ bool}}
\pysigstopsignatures
\sphinxAtStartPar
Return self==value.

\end{fulllineitems}

\index{\_\_ne\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_ne\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__ne__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_ne\_\_}}}{\emph{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}}{{ $\rightarrow$ bool}}
\pysigstopsignatures
\sphinxAtStartPar
Return self!=value.

\end{fulllineitems}

\index{\_\_lt\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_lt\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__lt__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_lt\_\_}}}{\emph{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}}{{ $\rightarrow$ bool}}
\pysigstopsignatures
\sphinxAtStartPar
Return self\textless{}value.

\end{fulllineitems}

\index{\_\_le\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_le\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__le__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_le\_\_}}}{\emph{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}}{{ $\rightarrow$ bool}}
\pysigstopsignatures
\sphinxAtStartPar
Return self\textless{}=value.

\end{fulllineitems}

\index{\_\_gt\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_gt\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__gt__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_gt\_\_}}}{\emph{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}}{{ $\rightarrow$ bool}}
\pysigstopsignatures
\sphinxAtStartPar
Return self\textgreater{}value.

\end{fulllineitems}

\index{\_\_ge\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_ge\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__ge__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_ge\_\_}}}{\emph{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}}{{ $\rightarrow$ bool}}
\pysigstopsignatures
\sphinxAtStartPar
Return self\textgreater{}=value.

\end{fulllineitems}

\index{\_\_contains\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_contains\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__contains__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_contains\_\_}}}{\emph{\DUrole{n}{value}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}}{{ $\rightarrow$ bool}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_len\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_len\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__len__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_len\_\_}}}{}{{ $\rightarrow$ int}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_bool\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_bool\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__bool__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_bool\_\_}}}{}{{ $\rightarrow$ bool}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_repr\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_repr\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__repr__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_repr\_\_}}}{}{{ $\rightarrow$ str}}
\pysigstopsignatures
\sphinxAtStartPar
Return repr(self).

\end{fulllineitems}

\index{\_\_str\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_str\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__str__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_str\_\_}}}{}{{ $\rightarrow$ str}}
\pysigstopsignatures
\sphinxAtStartPar
Return str(self).

\end{fulllineitems}

\index{\_\_iadd\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_iadd\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__iadd__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_iadd\_\_}}}{\emph{\DUrole{n}{value}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_add\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_add\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__add__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_add\_\_}}}{\emph{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_radd\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_radd\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__radd__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_radd\_\_}}}{\emph{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_isub\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_isub\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__isub__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_isub\_\_}}}{\emph{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_sub\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_sub\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__sub__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_sub\_\_}}}{\emph{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_rsub\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_rsub\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__rsub__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_rsub\_\_}}}{\emph{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_imul\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_imul\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__imul__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_imul\_\_}}}{\emph{\DUrole{n}{times}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}}{{ $\rightarrow$ Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_mul\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_mul\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__mul__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_mul\_\_}}}{\emph{\DUrole{n}{times}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}}{{ $\rightarrow$ Union\DUrole{p}{{[}}Tuple\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }List\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{{]}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_rmul\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_rmul\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__rmul__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_rmul\_\_}}}{\emph{\DUrole{n}{times}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}}{{ $\rightarrow$ Union\DUrole{p}{{[}}Tuple\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }List\DUrole{p}{{[}}Any\DUrole{p}{{]}}\DUrole{p}{{]}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_abstractmethods\_\_ (fagus.fagus.Fagus attribute)@\spxentry{\_\_abstractmethods\_\_}\spxextra{fagus.fagus.Fagus attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__abstractmethods__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_abstractmethods\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }frozenset(\{\})}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_annotations\_\_ (fagus.fagus.Fagus attribute)@\spxentry{\_\_annotations\_\_}\spxextra{fagus.fagus.Fagus attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__annotations__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_annotations\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }\{\textquotesingle{}\_options\textquotesingle{}: \textquotesingle{}Optional{[}Dict{[}str, Any{]}{]}\textquotesingle{}, \textquotesingle{}root\textquotesingle{}: \textquotesingle{}Collection{[}Any{]}\textquotesingle{}\}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_dict\_\_ (fagus.fagus.Fagus attribute)@\spxentry{\_\_dict\_\_}\spxextra{fagus.fagus.Fagus attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__dict__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_dict\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }mappingproxy(\{\textquotesingle{}\_\_module\_\_\textquotesingle{}: \textquotesingle{}fagus.fagus\textquotesingle{}, \textquotesingle{}\_\_doc\_\_\textquotesingle{}: \textquotesingle{}Fagus is a wrapper\sphinxhyphen{}class for complex, nested objects of dicts and lists in Python\textbackslash{}n\textbackslash{}n    Fagus can be used as an object by instantiating it, but it\textbackslash{}\textquotesingle{}s also possible to use all methods statically without\textbackslash{}n    even an object, so that a = \{\}; Fagus.set(a, "top med", 1) and a = Fagus(\{\}); a.set(1, "top med") do the same.\textbackslash{}n\textbackslash{}n    The root node is always modified directly. If you don\textbackslash{}\textquotesingle{}t want to change the root node, all the functions where it\textbackslash{}n    makes sense support to rather modify a copy, and return that modified copy using the copy\sphinxhyphen{}parameter.\textbackslash{}n\textbackslash{}n    **FagusOptions**:\textbackslash{}n    Several parameters used in functions in Fagus work as options so that you don\textbackslash{}\textquotesingle{}t have to specify them each time you\textbackslash{}n    run a function. In the docstrings, these options are marked with a \textbackslash{}\textbackslash{}*, e.g. the fagus parameter is an option.\textbackslash{}n    Options can be specified at three levels with increasing precedence: at class\sphinxhyphen{}level (Fagus.fagus = True), at\textbackslash{}n    object\sphinxhyphen{}level (a = Fagus(), a.fagus = True) and in each function\sphinxhyphen{}call (a.get("b", fagus=True)). If you generally want\textbackslash{}n    to change an option, change it at class\sphinxhyphen{}level \sphinxhyphen{} all objects in that file will inherit this option. If you want to\textbackslash{}n    change the option specifically for one object, change the option at object\sphinxhyphen{}level. If you only want to change the\textbackslash{}n    option for one single run of a function, put it as a function\sphinxhyphen{}parameter. More thorough examples of options can be\textbackslash{}n    found in README.md.\textbackslash{}n    \textquotesingle{}, \textquotesingle{}\_\_init\_\_\textquotesingle{}: \textless{}function Fagus.\_\_init\_\_\textgreater{}, \textquotesingle{}get\textquotesingle{}: \textless{}function Fagus.get\textgreater{}, \textquotesingle{}iter\textquotesingle{}: \textless{}function Fagus.iter\textgreater{}, \textquotesingle{}filter\textquotesingle{}: \textless{}function Fagus.filter\textgreater{}, \textquotesingle{}split\textquotesingle{}: \textless{}function Fagus.split\textgreater{}, \textquotesingle{}\_split\_r\textquotesingle{}: \textless{}staticmethod(\textless{}function Fagus.\_split\_r\textgreater{})\textgreater{}, \textquotesingle{}set\textquotesingle{}: \textless{}function Fagus.set\textgreater{}, \textquotesingle{}append\textquotesingle{}: \textless{}function Fagus.append\textgreater{}, \textquotesingle{}extend\textquotesingle{}: \textless{}function Fagus.extend\textgreater{}, \textquotesingle{}insert\textquotesingle{}: \textless{}function Fagus.insert\textgreater{}, \textquotesingle{}add\textquotesingle{}: \textless{}function Fagus.add\textgreater{}, \textquotesingle{}update\textquotesingle{}: \textless{}function Fagus.update\textgreater{}, \textquotesingle{}\_build\_node\textquotesingle{}: \textless{}function Fagus.\_build\_node\textgreater{}, \textquotesingle{}\_put\_value\textquotesingle{}: \textless{}staticmethod(\textless{}function Fagus.\_put\_value\textgreater{})\textgreater{}, \textquotesingle{}setdefault\textquotesingle{}: \textless{}function Fagus.setdefault\textgreater{}, \textquotesingle{}mod\textquotesingle{}: \textless{}function Fagus.mod\textgreater{}, \textquotesingle{}mod\_all\textquotesingle{}: \textless{}function Fagus.mod\_all\textgreater{}, \textquotesingle{}serialize\textquotesingle{}: \textless{}function Fagus.serialize\textgreater{}, \textquotesingle{}\_serialize\_r\textquotesingle{}: \textless{}staticmethod(\textless{}function Fagus.\_serialize\_r\textgreater{})\textgreater{}, \textquotesingle{}\_serializable\_value\textquotesingle{}: \textless{}staticmethod(\textless{}function Fagus.\_serializable\_value\textgreater{})\textgreater{}, \textquotesingle{}merge\textquotesingle{}: \textless{}function Fagus.merge\textgreater{}, \textquotesingle{}pop\textquotesingle{}: \textless{}function Fagus.pop\textgreater{}, \textquotesingle{}popitem\textquotesingle{}: \textless{}function Fagus.popitem\textgreater{}, \textquotesingle{}discard\textquotesingle{}: \textless{}function Fagus.discard\textgreater{}, \textquotesingle{}remove\textquotesingle{}: \textless{}function Fagus.remove\textgreater{}, \textquotesingle{}keys\textquotesingle{}: \textless{}function Fagus.keys\textgreater{}, \textquotesingle{}values\textquotesingle{}: \textless{}function Fagus.values\textgreater{}, \textquotesingle{}items\textquotesingle{}: \textless{}function Fagus.items\textgreater{}, \textquotesingle{}clear\textquotesingle{}: \textless{}function Fagus.clear\textgreater{}, \textquotesingle{}contains\textquotesingle{}: \textless{}function Fagus.contains\textgreater{}, \textquotesingle{}count\textquotesingle{}: \textless{}function Fagus.count\textgreater{}, \textquotesingle{}index\textquotesingle{}: \textless{}function Fagus.index\textgreater{}, \textquotesingle{}isdisjoint\textquotesingle{}: \textless{}function Fagus.isdisjoint\textgreater{}, \textquotesingle{}child\textquotesingle{}: \textless{}function Fagus.child\textgreater{}, \textquotesingle{}reversed\textquotesingle{}: \textless{}function Fagus.reversed\textgreater{}, \textquotesingle{}reverse\textquotesingle{}: \textless{}function Fagus.reverse\textgreater{}, \textquotesingle{}copy\textquotesingle{}: \textless{}function Fagus.copy\textgreater{}, \textquotesingle{}options\textquotesingle{}: \textless{}function Fagus.options\textgreater{}, \textquotesingle{}\_opt\textquotesingle{}: \textless{}function Fagus.\_opt\textgreater{}, \textquotesingle{}\_ensure\_mutable\_node\textquotesingle{}: \textless{}staticmethod(\textless{}function Fagus.\_ensure\_mutable\_node\textgreater{})\textgreater{}, \textquotesingle{}\_get\_mutable\_node\textquotesingle{}: \textless{}function Fagus.\_get\_mutable\_node\textgreater{}, \textquotesingle{}\_mutable\_node\_type\textquotesingle{}: \textless{}staticmethod(\textless{}function Fagus.\_mutable\_node\_type\textgreater{})\textgreater{}, \textquotesingle{}\_node\_type\textquotesingle{}: \textless{}staticmethod(\textless{}function Fagus.\_node\_type\textgreater{})\textgreater{}, \textquotesingle{}\_hash\textquotesingle{}: \textless{}function Fagus.\_hash\textgreater{}, \textquotesingle{}\_\_copy\_\_\textquotesingle{}: \textless{}function Fagus.\_\_copy\_\_\textgreater{}, \textquotesingle{}\_\_call\_\_\textquotesingle{}: \textless{}function Fagus.\_\_call\_\_\textgreater{}, \textquotesingle{}\_\_getattr\_\_\textquotesingle{}: \textless{}function Fagus.\_\_getattr\_\_\textgreater{}, \textquotesingle{}\_\_getitem\_\_\textquotesingle{}: \textless{}function Fagus.\_\_getitem\_\_\textgreater{}, \textquotesingle{}\_\_setattr\_\_\textquotesingle{}: \textless{}function Fagus.\_\_setattr\_\_\textgreater{}, \textquotesingle{}\_\_setitem\_\_\textquotesingle{}: \textless{}function Fagus.\_\_setitem\_\_\textgreater{}, \textquotesingle{}\_\_delattr\_\_\textquotesingle{}: \textless{}function Fagus.\_\_delattr\_\_\textgreater{}, \textquotesingle{}\_\_delitem\_\_\textquotesingle{}: \textless{}function Fagus.\_\_delitem\_\_\textgreater{}, \textquotesingle{}\_\_iter\_\_\textquotesingle{}: \textless{}function Fagus.\_\_iter\_\_\textgreater{}, \textquotesingle{}\_\_hash\_\_\textquotesingle{}: \textless{}function Fagus.\_\_hash\_\_\textgreater{}, \textquotesingle{}\_\_eq\_\_\textquotesingle{}: \textless{}function Fagus.\_\_eq\_\_\textgreater{}, \textquotesingle{}\_\_ne\_\_\textquotesingle{}: \textless{}function Fagus.\_\_ne\_\_\textgreater{}, \textquotesingle{}\_\_lt\_\_\textquotesingle{}: \textless{}function Fagus.\_\_lt\_\_\textgreater{}, \textquotesingle{}\_\_le\_\_\textquotesingle{}: \textless{}function Fagus.\_\_le\_\_\textgreater{}, \textquotesingle{}\_\_gt\_\_\textquotesingle{}: \textless{}function Fagus.\_\_gt\_\_\textgreater{}, \textquotesingle{}\_\_ge\_\_\textquotesingle{}: \textless{}function Fagus.\_\_ge\_\_\textgreater{}, \textquotesingle{}\_\_contains\_\_\textquotesingle{}: \textless{}function Fagus.\_\_contains\_\_\textgreater{}, \textquotesingle{}\_\_len\_\_\textquotesingle{}: \textless{}function Fagus.\_\_len\_\_\textgreater{}, \textquotesingle{}\_\_bool\_\_\textquotesingle{}: \textless{}function Fagus.\_\_bool\_\_\textgreater{}, \textquotesingle{}\_\_repr\_\_\textquotesingle{}: \textless{}function Fagus.\_\_repr\_\_\textgreater{}, \textquotesingle{}\_\_str\_\_\textquotesingle{}: \textless{}function Fagus.\_\_str\_\_\textgreater{}, \textquotesingle{}\_\_iadd\_\_\textquotesingle{}: \textless{}function Fagus.\_\_iadd\_\_\textgreater{}, \textquotesingle{}\_\_add\_\_\textquotesingle{}: \textless{}function Fagus.\_\_add\_\_\textgreater{}, \textquotesingle{}\_\_radd\_\_\textquotesingle{}: \textless{}function Fagus.\_\_radd\_\_\textgreater{}, \textquotesingle{}\_\_isub\_\_\textquotesingle{}: \textless{}function Fagus.\_\_isub\_\_\textgreater{}, \textquotesingle{}\_\_sub\_\_\textquotesingle{}: \textless{}function Fagus.\_\_sub\_\_\textgreater{}, \textquotesingle{}\_\_rsub\_\_\textquotesingle{}: \textless{}function Fagus.\_\_rsub\_\_\textgreater{}, \textquotesingle{}\_\_imul\_\_\textquotesingle{}: \textless{}function Fagus.\_\_imul\_\_\textgreater{}, \textquotesingle{}\_\_mul\_\_\textquotesingle{}: \textless{}function Fagus.\_\_mul\_\_\textgreater{}, \textquotesingle{}\_\_rmul\_\_\textquotesingle{}: \textless{}function Fagus.\_\_rmul\_\_\textgreater{}, \textquotesingle{}\_\_reversed\_\_\textquotesingle{}: \textless{}function Fagus.\_\_reversed\_\_\textgreater{}, \textquotesingle{}\_\_reduce\_\_\textquotesingle{}: \textless{}function Fagus.\_\_reduce\_\_\textgreater{}, \textquotesingle{}\_\_reduce\_ex\_\_\textquotesingle{}: \textless{}function Fagus.\_\_reduce\_ex\_\_\textgreater{}, \textquotesingle{}\_\_dict\_\_\textquotesingle{}: \textless{}attribute \textquotesingle{}\_\_dict\_\_\textquotesingle{} of \textquotesingle{}Fagus\textquotesingle{} objects\textgreater{}, \textquotesingle{}\_\_weakref\_\_\textquotesingle{}: \textless{}attribute \textquotesingle{}\_\_weakref\_\_\textquotesingle{} of \textquotesingle{}Fagus\textquotesingle{} objects\textgreater{}, \textquotesingle{}\_\_abstractmethods\_\_\textquotesingle{}: frozenset(), \textquotesingle{}\_abc\_impl\textquotesingle{}: \textless{}\_abc.\_abc\_data object\textgreater{}, \textquotesingle{}\_\_annotations\_\_\textquotesingle{}: \{\textquotesingle{}root\textquotesingle{}: \textquotesingle{}Collection{[}Any{]}\textquotesingle{}, \textquotesingle{}\_options\textquotesingle{}: \textquotesingle{}Optional{[}Dict{[}str, Any{]}{]}\textquotesingle{}\}\})}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_module\_\_ (fagus.fagus.Fagus attribute)@\spxentry{\_\_module\_\_}\spxextra{fagus.fagus.Fagus attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__module__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_module\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }\textquotesingle{}fagus.fagus\textquotesingle{}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_reversed\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_reversed\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__reversed__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_reversed\_\_}}}{}{{ $\rightarrow$ Iterator\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_weakref\_\_ (fagus.fagus.Fagus attribute)@\spxentry{\_\_weakref\_\_}\spxextra{fagus.fagus.Fagus attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__weakref__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_weakref\_\_}}}
\pysigstopsignatures
\sphinxAtStartPar
list of weak references to the object (if defined)

\end{fulllineitems}

\index{\_\_reduce\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_reduce\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__reduce__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_reduce\_\_}}}{}{{ $\rightarrow$ Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }Tuple\DUrole{p}{{[}}Any\DUrole{p}{,}\DUrole{w}{  }\DUrole{p}{...}\DUrole{p}{{]}}\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Helper for pickle.

\end{fulllineitems}

\index{\_\_reduce\_ex\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_reduce\_ex\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__reduce_ex__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_reduce\_ex\_\_}}}{\emph{\DUrole{n}{protocol}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}}{{ $\rightarrow$ Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }Tuple\DUrole{p}{{[}}Any\DUrole{p}{,}\DUrole{w}{  }\DUrole{p}{...}\DUrole{p}{{]}}\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Helper for pickle.

\end{fulllineitems}


\end{fulllineitems}


\sphinxstepscope


\subsection{fagus.filters module}
\label{\detokenize{fagus.filters:module-fagus.filters}}\label{\detokenize{fagus.filters:fagus-filters-module}}\label{\detokenize{fagus.filters::doc}}\index{module@\spxentry{module}!fagus.filters@\spxentry{fagus.filters}}\index{fagus.filters@\spxentry{fagus.filters}!module@\spxentry{module}}
\sphinxAtStartPar
This module contains filter\sphinxhyphen{}classes used in Fagus
\index{FilBase (class in fagus.filters)@\spxentry{FilBase}\spxextra{class in fagus.filters}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.FilBase}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{fagus.filters.}}\sphinxbfcode{\sphinxupquote{FilBase}}}{\emph{\DUrole{o}{*}\DUrole{n}{filter\_args}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}, \emph{\DUrole{n}{inexclude}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
FilterBase \sphinxhyphen{} base\sphinxhyphen{}class for all filters used in Fagus, providing basic functions shared by all filters
\index{\_\_init\_\_() (fagus.filters.FilBase method)@\spxentry{\_\_init\_\_()}\spxextra{fagus.filters.FilBase method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.FilBase.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{o}{*}\DUrole{n}{filter\_args}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}, \emph{\DUrole{n}{inexclude}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Basic constructor for all filter\sphinxhyphen{}classes used in Fagus
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{*filter\_args}} \textendash{} Each argument filters one key in the tree, the last argument filters the leaf\sphinxhyphen{}value. You can
put a list of values to match different values in the same filter. In this list, you can also specify
subfilters to match different grains differently.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{inexclude}} \textendash{} In some cases it’s easier to specify that a filter shall match everything except b, rather than
match a. \textasciitilde{} can be used to specify for each argument if the filter shall include it (+) or exclude it
(\sphinxhyphen{}). Valid example: “++\sphinxhyphen{}+”. If this parameter isn’t specified, all args will be treated as (+).

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{included() (fagus.filters.FilBase method)@\spxentry{included()}\spxextra{fagus.filters.FilBase method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.FilBase.included}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{included}}}{\emph{\DUrole{n}{index}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}}{{ $\rightarrow$ bool}}
\pysigstopsignatures
\sphinxAtStartPar
This function returns if the filter should be an include\sphinxhyphen{}filter (+) or an exclude\sphinxhyphen{}filter (\sphinxhyphen{}) at a given index
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{index}} \textendash{} index in filter\sphinxhyphen{}arguments that shall be interpreted as include\sphinxhyphen{} or exclude\sphinxhyphen{}filter

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\begin{description}
\item[{bool that is True if it is an include\sphinxhyphen{}filter, and False if it is an Exclude\sphinxhyphen{}Filter, defaults to True if}] \leavevmode
\sphinxAtStartPar
undefined at index

\end{description}


\end{description}\end{quote}

\end{fulllineitems}

\index{match\_node() (fagus.filters.FilBase method)@\spxentry{match\_node()}\spxextra{fagus.filters.FilBase method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.FilBase.match_node}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{match\_node}}}{\emph{\DUrole{n}{node}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}, \emph{\DUrole{n}{\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{None}}}{{ $\rightarrow$ bool}}
\pysigstopsignatures
\sphinxAtStartPar
This method is overridden by CheckFilter and ValueFilter, and otherwise not in use

\end{fulllineitems}

\index{\_\_annotations\_\_ (fagus.filters.FilBase attribute)@\spxentry{\_\_annotations\_\_}\spxextra{fagus.filters.FilBase attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.FilBase.__annotations__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_annotations\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }\{\}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_dict\_\_ (fagus.filters.FilBase attribute)@\spxentry{\_\_dict\_\_}\spxextra{fagus.filters.FilBase attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.FilBase.__dict__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_dict\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }mappingproxy(\{\textquotesingle{}\_\_module\_\_\textquotesingle{}: \textquotesingle{}fagus.filters\textquotesingle{}, \textquotesingle{}\_\_doc\_\_\textquotesingle{}: \textquotesingle{}FilterBase \sphinxhyphen{} base\sphinxhyphen{}class for all filters used in Fagus, providing basic functions shared by all filters\textquotesingle{}, \textquotesingle{}\_\_init\_\_\textquotesingle{}: \textless{}function FilBase.\_\_init\_\_\textgreater{}, \textquotesingle{}included\textquotesingle{}: \textless{}function FilBase.included\textgreater{}, \textquotesingle{}match\_node\textquotesingle{}: \textless{}function FilBase.match\_node\textgreater{}, \textquotesingle{}\_\_dict\_\_\textquotesingle{}: \textless{}attribute \textquotesingle{}\_\_dict\_\_\textquotesingle{} of \textquotesingle{}FilBase\textquotesingle{} objects\textgreater{}, \textquotesingle{}\_\_weakref\_\_\textquotesingle{}: \textless{}attribute \textquotesingle{}\_\_weakref\_\_\textquotesingle{} of \textquotesingle{}FilBase\textquotesingle{} objects\textgreater{}, \textquotesingle{}\_\_annotations\_\_\textquotesingle{}: \{\}\})}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_module\_\_ (fagus.filters.FilBase attribute)@\spxentry{\_\_module\_\_}\spxextra{fagus.filters.FilBase attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.FilBase.__module__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_module\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }\textquotesingle{}fagus.filters\textquotesingle{}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_weakref\_\_ (fagus.filters.FilBase attribute)@\spxentry{\_\_weakref\_\_}\spxextra{fagus.filters.FilBase attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.FilBase.__weakref__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_weakref\_\_}}}
\pysigstopsignatures
\sphinxAtStartPar
list of weak references to the object (if defined)

\end{fulllineitems}


\end{fulllineitems}

\index{VFil (class in fagus.filters)@\spxentry{VFil}\spxextra{class in fagus.filters}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.VFil}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{fagus.filters.}}\sphinxbfcode{\sphinxupquote{VFil}}}{\emph{\DUrole{o}{*}\DUrole{n}{filter\_args}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}, \emph{\DUrole{n}{inexclude}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{invert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{fagus.filters:fagus.filters.FilBase}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fagus.filters.FilBase}}}}}

\sphinxAtStartPar
ValueFilter \sphinxhyphen{} This special type of filter can be used to inspect the entire node

\sphinxAtStartPar
It can be used to e.g. select all the nodes that contain at least 10 elements. See README for an example
\index{\_\_init\_\_() (fagus.filters.VFil method)@\spxentry{\_\_init\_\_()}\spxextra{fagus.filters.VFil method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.VFil.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{o}{*}\DUrole{n}{filter\_args}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}, \emph{\DUrole{n}{inexclude}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{invert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ None}}
\pysigstopsignatures\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{*filter\_args}} \textendash{} Each argument filters one key in the tree, the last argument filters the leaf\sphinxhyphen{}value. You can
put a list of values to match different values in the same filter. In this list, you can also specify
subfilters to match different grains differently.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{inexclude}} \textendash{} In some cases it’s easier to specify that a filter shall match everything except b, rather than
match a. \textasciitilde{} can be used to specify for each argument if the filter shall include it (+) or exclude it
(\sphinxhyphen{}). Valid example: “++\sphinxhyphen{}+”. If this parameter isn’t specified, all args will be treated as (+).

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{invert}} \textendash{} Invert this whole filter to match if it doesn’t match. E.g. if you want to select all the nodes
that don’t have a certain property.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{match\_node() (fagus.filters.VFil method)@\spxentry{match\_node()}\spxextra{fagus.filters.VFil method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.VFil.match_node}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{match\_node}}}{\emph{\DUrole{n}{node}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}, \emph{\DUrole{n}{\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{None}}}{{ $\rightarrow$ bool}}
\pysigstopsignatures
\sphinxAtStartPar
Verify that a node matches ValueFilter
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node}} \textendash{} node to check

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{\_}} \textendash{} this argument is ignored

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
bool whether the filter matched

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_annotations\_\_ (fagus.filters.VFil attribute)@\spxentry{\_\_annotations\_\_}\spxextra{fagus.filters.VFil attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.VFil.__annotations__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_annotations\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }\{\}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_module\_\_ (fagus.filters.VFil attribute)@\spxentry{\_\_module\_\_}\spxextra{fagus.filters.VFil attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.VFil.__module__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_module\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }\textquotesingle{}fagus.filters\textquotesingle{}}}}
\pysigstopsignatures
\end{fulllineitems}


\end{fulllineitems}

\index{KFil (class in fagus.filters)@\spxentry{KFil}\spxextra{class in fagus.filters}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.KFil}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{fagus.filters.}}\sphinxbfcode{\sphinxupquote{KFil}}}{\emph{\DUrole{o}{*}\DUrole{n}{filter\_args}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}, \emph{\DUrole{n}{inexclude}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{str\_as\_re}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{fagus.filters:fagus.filters.FilBase}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fagus.filters.FilBase}}}}}

\sphinxAtStartPar
KeyFilter \sphinxhyphen{} Base class for filters in Fagus that inspect key\sphinxhyphen{}values to determine whether the filter matched
\index{\_\_init\_\_() (fagus.filters.KFil method)@\spxentry{\_\_init\_\_()}\spxextra{fagus.filters.KFil method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.KFil.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{o}{*}\DUrole{n}{filter\_args}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}, \emph{\DUrole{n}{inexclude}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{str\_as\_re}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Initializes KeyFilter and verifies the arguments passed to it
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{*filter\_args}} \textendash{} Each argument filters one key in the tree, the last argument filters the leaf\sphinxhyphen{}value. You can
put a list of values to match different values in the same filter. In this list, you can also specify
subfilters to match different grains differently.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{inexclude}} \textendash{} In some cases it’s easier to specify that a filter shall match everything except b, rather than
match a. \textasciitilde{} can be used to specify for each argument if the filter shall include it (+) or exclude it
(\sphinxhyphen{}). Valid example: “++\sphinxhyphen{}+”. If this parameter isn’t specified, all args will be treated as (+).

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{str\_as\_re}} \textendash{} If this is set to True, it will be evaluated for all str’s if they’d match differently as a
regex, and in the latter case match these strings as regex patterns. E.g. re.match(“a.*”, b) will match
differently than “a.*” == b. In this case, “a.*” will be used as a regex\sphinxhyphen{}pattern. However
re.match(“abc”, b) will give the same result as “abc” == b, so here “abc” == b will be used.

\end{itemize}

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if the filters are not stacked correctly / stacked in a way that doesn’t make sense

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_getitem\_\_() (fagus.filters.KFil method)@\spxentry{\_\_getitem\_\_()}\spxextra{fagus.filters.KFil method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.KFil.__getitem__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_getitem\_\_}}}{\emph{\DUrole{n}{index}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}}{{ $\rightarrow$ Any}}
\pysigstopsignatures
\sphinxAtStartPar
Get filter\sphinxhyphen{}argument at index
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
filter\sphinxhyphen{}argument at index, \_None if index isn’t defined

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_setitem\_\_() (fagus.filters.KFil method)@\spxentry{\_\_setitem\_\_()}\spxextra{fagus.filters.KFil method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.KFil.__setitem__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_setitem\_\_}}}{\emph{\DUrole{n}{key}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{value}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Set filter\sphinxhyphen{}argument at index. Throws IndexError if that index isn’t defined

\end{fulllineitems}

\index{match() (fagus.filters.KFil method)@\spxentry{match()}\spxextra{fagus.filters.KFil method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.KFil.match}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{match}}}{\emph{\DUrole{n}{value}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}, \emph{\DUrole{n}{index}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{0}}, \emph{\DUrole{n}{\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{None}}}{{ $\rightarrow$ Tuple\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }Optional\DUrole{p}{{[}}{\hyperref[\detokenize{fagus.filters:fagus.filters.KFil}]{\sphinxcrossref{fagus.filters.KFil}}}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }int\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
match filter at index (matches recursively into subfilters if necessary)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value}} \textendash{} the value to be matched against the filter

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{index}} \textendash{} index of filter\sphinxhyphen{}argument to check

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{\_}} \textendash{} this argument is ignored

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\begin{description}
\item[{whether the value matched the filter, the filter that matched (as it can be a subfilter), and the next index}] \leavevmode
\sphinxAtStartPar
in that (sub)filter

\end{description}


\end{description}\end{quote}

\end{fulllineitems}

\index{match\_list() (fagus.filters.KFil method)@\spxentry{match\_list()}\spxextra{fagus.filters.KFil method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.KFil.match_list}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{match\_list}}}{\emph{\DUrole{n}{value}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{index}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{0}}, \emph{\DUrole{n}{node\_length}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{0}}}{{ $\rightarrow$ Tuple\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }Optional\DUrole{p}{{[}}{\hyperref[\detokenize{fagus.filters:fagus.filters.KFil}]{\sphinxcrossref{fagus.filters.KFil}}}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }int\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
match\_list: same as match, but optimized to match list\sphinxhyphen{}indices (e. g. no regex\sphinxhyphen{}matching here)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value}} \textendash{} the value to be matched against the filter

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{index}} \textendash{} index of filter\sphinxhyphen{}argument to check

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_length}} \textendash{} length of the list whose indices shall be verified

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\begin{description}
\item[{whether the value matched the filter, the filter that matched (as it can be a subfilter), and the next index}] \leavevmode
\sphinxAtStartPar
in that (sub)filter

\end{description}


\end{description}\end{quote}

\end{fulllineitems}

\index{match\_extra\_filters() (fagus.filters.KFil method)@\spxentry{match\_extra\_filters()}\spxextra{fagus.filters.KFil method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.KFil.match_extra_filters}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{match\_extra\_filters}}}{\emph{\DUrole{n}{node}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}, \emph{\DUrole{n}{index}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{0}}}{{ $\rightarrow$ bool}}
\pysigstopsignatures
\sphinxAtStartPar
Match extra filters on node (CFil and VFil).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node}} \textendash{} node to be verified

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{index}} \textendash{} filter\_index to check for extra filters

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
bool whether the extra filters matched

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_annotations\_\_ (fagus.filters.KFil attribute)@\spxentry{\_\_annotations\_\_}\spxextra{fagus.filters.KFil attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.KFil.__annotations__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_annotations\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }\{\}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_module\_\_ (fagus.filters.KFil attribute)@\spxentry{\_\_module\_\_}\spxextra{fagus.filters.KFil attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.KFil.__module__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_module\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }\textquotesingle{}fagus.filters\textquotesingle{}}}}
\pysigstopsignatures
\end{fulllineitems}


\end{fulllineitems}

\index{Fil (class in fagus.filters)@\spxentry{Fil}\spxextra{class in fagus.filters}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.Fil}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{fagus.filters.}}\sphinxbfcode{\sphinxupquote{Fil}}}{\emph{\DUrole{o}{*}\DUrole{n}{filter\_args}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}, \emph{\DUrole{n}{inexclude}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{str\_as\_re}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{fagus.filters:fagus.filters.KFil}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fagus.filters.KFil}}}}}

\sphinxAtStartPar
TFilter \sphinxhyphen{} what matches this filter will actually be visible in the result. See README
\index{\_\_annotations\_\_ (fagus.filters.Fil attribute)@\spxentry{\_\_annotations\_\_}\spxextra{fagus.filters.Fil attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.Fil.__annotations__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_annotations\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }\{\}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_module\_\_ (fagus.filters.Fil attribute)@\spxentry{\_\_module\_\_}\spxextra{fagus.filters.Fil attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.Fil.__module__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_module\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }\textquotesingle{}fagus.filters\textquotesingle{}}}}
\pysigstopsignatures
\end{fulllineitems}


\end{fulllineitems}

\index{CFil (class in fagus.filters)@\spxentry{CFil}\spxextra{class in fagus.filters}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.CFil}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{fagus.filters.}}\sphinxbfcode{\sphinxupquote{CFil}}}{\emph{\DUrole{o}{*}\DUrole{n}{filter\_args}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}, \emph{\DUrole{n}{inexclude}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{str\_as\_re}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{invert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{fagus.filters:fagus.filters.KFil}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fagus.filters.KFil}}}}}

\sphinxAtStartPar
CFil \sphinxhyphen{} can be used to select nodes based on values that shall not appear in the result. See README
\index{\_\_init\_\_() (fagus.filters.CFil method)@\spxentry{\_\_init\_\_()}\spxextra{fagus.filters.CFil method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.CFil.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{o}{*}\DUrole{n}{filter\_args}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}, \emph{\DUrole{n}{inexclude}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{str\_as\_re}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{invert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Initializes KeyFilter and verifies the arguments passed to it
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{*filter\_args}} \textendash{} Each argument filters one key in the tree, the last argument filters the leaf\sphinxhyphen{}value. You can
put a list of values to match different values in the same filter. In this list, you can also specify
subfilters to match different grains differently.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{inexclude}} \textendash{} In some cases it’s easier to specify that a filter shall match everything except b, rather than
match a. \textasciitilde{} can be used to specify for each argument if the filter shall include it (+) or exclude it
(\sphinxhyphen{}). Valid example: “++\sphinxhyphen{}+”. If this parameter isn’t specified, all args will be treated as (+).

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{str\_as\_re}} \textendash{} If this is set to True, it will be evaluated for all str’s if they’d match differently as a
regex, and in the latter case match these strings as regex patterns. E.g. re.match(“a.*”, b) will match
differently than “a.*” == b. In this case, “a.*” will be used as a regex\sphinxhyphen{}pattern. However
re.match(“abc”, b) will give the same result as “abc” == b, so here “abc” == b will be used.

\end{itemize}

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if the filters are not stacked correctly, or stacked in a way that doesn’t make sense

\end{description}\end{quote}

\end{fulllineitems}

\index{match\_node() (fagus.filters.CFil method)@\spxentry{match\_node()}\spxextra{fagus.filters.CFil method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.CFil.match_node}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{match\_node}}}{\emph{\DUrole{n}{node}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}, \emph{\DUrole{n}{index}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{0}}}{{ $\rightarrow$ bool}}
\pysigstopsignatures
\sphinxAtStartPar
Recursive function to completely verify a node and its subnodes in CFil
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node}} \textendash{} node to check

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{index}} \textendash{} index in filter to check (filter is self)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
bool whether the filter matched

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_annotations\_\_ (fagus.filters.CFil attribute)@\spxentry{\_\_annotations\_\_}\spxextra{fagus.filters.CFil attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.CFil.__annotations__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_annotations\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }\{\}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_module\_\_ (fagus.filters.CFil attribute)@\spxentry{\_\_module\_\_}\spxextra{fagus.filters.CFil attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.CFil.__module__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_module\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }\textquotesingle{}fagus.filters\textquotesingle{}}}}
\pysigstopsignatures
\end{fulllineitems}


\end{fulllineitems}


\sphinxstepscope


\subsection{fagus.iterators module}
\label{\detokenize{fagus.iterators:module-fagus.iterators}}\label{\detokenize{fagus.iterators:fagus-iterators-module}}\label{\detokenize{fagus.iterators::doc}}\index{module@\spxentry{module}!fagus.iterators@\spxentry{fagus.iterators}}\index{fagus.iterators@\spxentry{fagus.iterators}!module@\spxentry{module}}
\sphinxAtStartPar
This module contains iterator\sphinxhyphen{}classes that are used to iterate over Fagus\sphinxhyphen{}objects
\index{FilteredIterator (class in fagus.iterators)@\spxentry{FilteredIterator}\spxextra{class in fagus.iterators}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.iterators:fagus.iterators.FilteredIterator}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{fagus.iterators.}}\sphinxbfcode{\sphinxupquote{FilteredIterator}}}{\emph{\DUrole{n}{obj}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}, \emph{\DUrole{n}{filter\_value}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}}, \emph{\DUrole{n}{filter\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{{\hyperref[\detokenize{fagus:fagus.Fil}]{\sphinxcrossref{Fil}}}}}, \emph{\DUrole{n}{filter\_index}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{0}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Iterator class that gives keys and values for any Collection (use optimal\_iterator() to initialize it)
\index{optimal\_iterator() (fagus.iterators.FilteredIterator static method)@\spxentry{optimal\_iterator()}\spxextra{fagus.iterators.FilteredIterator static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.iterators:fagus.iterators.FilteredIterator.optimal_iterator}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static\DUrole{w}{  }}}\sphinxbfcode{\sphinxupquote{optimal\_iterator}}}{\emph{\DUrole{n}{obj}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}, \emph{\DUrole{n}{filter\_value}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{filter\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Optional\DUrole{p}{{[}}{\hyperref[\detokenize{fagus:fagus.Fil}]{\sphinxcrossref{Fil}}}\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{None}}, \emph{\DUrole{n}{filter\_index}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{0}}}{{ $\rightarrow$ Iterator\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
This method returns the simplest possible Iterator to loop through a given object.

\sphinxAtStartPar
If no filter is present, either items or enumerate are called to loop through the keys, for sets … is put
as key for each value (as sets have no meaningful keys). If you additionally need filtering, this class is
initialized to support iteration on only the keys and values that pass the filter

\end{fulllineitems}

\index{\_\_init\_\_() (fagus.iterators.FilteredIterator method)@\spxentry{\_\_init\_\_()}\spxextra{fagus.iterators.FilteredIterator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.iterators:fagus.iterators.FilteredIterator.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{n}{obj}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Collection\DUrole{p}{{[}}Any\DUrole{p}{{]}}}}, \emph{\DUrole{n}{filter\_value}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}}, \emph{\DUrole{n}{filter\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{{\hyperref[\detokenize{fagus:fagus.Fil}]{\sphinxcrossref{Fil}}}}}, \emph{\DUrole{n}{filter\_index}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{0}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_iter\_\_() (fagus.iterators.FilteredIterator method)@\spxentry{\_\_iter\_\_()}\spxextra{fagus.iterators.FilteredIterator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.iterators:fagus.iterators.FilteredIterator.__iter__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_iter\_\_}}}{}{{ $\rightarrow$ {\hyperref[\detokenize{fagus.iterators:fagus.iterators.FilteredIterator}]{\sphinxcrossref{fagus.iterators.FilteredIterator}}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_next\_\_() (fagus.iterators.FilteredIterator method)@\spxentry{\_\_next\_\_()}\spxextra{fagus.iterators.FilteredIterator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.iterators:fagus.iterators.FilteredIterator.__next__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_next\_\_}}}{}{{ $\rightarrow$ Any}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_dict\_\_ (fagus.iterators.FilteredIterator attribute)@\spxentry{\_\_dict\_\_}\spxextra{fagus.iterators.FilteredIterator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.iterators:fagus.iterators.FilteredIterator.__dict__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_dict\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }mappingproxy(\{\textquotesingle{}\_\_module\_\_\textquotesingle{}: \textquotesingle{}fagus.iterators\textquotesingle{}, \textquotesingle{}\_\_doc\_\_\textquotesingle{}: \textquotesingle{}Iterator class that gives keys and values for any Collection (use optimal\_iterator() to initialize it)\textquotesingle{}, \textquotesingle{}optimal\_iterator\textquotesingle{}: \textless{}staticmethod(\textless{}function FilteredIterator.optimal\_iterator\textgreater{})\textgreater{}, \textquotesingle{}\_\_init\_\_\textquotesingle{}: \textless{}function FilteredIterator.\_\_init\_\_\textgreater{}, \textquotesingle{}\_\_iter\_\_\textquotesingle{}: \textless{}function FilteredIterator.\_\_iter\_\_\textgreater{}, \textquotesingle{}\_\_next\_\_\textquotesingle{}: \textless{}function FilteredIterator.\_\_next\_\_\textgreater{}, \textquotesingle{}\_\_dict\_\_\textquotesingle{}: \textless{}attribute \textquotesingle{}\_\_dict\_\_\textquotesingle{} of \textquotesingle{}FilteredIterator\textquotesingle{} objects\textgreater{}, \textquotesingle{}\_\_weakref\_\_\textquotesingle{}: \textless{}attribute \textquotesingle{}\_\_weakref\_\_\textquotesingle{} of \textquotesingle{}FilteredIterator\textquotesingle{} objects\textgreater{}, \textquotesingle{}\_\_annotations\_\_\textquotesingle{}: \{\textquotesingle{}match\_key\textquotesingle{}: \textquotesingle{}Callable{[}{[}Any, int, Any{]}, Tuple{[}bool, Optional{[}KFil{]}, int{]}{]}\textquotesingle{}\}\})}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_module\_\_ (fagus.iterators.FilteredIterator attribute)@\spxentry{\_\_module\_\_}\spxextra{fagus.iterators.FilteredIterator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.iterators:fagus.iterators.FilteredIterator.__module__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_module\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }\textquotesingle{}fagus.iterators\textquotesingle{}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_weakref\_\_ (fagus.iterators.FilteredIterator attribute)@\spxentry{\_\_weakref\_\_}\spxextra{fagus.iterators.FilteredIterator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.iterators:fagus.iterators.FilteredIterator.__weakref__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_weakref\_\_}}}
\pysigstopsignatures
\sphinxAtStartPar
list of weak references to the object (if defined)

\end{fulllineitems}


\end{fulllineitems}

\index{FagusIterator (class in fagus.iterators)@\spxentry{FagusIterator}\spxextra{class in fagus.iterators}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.iterators:fagus.iterators.FagusIterator}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{fagus.iterators.}}\sphinxbfcode{\sphinxupquote{FagusIterator}}}{\emph{\DUrole{n}{obj: Fagus}}, \emph{\DUrole{n}{max\_depth: int = 9223372036854775807}}, \emph{\DUrole{n}{filter\_: typing.Optional{[}Fil{]} = None}}, \emph{\DUrole{n}{fagus: bool = False}}, \emph{\DUrole{n}{iter\_fill: typing.Any = \textless{}class \textquotesingle{}fagus.utils.\_None\textquotesingle{}\textgreater{}}}, \emph{\DUrole{n}{select: typing.Optional{[}typing.Union{[}int}}, \emph{\DUrole{n}{typing.Iterable{[}typing.Any{]}{]}{]} = None}}, \emph{\DUrole{n}{iter\_nodes: bool = False}}, \emph{\DUrole{n}{copy: bool = False}}, \emph{\DUrole{n}{filter\_ends: bool = False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Iterator\sphinxhyphen{}class for Fagus to facilitate the complex iteration with filtering etc. in the tree\sphinxhyphen{}object

\sphinxAtStartPar
Internal \sphinxhyphen{} use Fagus.iter() to use this iterator on your object
\index{\_\_init\_\_() (fagus.iterators.FagusIterator method)@\spxentry{\_\_init\_\_()}\spxextra{fagus.iterators.FagusIterator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.iterators:fagus.iterators.FagusIterator.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{n}{obj: Fagus}}, \emph{\DUrole{n}{max\_depth: int = 9223372036854775807}}, \emph{\DUrole{n}{filter\_: typing.Optional{[}Fil{]} = None}}, \emph{\DUrole{n}{fagus: bool = False}}, \emph{\DUrole{n}{iter\_fill: typing.Any = \textless{}class \textquotesingle{}fagus.utils.\_None\textquotesingle{}\textgreater{}}}, \emph{\DUrole{n}{select: typing.Optional{[}typing.Union{[}int}}, \emph{\DUrole{n}{typing.Iterable{[}typing.Any{]}{]}{]} = None}}, \emph{\DUrole{n}{iter\_nodes: bool = False}}, \emph{\DUrole{n}{copy: bool = False}}, \emph{\DUrole{n}{filter\_ends: bool = False}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Internal function. Recursively iterates through Fagus\sphinxhyphen{}object

\sphinxAtStartPar
Initiate this iterator through Fagus.iter(), there the parameters are discussed as well.

\end{fulllineitems}

\index{\_\_dict\_\_ (fagus.iterators.FagusIterator attribute)@\spxentry{\_\_dict\_\_}\spxextra{fagus.iterators.FagusIterator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.iterators:fagus.iterators.FagusIterator.__dict__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_dict\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }mappingproxy(\{\textquotesingle{}\_\_module\_\_\textquotesingle{}: \textquotesingle{}fagus.iterators\textquotesingle{}, \textquotesingle{}\_\_doc\_\_\textquotesingle{}: \textquotesingle{}Iterator\sphinxhyphen{}class for Fagus to facilitate the complex iteration with filtering etc. in the tree\sphinxhyphen{}object\textbackslash{}n\textbackslash{}n    Internal \sphinxhyphen{} use Fagus.iter() to use this iterator on your object\textquotesingle{}, \textquotesingle{}\_\_init\_\_\textquotesingle{}: \textless{}function FagusIterator.\_\_init\_\_\textgreater{}, \textquotesingle{}\_\_iter\_\_\textquotesingle{}: \textless{}function FagusIterator.\_\_iter\_\_\textgreater{}, \textquotesingle{}\_\_next\_\_\textquotesingle{}: \textless{}function FagusIterator.\_\_next\_\_\textgreater{}, \textquotesingle{}skip\textquotesingle{}: \textless{}function FagusIterator.skip\textgreater{}, \textquotesingle{}\_\_dict\_\_\textquotesingle{}: \textless{}attribute \textquotesingle{}\_\_dict\_\_\textquotesingle{} of \textquotesingle{}FagusIterator\textquotesingle{} objects\textgreater{}, \textquotesingle{}\_\_weakref\_\_\textquotesingle{}: \textless{}attribute \textquotesingle{}\_\_weakref\_\_\textquotesingle{} of \textquotesingle{}FagusIterator\textquotesingle{} objects\textgreater{}, \textquotesingle{}\_\_annotations\_\_\textquotesingle{}: \{\}\})}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_iter\_\_() (fagus.iterators.FagusIterator method)@\spxentry{\_\_iter\_\_()}\spxextra{fagus.iterators.FagusIterator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.iterators:fagus.iterators.FagusIterator.__iter__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_iter\_\_}}}{}{{ $\rightarrow$ {\hyperref[\detokenize{fagus.iterators:fagus.iterators.FagusIterator}]{\sphinxcrossref{fagus.iterators.FagusIterator}}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_module\_\_ (fagus.iterators.FagusIterator attribute)@\spxentry{\_\_module\_\_}\spxextra{fagus.iterators.FagusIterator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.iterators:fagus.iterators.FagusIterator.__module__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_module\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }\textquotesingle{}fagus.iterators\textquotesingle{}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_weakref\_\_ (fagus.iterators.FagusIterator attribute)@\spxentry{\_\_weakref\_\_}\spxextra{fagus.iterators.FagusIterator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.iterators:fagus.iterators.FagusIterator.__weakref__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_weakref\_\_}}}
\pysigstopsignatures
\sphinxAtStartPar
list of weak references to the object (if defined)

\end{fulllineitems}

\index{\_\_next\_\_() (fagus.iterators.FagusIterator method)@\spxentry{\_\_next\_\_()}\spxextra{fagus.iterators.FagusIterator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.iterators:fagus.iterators.FagusIterator.__next__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_next\_\_}}}{}{{ $\rightarrow$ Any}}
\pysigstopsignatures
\end{fulllineitems}

\index{skip() (fagus.iterators.FagusIterator method)@\spxentry{skip()}\spxextra{fagus.iterators.FagusIterator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.iterators:fagus.iterators.FagusIterator.skip}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{skip}}}{\emph{\DUrole{n}{level}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ Any}}
\pysigstopsignatures
\sphinxAtStartPar
Skip the remaining iterations of a node at a given level if you’re done handling it
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{level}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} which node to skip. Level 0 is the root node, the next node is level 1 etc.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Whether to skip a copy of the node. Can be useful when the tree is modified during iteration

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
The node that was skipped

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}


\sphinxstepscope


\subsection{fagus.utils module}
\label{\detokenize{fagus.utils:module-fagus.utils}}\label{\detokenize{fagus.utils:fagus-utils-module}}\label{\detokenize{fagus.utils::doc}}\index{module@\spxentry{module}!fagus.utils@\spxentry{fagus.utils}}\index{fagus.utils@\spxentry{fagus.utils}!module@\spxentry{module}}
\sphinxAtStartPar
This module contains classes and functions used across the Fagus\sphinxhyphen{}library that didn’t fit in another module
\index{FagusOption (class in fagus.utils)@\spxentry{FagusOption}\spxextra{class in fagus.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.utils:fagus.utils.FagusOption}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{fagus.utils.}}\sphinxbfcode{\sphinxupquote{FagusOption}}}{\emph{name: str, default: typing.Any, type\_: type = \textless{}class \textquotesingle{}typing.\_AnyMeta\textquotesingle{}\textgreater{}, verify\_function: typing.Callable{[}{[}typing.Any{]}, bool{]} = \textless{}function FagusOption.\textless{}lambda\textgreater{}\textgreater{}, verify\_error\_msg: typing.Optional{[}str{]} = None}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Helper class to facilitate Fagus options.
\index{\_\_init\_\_() (fagus.utils.FagusOption method)@\spxentry{\_\_init\_\_()}\spxextra{fagus.utils.FagusOption method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.utils:fagus.utils.FagusOption.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{name: str, default: typing.Any, type\_: type = \textless{}class \textquotesingle{}typing.\_AnyMeta\textquotesingle{}\textgreater{}, verify\_function: typing.Callable{[}{[}typing.Any{]}, bool{]} = \textless{}function FagusOption.\textless{}lambda\textgreater{}\textgreater{}, verify\_error\_msg: typing.Optional{[}str{]} = None}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Initializes FagusOption with the given parameters
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} The name of the option.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default}} (\sphinxstyleliteralemphasis{\sphinxupquote{Any}}) \textendash{} The default value for the option if it hasn’t been set explicitly at class\sphinxhyphen{} or instance
level or in the function.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{type\_}} (\sphinxstyleliteralemphasis{\sphinxupquote{type}}) \textendash{} The expected type for the input to the option. Defaults to Any. In case the provided
input to the option doesn’t have the type indicated here, an error\sphinxhyphen{}message is thrown.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{verify\_function}} (\sphinxstyleliteralemphasis{\sphinxupquote{Callable}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{Any}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} A function to verify the input value to the option. Returns a bool
whether the input was valid or not. An error is thrown if the input isn’t valid with the error message
defined in verify\_error\_message. Defaults to \sphinxtitleref{lambda x: True}, meaning that any input is valid

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{verify\_error\_msg}} (\sphinxstyleliteralemphasis{\sphinxupquote{Optional}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} An error message to display when the verify\_function returns False.
Defaults to f”\{value\} is not a valid value for \{self.name\}”

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{verify() (fagus.utils.FagusOption method)@\spxentry{verify()}\spxextra{fagus.utils.FagusOption method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.utils:fagus.utils.FagusOption.verify}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{verify}}}{\emph{\DUrole{n}{value}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}}{{ $\rightarrow$ Any}}
\pysigstopsignatures
\sphinxAtStartPar
Verifies if the input value to the option has the correct type and passes the validation function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value}} (\sphinxstyleliteralemphasis{\sphinxupquote{Any}}) \textendash{} The option input value to be verified.

\item[{Raises}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} If the input value is not of the expected type.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} If the input value does not pass the custom validation function.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
The input value if it meets the requirements.

\item[{Return type}] \leavevmode
\sphinxAtStartPar
Any

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_dict\_\_ (fagus.utils.FagusOption attribute)@\spxentry{\_\_dict\_\_}\spxextra{fagus.utils.FagusOption attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.utils:fagus.utils.FagusOption.__dict__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_dict\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }mappingproxy(\{\textquotesingle{}\_\_module\_\_\textquotesingle{}: \textquotesingle{}fagus.utils\textquotesingle{}, \textquotesingle{}\_\_doc\_\_\textquotesingle{}: \textquotesingle{}Helper class to facilitate Fagus options.\textquotesingle{}, \textquotesingle{}\_\_init\_\_\textquotesingle{}: \textless{}function FagusOption.\_\_init\_\_\textgreater{}, \textquotesingle{}verify\textquotesingle{}: \textless{}function FagusOption.verify\textgreater{}, \textquotesingle{}\_\_dict\_\_\textquotesingle{}: \textless{}attribute \textquotesingle{}\_\_dict\_\_\textquotesingle{} of \textquotesingle{}FagusOption\textquotesingle{} objects\textgreater{}, \textquotesingle{}\_\_weakref\_\_\textquotesingle{}: \textless{}attribute \textquotesingle{}\_\_weakref\_\_\textquotesingle{} of \textquotesingle{}FagusOption\textquotesingle{} objects\textgreater{}, \textquotesingle{}\_\_annotations\_\_\textquotesingle{}: \{\}\})}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_module\_\_ (fagus.utils.FagusOption attribute)@\spxentry{\_\_module\_\_}\spxextra{fagus.utils.FagusOption attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.utils:fagus.utils.FagusOption.__module__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_module\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }\textquotesingle{}fagus.utils\textquotesingle{}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_weakref\_\_ (fagus.utils.FagusOption attribute)@\spxentry{\_\_weakref\_\_}\spxextra{fagus.utils.FagusOption attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.utils:fagus.utils.FagusOption.__weakref__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_weakref\_\_}}}
\pysigstopsignatures
\sphinxAtStartPar
list of weak references to the object (if defined)

\end{fulllineitems}


\end{fulllineitems}

\index{EllipsisType (in module fagus.utils)@\spxentry{EllipsisType}\spxextra{in module fagus.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.utils:fagus.utils.EllipsisType}}
\pysigstartsignatures
\pysigline{\sphinxcode{\sphinxupquote{fagus.utils.}}\sphinxbfcode{\sphinxupquote{EllipsisType}}}
\pysigstopsignatures
\sphinxAtStartPar
TypeAlias to represent type(…), which cannot be done in a nicer way prior to Python 3.10

\end{fulllineitems}

\index{OptStr (in module fagus.utils)@\spxentry{OptStr}\spxextra{in module fagus.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.utils:fagus.utils.OptStr}}
\pysigstartsignatures
\pysigline{\sphinxcode{\sphinxupquote{fagus.utils.}}\sphinxbfcode{\sphinxupquote{OptStr}}}
\pysigstopsignatures
\sphinxAtStartPar
TypeAlias for FagusOption requiring a str. Specify custom value as str, or keep … to use FagusOption default.

\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{Union}}{[}\sphinxcode{\sphinxupquote{str}}, \sphinxcode{\sphinxupquote{ellipsis}}{]}

\end{fulllineitems}

\index{OptBool (in module fagus.utils)@\spxentry{OptBool}\spxextra{in module fagus.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.utils:fagus.utils.OptBool}}
\pysigstartsignatures
\pysigline{\sphinxcode{\sphinxupquote{fagus.utils.}}\sphinxbfcode{\sphinxupquote{OptBool}}}
\pysigstopsignatures
\sphinxAtStartPar
TypeAlias for FagusOption requiring a bool. Specify custom value as bool, or keep … to use FagusOption default.

\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{Union}}{[}\sphinxcode{\sphinxupquote{bool}}, \sphinxcode{\sphinxupquote{ellipsis}}{]}

\end{fulllineitems}

\index{OptInt (in module fagus.utils)@\spxentry{OptInt}\spxextra{in module fagus.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.utils:fagus.utils.OptInt}}
\pysigstartsignatures
\pysigline{\sphinxcode{\sphinxupquote{fagus.utils.}}\sphinxbfcode{\sphinxupquote{OptInt}}}
\pysigstopsignatures
\sphinxAtStartPar
TypeAlias for FagusOption requiring an int. Specify custom value as int, or keep … to use FagusOption default.

\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{Union}}{[}\sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{ellipsis}}{]}

\end{fulllineitems}

\index{OptAny (in module fagus.utils)@\spxentry{OptAny}\spxextra{in module fagus.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.utils:fagus.utils.OptAny}}
\pysigstartsignatures
\pysigline{\sphinxcode{\sphinxupquote{fagus.utils.}}\sphinxbfcode{\sphinxupquote{OptAny}}}
\pysigstopsignatures
\sphinxAtStartPar
TypeAlias for FagusOption taking any object. Specify custom value, or keep … to use FagusOption default.

\end{fulllineitems}


\sphinxstepscope


\chapter{Changelog}
\label{\detokenize{CHANGELOG:changelog}}\label{\detokenize{CHANGELOG::doc}}
\sphinxAtStartPar
\sphinxstylestrong{2023\sphinxhyphen{}08\sphinxhyphen{}19 1.1.0 Fixed strong typing and added more documentation}
\begin{itemize}
\item {}
\sphinxAtStartPar
Added mypy as a build\sphinxhyphen{}dependency to ensure correct and strong typing in the whole library. Consequences:
\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{TypeAlias}} was added to make Fagus Options more clear.

\item {}
\sphinxAtStartPar
Now, \sphinxcode{\sphinxupquote{OptStr}}, \sphinxcode{\sphinxupquote{OptBool}}, \sphinxcode{\sphinxupquote{OptInt}} and \sphinxcode{\sphinxupquote{OptAny}} clearly declare what the … means, and make it strongly typed.

\end{itemize}

\item {}
\sphinxAtStartPar
Added external dependency \sphinxcode{\sphinxupquote{type\_extensions \textgreater{}= 3.74}} for Python \textless{} 3.10
\begin{itemize}
\item {}
\sphinxAtStartPar
This was necessary to support \sphinxcode{\sphinxupquote{TypeAlias}}. However, with \sphinxcode{\sphinxupquote{\textgreater{}= 3.74}} which was released in June 2019, this dependency is kept as open and forgiving as possible.

\item {}
\sphinxAtStartPar
For Python \textgreater{}= 3.10, \sphinxcode{\sphinxupquote{Fagus}} still has no external dependencies.

\end{itemize}

\item {}
\sphinxAtStartPar
Renamed the \sphinxcode{\sphinxupquote{FagusOption}} \sphinxcode{\sphinxupquote{value\_split}} to \sphinxcode{\sphinxupquote{path\_split}} which is more descriptive of what it is doing.

\item {}
\sphinxAtStartPar
More documentation in README: now all the different \sphinxcode{\sphinxupquote{FagusOption}}s are documented properly, as well as the basic \sphinxcode{\sphinxupquote{set()}}, \sphinxcode{\sphinxupquote{get()}}, \sphinxcode{\sphinxupquote{update()}}, \sphinxcode{\sphinxupquote{add()}}, \sphinxcode{\sphinxupquote{insert()}} and \sphinxcode{\sphinxupquote{extend()}}\sphinxhyphen{}functions.

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{2022\sphinxhyphen{}05\sphinxhyphen{}13 1.0.1 Release of Fagus on GitHub and ReadTheDocs}

\sphinxAtStartPar
Now. Finally. The documentation is still not completely ready but it’s time to get some feedback from the community.

\sphinxAtStartPar
\sphinxstylestrong{2022\sphinxhyphen{}04\sphinxhyphen{}05 1.0.0 Renaming to Fagus}

\sphinxAtStartPar
Checking GitHub I found that there already were several other libraries and programs having TreeO as a name which I had chosen originally. I then found another (much cooler) name which wasn’t in use yet.

\sphinxAtStartPar
\sphinxstylestrong{2022\sphinxhyphen{}04 0.9.0 Release getting closer}

\sphinxAtStartPar
Development has been ongoing for almost a year. Documentation and testing takes time, but it is absolutely necessary for a library like this. Finally moving away from two Python\sphinxhyphen{}files (one for tests and one for the lib) to a proper \sphinxcode{\sphinxupquote{poetry}}\sphinxhyphen{}project, starting to implement sphinx to parse the docstrings that had been written earlier.

\sphinxAtStartPar
\sphinxstylestrong{2021\sphinxhyphen{}06 0.1.0 First idea for TreeO}

\sphinxAtStartPar
Development starts, the idea to this was born writing my Bachelor’s thesis where I felt that constantly writing \sphinxcode{\sphinxupquote{.get("a", \{\}).get("b", \{\}).get("c", \{\})}} was too annoying to go on with.

\sphinxstepscope


\chapter{Contributing to Fagus}
\label{\detokenize{CONTRIBUTING:contributing-to-fagus}}\label{\detokenize{CONTRIBUTING::doc}}
\sphinxAtStartPar
First off, welcome and thank you for taking the time to contribute to Fagus! Any contribution, big or small, is welcome to make Fagus more useful such that more people can benefit from it.

\sphinxAtStartPar
The following is a set of guidelines for contribution to Fagus, which is hosted by the \sphinxhref{https://github.com/treeorg}{treeorg} organisation on GitHub. They are mostly guidelines, not rules. All of this can be discussed \sphinxhyphen{} use your best judgement, and feel free to propose changes to this document in a pull request.


\section{Table of contents}
\label{\detokenize{CONTRIBUTING:table-of-contents}}
\sphinxAtStartPar
{\hyperref[\detokenize{CONTRIBUTING:fagus-principles}]{\sphinxcrossref{\DUrole{std,std-doc}{Fagus Principles}}}}

\sphinxAtStartPar
{\hyperref[\detokenize{CONTRIBUTING:how-can-i-contribute}]{\sphinxcrossref{\DUrole{std,std-doc}{How Can I Contribute?}}}}
\begin{itemize}
\item {}
\sphinxAtStartPar
{\hyperref[\detokenize{CONTRIBUTING:reporting-bugs}]{\sphinxcrossref{\DUrole{std,std-doc}{Reporting Bugs}}}}

\item {}
\sphinxAtStartPar
{\hyperref[\detokenize{CONTRIBUTING:requesting-new-features}]{\sphinxcrossref{\DUrole{std,std-doc}{Requesting New Features}}}}

\end{itemize}

\sphinxAtStartPar
{\hyperref[\detokenize{CONTRIBUTING:developing-fagus}]{\sphinxcrossref{\DUrole{std,std-doc}{Developing Fagus}}}}
\begin{itemize}
\item {}
\sphinxAtStartPar
{\hyperref[\detokenize{CONTRIBUTING:software-dependencies-for-development}]{\sphinxcrossref{\DUrole{std,std-doc}{Software Dependencies for Development}}}}

\item {}
\sphinxAtStartPar
{\hyperref[\detokenize{CONTRIBUTING:code-styling-guidelines}]{\sphinxcrossref{\DUrole{std,std-doc}{Code Styling Guidelines}}}}

\item {}
\sphinxAtStartPar
{\hyperref[\detokenize{CONTRIBUTING:setting-up-a-local-fagus-developing-environment}]{\sphinxcrossref{\DUrole{std,std-doc}{Setting Up A Local Fagus Developing Environment}}}}

\item {}
\sphinxAtStartPar
{\hyperref[\detokenize{CONTRIBUTING:submitting-pull-requests-for-fagus}]{\sphinxcrossref{\DUrole{std,std-doc}{Submitting Pull Requests For Fagus}}}}

\end{itemize}


\section{Fagus Principles}
\label{\detokenize{CONTRIBUTING:fagus-principles}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
\sphinxstylestrong{No external dependencies}: Fagus runs on native Python without 3rd party dependencies.

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Documented}: All functions / modules / arguments / classes have docstrings.

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Tested}: All the functions shall have tests for as many edge cases as possible. It’s never possible to imagine all edge\sphinxhyphen{}cases, but if e.g. a bug is fixed which there is no test for, a new test case should be added to prevent the bug from being reintroduced.

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Consistent}: Fagus’s function arguments follow a common structure to be as consistent as possible.

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Static and Instance}: All functions in Fagus (except from \_\_internals\_\_) should be able to run static \sphinxcode{\sphinxupquote{Fagus.function(obj)}} or at a Fagus\sphinxhyphen{}instance \sphinxcode{\sphinxupquote{obj = Fagus(); obj.function()}}.

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Simple and efficient}: If you have suggestions on how to make the code more efficient, feel free to submit.

\end{enumerate}


\section{How Can I Contribute?}
\label{\detokenize{CONTRIBUTING:how-can-i-contribute}}

\subsection{Reporting Bugs}
\label{\detokenize{CONTRIBUTING:reporting-bugs}}
\sphinxAtStartPar
This section guides you through submitting a bug report for Fagus. Following these guidelines helps maintainers and the community understand your report, reproduce the behavior, and find related reports.


\subsubsection{Before Submitting A Bug Report}
\label{\detokenize{CONTRIBUTING:before-submitting-a-bug-report}}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{Check the \sphinxhref{https://github.com/treeorg/Fagus/discussions/categories/q-a}{FAQ} and the \sphinxhref{https://github.com/treeorg/Fagus/discussions}{discussions}} for a list of common questions and problems.

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Check \sphinxhref{https://github.com/treeorg/Fagus/issues}{issues} to see if your issue has already been reported}
\begin{itemize}
\item {}
\sphinxAtStartPar
If it has been reported \sphinxstylestrong{and the issue is still open}, add a comment to the existing issue instead of opening a new one.

\item {}
\sphinxAtStartPar
If you find a \sphinxstylestrong{Closed} issue that seems like it is the same thing that you’re experiencing, open a new issue and include a link to the original issue in the body of your new one.

\end{itemize}

\end{itemize}


\subsubsection{How Do I Submit A (Good) Bug Report?}
\label{\detokenize{CONTRIBUTING:how-do-i-submit-a-good-bug-report}}
\sphinxAtStartPar
Bugs are tracked as \sphinxhref{https://guides.github.com/features/issues/}{GitHub issues}. When you are creating a bug report, please {\hyperref[\detokenize{CONTRIBUTING:how-do-i-submit-a-good-bug-report}]{\sphinxcrossref{\DUrole{std,std-doc}{include as many details as possible (in particular test\sphinxhyphen{}data)}}}}. Fill out \sphinxhref{https://github.com/treeorg/Fagus/issues/new?template=bug\_report.md}{the required template}, the information it asks for helps us resolve issues faster.


\subsection{Requesting New Features}
\label{\detokenize{CONTRIBUTING:requesting-new-features}}
\sphinxAtStartPar
This section guides you through submitting an enhancement suggestion for Fagus, including completely new features and minor improvements to existing functionality. Following these guidelines helps maintainers and the community understand your suggestion and find related suggestions.


\subsubsection{Before Submitting A Feature Request}
\label{\detokenize{CONTRIBUTING:before-submitting-a-feature-request}}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{Check the \sphinxhref{https://github.com/treeorg/Fagus/discussions/categories/q-a}{FAQ} and the \sphinxhref{https://github.com/treeorg/Fagus/discussions}{discussions}} for a list of common questions and problems. Probably there already is a solution for your feature\sphinxhyphen{}request?

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Check \sphinxhref{https://github.com/treeorg/Fagus/issues}{issues} to see if your feature request has already been reported}
\begin{itemize}
\item {}
\sphinxAtStartPar
If it has been reported \sphinxstylestrong{and the feature request is still open}, add a comment to the existing issue instead of opening a new one. You can also give it a like to get it prioritized.

\item {}
\sphinxAtStartPar
If you find a \sphinxstylestrong{Closed} feature request that seems like it is the same thing that you would like to get added, you can create a new one and include a link to the old one. If many people would like to have a new feature it is more likely to get prioritized.

\end{itemize}

\end{itemize}


\subsubsection{How Do I Submit A (Good) Feature Request?}
\label{\detokenize{CONTRIBUTING:how-do-i-submit-a-good-feature-request}}
\sphinxAtStartPar
Feature requests are tracked as \sphinxhref{https://guides.github.com/features/issues/}{GitHub issues}. When you are creating a feature request, please {\hyperref[\detokenize{CONTRIBUTING:how-do-i-submit-a-good-feature-request}]{\sphinxcrossref{\DUrole{std,std-doc}{include as many details as possible (in particular test\sphinxhyphen{}data)}}}}. Fill out \sphinxhref{https://github.com/treeorg/Fagus/issues/new?template=feature\_request.md}{the required template}, the information it asks for helps us to better judge and understand your suggestion.


\section{Developing Fagus}
\label{\detokenize{CONTRIBUTING:developing-fagus}}
\sphinxAtStartPar
This section shows you how you can set up a local environment to test and develop Fagus, and finally how you can make your contribution.


\subsection{Software Dependencies For Development}
\label{\detokenize{CONTRIBUTING:software-dependencies-for-development}}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxhref{https://www.python.org/}{Python} (at least 3.6.2)

\item {}
\sphinxAtStartPar
\sphinxhref{https://python-poetry.org}{Poetry} for dependency management and deployment (creating packages for PyPi), instructions are found in {\hyperref[\detokenize{CONTRIBUTING:setting-up-a-local-fagus-developing-environment}]{\sphinxcrossref{\DUrole{std,std-doc}{installation steps}}}}

\item {}
\sphinxAtStartPar
\sphinxhref{https://git-scm.com/}{Git} to checkout this repo

\item {}
\sphinxAtStartPar
An IDE, I used \sphinxhref{https://www.jetbrains.com/pycharm/download/}{Intellij PyCharm Community}. Not mandatory, but I found it handy to see how the data is modified in the debugger.

\item {}
\sphinxAtStartPar
Fagus itself has no external dependencies, but some packages are used to smoothen the development process. They are installed and set up through poetry, check \sphinxhref{https://github.com/treeorg/Fagus/blob/main/pyproject.toml}{pyproject.toml} or {\hyperref[\detokenize{CONTRIBUTING:code-styling-guidelines}]{\sphinxcrossref{\DUrole{std,std-doc}{Code Styling Rules}}}} for a list.

\end{itemize}


\subsection{Code Styling Guidelines}
\label{\detokenize{CONTRIBUTING:code-styling-guidelines}}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{Code formatting}: The code is formatted using the \sphinxhref{https://peps.python.org/pep-0008/}{PEP\sphinxhyphen{}8\sphinxhyphen{}Standard}, but with a line length of 120 characters.
\begin{itemize}
\item {}
\sphinxAtStartPar
The code is automatically formatted correctly by using \sphinxhref{https://github.com/psf/black}{black}. Run \sphinxcode{\sphinxupquote{black .}} to ensure correct formatting for all py\sphinxhyphen{}files in the repo.

\item {}
\sphinxAtStartPar
The PEP\sphinxhyphen{}8\sphinxhyphen{}rules are verified through \sphinxhref{https://flake8.pycqa.org/en/latest/}{flake8}. This tool only shows what is wrong \sphinxhyphen{} you’ll have to fix it yourself.

\end{itemize}

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Docstrings}: All public functions in Fagus have docstrings following the \sphinxhref{https://google.github.io/styleguide/pyguide.html}{Google Python Style Guide}

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Formatting commit\sphinxhyphen{}messages}: \sphinxhref{https://commitizen-tools.github.io/commitizen/}{commitizen} is used to make sure that commit\sphinxhyphen{}messages follow a common style

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Pre\sphinxhyphen{}commit checks}: \sphinxhref{https://pre-commit.com/}{pre\sphinxhyphen{}commit} is used to ensure that the code changes have test\sphinxhyphen{}coverage, are formatted correctly etc. It runs black, flake8, unittests and a lot of other checks prior to accepting a commit.

\end{itemize}


\subsection{Setting Up A Local Fagus Developing Environment}
\label{\detokenize{CONTRIBUTING:setting-up-a-local-fagus-developing-environment}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
Install \sphinxhref{https://www.python.org/downloads/}{Python} and \sphinxhref{https://git-scm.com/}{Git}

\item {}
\sphinxAtStartPar
Checkout the repository: \sphinxcode{\sphinxupquote{git checkout https://github.com/treeorg/Fagus.git; cd Fagus}}

\item {}
\sphinxAtStartPar
Instructions how to install poetry can be found \sphinxhref{https://python-poetry.org/docs/}{here}
\begin{itemize}
\item {}
\sphinxAtStartPar
you might have to reopen your terminal after installing poetry (or run \sphinxcode{\sphinxupquote{source \textasciitilde{}/.bashrc}} on Linux)

\end{itemize}

\item {}
\sphinxAtStartPar
Run \sphinxcode{\sphinxupquote{poetry shell}} to open a terminal that is set up with the development tools for Fagus.
\begin{itemize}
\item {}
\sphinxAtStartPar
check if you can now run this command without getting errors: \sphinxcode{\sphinxupquote{poetry shell}}

\item {}
\sphinxAtStartPar
if the \sphinxcode{\sphinxupquote{poetry}}\sphinxhyphen{}command is not found, you might have to add \sphinxcode{\sphinxupquote{eval "\$(pyenv init \sphinxhyphen{}\sphinxhyphen{}path)"}} to your \sphinxcode{\sphinxupquote{.bashrc}} (on Linux)

\item {}
\sphinxAtStartPar
if you have problems setting this up, just ask a \sphinxhref{https://github.com/treeorg/Fagus/discussions/categories/q-a}{question}, we can later include the problem and the solution we found into this guide

\end{itemize}

\item {}
\sphinxAtStartPar
Install the project and developing dependencies: \sphinxcode{\sphinxupquote{poetry install}}

\item {}
\sphinxAtStartPar
If you use an IDE, you can now open your project there. If it has a poetry mode, use that mode \sphinxhyphen{} \sphinxcode{\sphinxupquote{poetry shell}} will then be executed automatically in the terminal of your IDE.

\end{enumerate}


\subsection{Submitting Pull Requests for Fagus}
\label{\detokenize{CONTRIBUTING:submitting-pull-requests-for-fagus}}
\sphinxAtStartPar
If it hasn’t run in your console yet, run \sphinxcode{\sphinxupquote{poetry shell}} to get all the development dependencies and some new commands available in your console.


\subsubsection{Tests}
\label{\detokenize{CONTRIBUTING:tests}}
\sphinxAtStartPar
You can run \sphinxcode{\sphinxupquote{python3 \sphinxhyphen{}m unittest discover}} to run all the tests in \sphinxcode{\sphinxupquote{./tests}}. If you add new functionality in your pull\sphinxhyphen{}request, make sure that the tests still work, or update them if necessary. As this is a generic library, it’s very important that all the functions have test coverage for as many edge cases as possible.


\subsubsection{Committing using pre\sphinxhyphen{}commit and commitizen}
\label{\detokenize{CONTRIBUTING:committing-using-pre-commit-and-commitizen}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
Make sure all your changes are staged for commit: \sphinxcode{\sphinxupquote{git add \sphinxhyphen{}A}} includes all of your changes

\item {}
\sphinxAtStartPar
Dry\sphinxhyphen{}run the pre\sphinxhyphen{}commit\sphinxhyphen{}checks: \sphinxcode{\sphinxupquote{pre\sphinxhyphen{}commit}}
\begin{itemize}
\item {}
\sphinxAtStartPar
Some errors like missing trailing whitespace or wrong formatting are automatically corrected.

\item {}
\sphinxAtStartPar
If there are errors in the tests, or flake8 observes problems, you’ll have to go back in the code and fix the problems.

\end{itemize}

\item {}
\sphinxAtStartPar
Repeat Step 1 and 2 until all the tests are green.

\item {}
\sphinxAtStartPar
Use \sphinxcode{\sphinxupquote{git cz c}} to commit using commitizen.
\begin{itemize}
\item {}
\sphinxAtStartPar
If the pre\sphinxhyphen{}commit\sphinxhyphen{}checks fail, your commit is rejected and after fixing the issues you’d have to retype the commit\sphinxhyphen{}message. To not have that problem, do step 3 beforehand.

\end{itemize}

\end{enumerate}


\subsubsection{Releasing A New Fagus Package on PyPi}
\label{\detokenize{CONTRIBUTING:releasing-a-new-fagus-package-on-pypi}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
Update \sphinxcode{\sphinxupquote{Changelog.md}} with a description of the changes you have made.

\item {}
\sphinxAtStartPar
Manually run \sphinxcode{\sphinxupquote{package.py}} from the project’s root folder using the following command
\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{python3 package update \sphinxhyphen{}bdlp \sphinxhyphen{}v \textless{}version number or increment\textgreater{}}}

\item {}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{b}} builds the package for later upload to PyPi

\item {}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{d}} updates the documentation files (see if this runs properly, if it does it will work on sphinx as well)

\item {}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{l}} builds a pdf\sphinxhyphen{}documentation file

\item {}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{p}} runs the pre\sphinxhyphen{}commit checks to ensure that everything is alright before publishing

\item {}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{v}} requires a version number or increment. Either manually put a version number here, or use one of the following increments:
\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{Major}: For backwards incompatible changes (e.g. removing support for Python 3.6)

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Minor}: Adds functionality in a backwards compatible way

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Patch}: Fixes bugs in a backwards compatible way

\end{itemize}

\end{itemize}

\item {}
\sphinxAtStartPar
Make a commit including all the changes made in step 1 and 2, and repeat them if necessary. Check the following before committing:
\begin{itemize}
\item {}
\sphinxAtStartPar
Ensure that the version number mentioned in \sphinxcode{\sphinxupquote{CHANGELOG.md}} corresponds to the one that is now present in \sphinxcode{\sphinxupquote{pyproject.toml}}. If it is not equal, update \sphinxcode{\sphinxupquote{CHANGELOG.md}} accordingly, and rerun step 2 but without the version\sphinxhyphen{}parameter \sphinxcode{\sphinxupquote{\sphinxhyphen{}v}}.

\item {}
\sphinxAtStartPar
Go through the errors and warnings which are thrown especially while the documentation is created in step 2.
\begin{itemize}
\item {}
\sphinxAtStartPar
This warning is alright: \sphinxcode{\sphinxupquote{WARNING: more than one target found for cross\sphinxhyphen{}reference \textquotesingle{}Fil\textquotesingle{}: fagus.Fil, fagus.filters.Fil}}

\item {}
\sphinxAtStartPar
Fix all other warnings / errors.

\end{itemize}

\end{itemize}

\item {}
\sphinxAtStartPar
Create a Pull Request for the changes back to the \sphinxcode{\sphinxupquote{main}}\sphinxhyphen{}branch, this is easiest to do directly on \sphinxhref{https://github.com/treeorg/Fagus/pulls}{GitHub}. Use the title and text from \sphinxcode{\sphinxupquote{CHANGELOG.md}} for the title and description of the PR.

\item {}
\sphinxAtStartPar
Run \sphinxcode{\sphinxupquote{poetry publish}} to publish the new version to \sphinxcode{\sphinxupquote{PyPi}}.
\begin{itemize}
\item {}
\sphinxAtStartPar
If it doesn’t work, make sure that you are allowed to publish to \sphinxhref{https://pypi.org/project/fagus/}{Fagus}.

\item {}
\sphinxAtStartPar
Set up an access token in your PyPi account \sphinxhref{https://pypi.org/manage/account/}{here}.

\item {}
\sphinxAtStartPar
Then run \sphinxcode{\sphinxupquote{poetry config pypi\sphinxhyphen{}token.pypi \textless{}my\sphinxhyphen{}token\textgreater{}}} documented \sphinxhref{https://python-poetry.org/docs/repositories/\#configuring-credentials}{here} to add the token to your \sphinxcode{\sphinxupquote{poetry}}\sphinxhyphen{}configuration, \sphinxcode{\sphinxupquote{poetry publish}} should now work.

\end{itemize}

\end{enumerate}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{f}
\item\relax\sphinxstyleindexentry{fagus}\sphinxstyleindexpageref{fagus:\detokenize{module-fagus}}
\item\relax\sphinxstyleindexentry{fagus.fagus}\sphinxstyleindexpageref{fagus.fagus:\detokenize{module-fagus.fagus}}
\item\relax\sphinxstyleindexentry{fagus.filters}\sphinxstyleindexpageref{fagus.filters:\detokenize{module-fagus.filters}}
\item\relax\sphinxstyleindexentry{fagus.iterators}\sphinxstyleindexpageref{fagus.iterators:\detokenize{module-fagus.iterators}}
\item\relax\sphinxstyleindexentry{fagus.utils}\sphinxstyleindexpageref{fagus.utils:\detokenize{module-fagus.utils}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
