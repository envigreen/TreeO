%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}


\usepackage{lmodern}


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{2}



\title{Fagus}
\date{May 17, 2022}
\release{1.0.1}
\author{Lukas Neuenschwander}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxstepscope


\chapter{ISC License}
\label{\detokenize{LICENSE:isc-license}}\label{\detokenize{LICENSE::doc}}
\sphinxAtStartPar
Copyright (c) 2022 Lukas Neuenschwander

\sphinxAtStartPar
Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies.

\sphinxAtStartPar
THE SOFTWARE IS PROVIDED “AS IS” AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

\sphinxstepscope


\chapter{README}
\label{\detokenize{README:readme}}\label{\detokenize{README::doc}}
\sphinxAtStartPar
These days most data is converted to and from \sphinxcode{\sphinxupquote{json}} and \sphinxcode{\sphinxupquote{yaml}} while it is sent back and forth to and from API’s. Often this data is deeply nested. \sphinxcode{\sphinxupquote{Fagus}} is a Python\sphinxhyphen{}library that makes it easier to work with nested dicts and lists. It allows you to traverse and edit these tree\sphinxhyphen{}objects with simple function\sphinxhyphen{}calls that handle the most common errors and exceptions internally. The name fagus is actually the latin name for the genus of beech\sphinxhyphen{}trees.


\section{Code and tests ready, documentation still WORK IN PROGRESS}
\label{\detokenize{README:code-and-tests-ready-documentation-still-work-in-progress}}
\sphinxAtStartPar
This documentation is still Work in Progress. I have some more ideas for features, but most of the coding is done. The code is tested as good as possible, but of course there still might be bugs as this library has just been released. Just report them so we get them away ;). Even though this README is not done yet, you should be able to use most of the functions based on the docstrings and some trial and error. Just ask questions \sphinxhref{https://github.com/treeorg/Fagus/discussions/categories/q-a}{here} if sth is unclear. The documentation will be filled in and completed as soon as possible.

\sphinxAtStartPar
\sphinxstylestrong{HAVE FUN!}


\section{Basic principles}
\label{\detokenize{README:basic-principles}}

\subsection{Introduction \textendash{} What it solves}
\label{\detokenize{README:introduction-what-it-solves}}
\sphinxAtStartPar
Imagine you want to fetch values from a nested dict like shown below:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{d1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{6}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} prints 2, so far so good}
\PYG{g+go}{2}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} fails, because b3 doesn\PYGZsq{}t exist}
\PYG{g+gt}{Traceback (most recent call last):}
 \PYG{c}{...}
\PYG{g+gr}{KeyError}: \PYG{n}{\PYGZsq{}b3\PYGZsq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The problem is that the consecutive square brackets fail if one of the nodes doesn’t exist. There are ways around, like writing \sphinxcode{\sphinxupquote{a.get("a1", \{\}).get("b3", \{\}).get("c2")}} or surrounding each of these statements with \sphinxcode{\sphinxupquote{try\sphinxhyphen{}except}}, but both are hard to maintain and verbose. Below you can see how \sphinxcode{\sphinxupquote{Fagus}} can help to resolve this:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{fagus} \PYG{k+kn}{import} \PYG{n}{Fagus}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{Fagus}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} None, as this key doesn\PYGZsq{}t exist in a}
\PYG{g+go}{None}
\end{sphinxVerbatim}

\sphinxAtStartPar
As you can see, now only one function call is needed to fetch the value from \sphinxcode{\sphinxupquote{a}}. If one of the keys doesn’t exist, a default value is returned. In this case no default value was specified, so \sphinxcode{\sphinxupquote{None}} is returned.

\sphinxAtStartPar
The whole \sphinxcode{\sphinxupquote{Fagus}} library is built around these principles. It provides:
\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{Simple functions}: replacing tedious code that is hard to maintain and error prone

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Few exceptions}: Rather than raising a lot of exceptions, \sphinxcode{\sphinxupquote{Fagus}} does what is most likely the programmer’s intention.

\end{itemize}


\subsection{The path\sphinxhyphen{}parameter}
\label{\detokenize{README:the-path-parameter}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Fagus}} is built around the concept of a Mapping or dict, where there are keys that are used to refer to values. For lists, the indices are used as keys. In opposition to a simple dict, in \sphinxcode{\sphinxupquote{Fagus}} the key can consist of multiple values \textendash{} one for each layer.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{6}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{fg}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{]}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Fagus}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}v1\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Fagus}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2 1 fg}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}v2\PYGZsq{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{Line 3}: The path\sphinxhyphen{}parameter is the tuple in the second argument of the get\sphinxhyphen{}function. The first and third element in that tuple are list\sphinxhyphen{}indices, whereas the second and fourth element are dict\sphinxhyphen{}keys.

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Line 5}: In many cases, the dict\sphinxhyphen{}keys that are traversed are strings. For convenience, it’s also possible to provide the whole path\sphinxhyphen{}parameter as one string that is split up into the different keys. In the example above, \sphinxcode{\sphinxupquote{" "}} is used to split the path\sphinxhyphen{}string, this can be customized using \sphinxcode{\sphinxupquote{value\_split}}.

\end{itemize}


\subsection{Static and instance usage}
\label{\detokenize{README:static-and-instance-usage}}
\sphinxAtStartPar
All functions in \sphinxcode{\sphinxupquote{Fagus}} can be used statically, or on a \sphinxcode{\sphinxupquote{Fagus}}\sphinxhyphen{}instance, so the following two calls of \sphinxcode{\sphinxupquote{get()}} give the same result:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{6}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{e}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{fg}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{]}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Fagus}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2 0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}e\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b} \PYG{o}{=} \PYG{n}{Fagus}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2 0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}e\PYGZsq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The first call of \sphinxcode{\sphinxupquote{get()}} in line 3 is static, as we have seen before. No \sphinxcode{\sphinxupquote{Fagus}} instance is required, the object \sphinxcode{\sphinxupquote{a}} is just passed as the first parameter. In line 5, \sphinxcode{\sphinxupquote{b}} is created as a \sphinxcode{\sphinxupquote{Fagus}}\sphinxhyphen{}instance \textendash{} calling \sphinxcode{\sphinxupquote{get()}} on \sphinxcode{\sphinxupquote{b}} also yields \sphinxcode{\sphinxupquote{e}}.

\sphinxAtStartPar
While it’s not necessary to instantiate \sphinxcode{\sphinxupquote{Fagus}}, there are some neat shortcuts that are only available to \sphinxcode{\sphinxupquote{Fagus}}\sphinxhyphen{}instances:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Fagus}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x y z}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{6}  \PYG{c+c1}{\PYGZsh{} a = \PYGZob{}\PYGZdq{}x\PYGZdq{}: \PYGZob{}\PYGZdq{}y\PYGZdq{}: \PYGZob{}\PYGZdq{}z\PYGZdq{}: 6\PYGZcb{}\PYGZcb{}\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{x}  \PYG{c+c1}{\PYGZsh{} returns the whole subnode at a[\PYGZdq{}x\PYGZdq{}]}
\PYG{g+go}{\PYGZob{}\PYGZsq{}y\PYGZsq{}: \PYGZob{}\PYGZsq{}z\PYGZsq{}: 6\PYGZcb{}\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{del} \PYG{n}{a}\PYG{p}{[}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{y}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{z}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} Delete the z\PYGZhy{}subnode in a[\PYGZdq{}x y\PYGZdq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}\PYGZsq{}x\PYGZsq{}: \PYGZob{}\PYGZsq{}y\PYGZsq{}: \PYGZob{}\PYGZcb{}\PYGZcb{}\PYGZcb{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{Square bracket notation}: On \sphinxcode{\sphinxupquote{Fagus}}\sphinxhyphen{}instances, the square\sphinxhyphen{}bracket notation can be used for easier access of data if no further customization is needed. Line 3 is equivalent to \sphinxcode{\sphinxupquote{a.set(6, "x y z")}}. It can be used for getting, setting and deleting items (line 6).

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Dot notation}: The dot\sphinxhyphen{}notation is activated for setting, getting and deleting items as well (line 4). It can be used to access \sphinxcode{\sphinxupquote{str}}\sphinxhyphen{}keys in \sphinxcode{\sphinxupquote{dict}}s and \sphinxcode{\sphinxupquote{list}}\sphinxhyphen{}indices, the index must then be preceded with an underscore due to Python naming limitations (\sphinxcode{\sphinxupquote{a.\_4}}). This can be further customized using {\hyperref[\detokenize{README:value-split}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{value\_split}}}}}}

\end{itemize}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Fagus}} is a wrapper\sphinxhyphen{}class around a tree of \sphinxcode{\sphinxupquote{dict}}\sphinxhyphen{} or \sphinxcode{\sphinxupquote{list}}\sphinxhyphen{}objects. To get back the root\sphinxhyphen{}object inside the instance, use \sphinxcode{\sphinxupquote{()}} to call the object \textendash{} this is shown in line 7.


\subsection{Fagus options}
\label{\detokenize{README:fagus-options}}
\sphinxAtStartPar
There are several parameters used across many functions in \sphinxcode{\sphinxupquote{Fagus}} which steer the behaviour of that function. Often, similar behaviour is intended across a whole application or parts of it, and this is where options come in handy allowing to only specify these parameters once.

\sphinxAtStartPar
One example of a \sphinxcode{\sphinxupquote{Fagus}}\sphinxhyphen{}option is {\hyperref[\detokenize{README:default}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{default}}}}}}. This option contains the value that is returned e.g. in \sphinxcode{\sphinxupquote{get()}} if a \sphinxcode{\sphinxupquote{path}} doesn’t exist, see {\hyperref[\detokenize{README:introduction-what-it-solves}]{\sphinxcrossref{\DUrole{std,std-doc}{Introduction}}}}, code block two for an example.

\sphinxAtStartPar
\sphinxstylestrong{The four levels of \sphinxcode{\sphinxupquote{Fagus}}\sphinxhyphen{}options}:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
\sphinxstylestrong{Argument}: The highest level \sphinxhyphen{} if an option is specified directly as an argument to a function, that value takes precedence over all other levels.

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Instance}: If an option is set for an instance, it will apply to all function calls at that instance where level one has not been specified.

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Class}: If an option is set at class level (i.e. \sphinxcode{\sphinxupquote{Fagus.option}}), it applies to all function calls and all instances where level one and two of that option aren’t defined. Options at this level apply for the whole file \sphinxcode{\sphinxupquote{Fagus}} has been imported in.

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Default}: If no other level is specified, the hardcoded default for that option is used.

\end{enumerate}

\sphinxAtStartPar
Below is an example of how the different levels take precedence over one another:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Fagus}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} b does not exist in a \PYGZhy{} default is None by default}
\PYG{g+go}{None}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Fagus}\PYG{o}{.}\PYG{n}{default} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{class}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{c+c1}{\PYGZsh{} Overriding default at class level}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} now \PYGZsq{}class\PYGZsq{} is returned, as None was overridden}
\PYG{g+go}{\PYGZsq{}class\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{default} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{instance}\PYG{l+s+s1}{\PYGZsq{}}  \PYG{c+c1}{\PYGZsh{} setting the default option at instance level}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} for a default is set to \PYGZsq{}instance\PYGZsq{} \PYGZhy{}\PYGZhy{} return \PYGZsq{}instance\PYGZsq{}}
\PYG{g+go}{\PYGZsq{}instance\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b} \PYG{o}{=} \PYG{n}{Fagus}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} for b, line 7 doesn\PYGZsq{}t apply \PYGZhy{}\PYGZhy{} line 5 still applies}
\PYG{g+go}{\PYGZsq{}class\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{del} \PYG{n}{Fagus}\PYG{o}{.}\PYG{n}{default}  \PYG{c+c1}{\PYGZsh{} deleting an option resets it to its default}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{b}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} for default, the default is None}
\PYG{g+go}{None}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{default}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{arg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} passing an option as a parameter always wins}
\PYG{g+go}{\PYGZsq{}arg\PYGZsq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
All \sphinxcode{\sphinxupquote{Fagus}}\sphinxhyphen{}options at level two can be set in the constructor of \sphinxcode{\sphinxupquote{Fagus}}, so they don’t have to be set one by one like in line 8. You can also use \sphinxcode{\sphinxupquote{options()}} on an instance or on the \sphinxcode{\sphinxupquote{Fagus}}\sphinxhyphen{}class to set several options in one line, or get all the options that apply to an instance.

\sphinxAtStartPar
Some \sphinxcode{\sphinxupquote{Fagus}}\sphinxhyphen{}functions return child\sphinxhyphen{}\sphinxcode{\sphinxupquote{Fagus}}\sphinxhyphen{}objects in their result. These child\sphinxhyphen{}objects inherit the options at level two from their parent.

\sphinxAtStartPar
The remaining part of this section explains the options one by one.


\subsubsection{default}
\label{\detokenize{README:default}}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{Default}: \sphinxcode{\sphinxupquote{None}}

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Type}: \sphinxcode{\sphinxupquote{Any}}

\end{itemize}

\sphinxAtStartPar
This value is returned if the requested {\hyperref[\detokenize{README:the-path-parameter}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{path}}}}}} does not exist. Example in {\hyperref[\detokenize{README:introduction-what-it-solves}]{\sphinxcrossref{\DUrole{std,std-doc}{Introduction}}}}, code block two.


\subsubsection{default\_node\_type}
\label{\detokenize{README:default-node-type}}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{Default}: \sphinxcode{\sphinxupquote{"d"}}

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Type}: \sphinxcode{\sphinxupquote{str}}

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Allowed values}: \sphinxcode{\sphinxupquote{"d"}} and \sphinxcode{\sphinxupquote{"l"}}

\end{itemize}

\sphinxAtStartPar
Can be either \sphinxcode{\sphinxupquote{"d"}} for \sphinxcode{\sphinxupquote{dict}} or \sphinxcode{\sphinxupquote{"l"}} for \sphinxcode{\sphinxupquote{list}}. A new node of this type is created if it’s not specified clearly what other type that node shall have. It is used e.g. when Fagus is instanciated with an empty constructor:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Fagus}\PYG{o}{.}\PYG{n}{default\PYGZus{}node\PYGZus{}type} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{l}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Fagus}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} the root node of a is an empty list as this was set in line 2}
\PYG{g+go}{[]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{del} \PYG{n}{Fagus}\PYG{o}{.}\PYG{n}{default\PYGZus{}node\PYGZus{}type}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b} \PYG{o}{=} \PYG{n}{Fagus}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} the root node of b is a dict (default for default\PYGZus{}node\PYGZus{}type)}
\PYG{g+go}{\PYGZob{}\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{if\_}
\label{\detokenize{README:if}}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{Default}: \sphinxcode{\sphinxupquote{\_None}}, meaning that the value is not checked

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Type}: Any

\end{itemize}

\sphinxAtStartPar
This option can be used to verify values before they’re inserted into the \sphinxcode{\sphinxupquote{Fagus}}\sphinxhyphen{}object. Generating configuration\sphinxhyphen{}files, default values can often be omitted whereas special settings shall be included, \sphinxcode{\sphinxupquote{if\_}} can be used to do this without an extra if\sphinxhyphen{}statement.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Fagus}\PYG{p}{(}\PYG{n}{if\PYGZus{}}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} the only allowed value for set is now True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{v1} \PYG{o}{=} \PYG{k+kc}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} v1 was set, because it was True (as requested in line 1)}
\PYG{g+go}{\PYGZob{}\PYGZsq{}v1\PYGZsq{}: True\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{v2} \PYG{o}{=} \PYG{k+kc}{None}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} note that v2 has not been set as it was not True}
\PYG{g+go}{\PYGZob{}\PYGZsq{}v1\PYGZsq{}: True\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{if\PYGZus{}}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} 6 was set as it was in (4, 5, 6)}
\PYG{g+go}{\PYGZob{}\PYGZsq{}v1\PYGZsq{}: True, \PYGZsq{}v2\PYGZsq{}: 6\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{if\PYGZus{}}\PYG{o}{=}\PYG{n+nb}{bool}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} v3 is not set because bool(\PYGZdq{}\PYGZdq{}) is False}
\PYG{g+go}{\PYGZob{}\PYGZsq{}v1\PYGZsq{}: True, \PYGZsq{}v2\PYGZsq{}: 6\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Possible ways to specify \sphinxcode{\sphinxupquote{if\_}}:
\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{Single value}: This is shown in line 1 \textendash{} the only values that can now be set is \sphinxcode{\sphinxupquote{True}}, anything else is not accepted.

\item {}
\sphinxAtStartPar
\sphinxstylestrong{List of values}: You can also specify any \sphinxcode{\sphinxupquote{Iterable}} (e.g. a \sphinxcode{\sphinxupquote{list}}) with multiple values \textendash{} the values that can be set must be one of the values in the \sphinxcode{\sphinxupquote{list}} (line 8).

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Callable}: You can also pass a callable object or a function (lambda) \textendash{} the result of that call determines whether the value is set (line 10).

\end{itemize}


\subsubsection{iter\_fill}
\label{\detokenize{README:iter-fill}}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{Default}: \sphinxcode{\sphinxupquote{\_None}}, meaning that \sphinxcode{\sphinxupquote{iter\_fill}} is inactive

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Type}: Any

\end{itemize}

\sphinxAtStartPar
This option is used to get a constant number of items in the iterator while iterating over a \sphinxcode{\sphinxupquote{Fagus}}\sphinxhyphen{}object, see {\hyperref[\detokenize{README:iterating-over-nested-objects}]{\sphinxcrossref{\DUrole{std,std-doc}{here}}}} for more about iteration in \sphinxcode{\sphinxupquote{Fagus}}. The example below shows what happens by default when iterating over a \sphinxcode{\sphinxupquote{Fagus}}\sphinxhyphen{}object where the leaf\sphinxhyphen{}nodes are at different depths:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{Fagus}\PYG{o}{.}\PYG{n}{iter}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}
\PYG{g+go}{[(\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, 2), (\PYGZsq{}c\PYGZsq{}, 4)]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z} \PYG{o+ow}{in} \PYG{n}{a}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}
\PYG{g+gt}{Traceback (most recent call last):}
\PYG{c}{...}
\PYG{g+gr}{ValueError}: \PYG{n}{not enough values to unpack (expected 3, got 2)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{Fagus}\PYG{o}{.}\PYG{n}{iter}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{iter\PYGZus{}fill}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}
\PYG{g+go}{[(\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, 2), (\PYGZsq{}c\PYGZsq{}, 4, None)]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z} \PYG{o+ow}{in} \PYG{n}{a}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}
\PYG{g+go}{a b 2}
\PYG{g+go}{c 4 None}
\end{sphinxVerbatim}

\sphinxAtStartPar
In line 3, we see that the first tuple has three items, and the second only two. When this is run in a loop that always expects three values to unpack, it fails (line 4\sphinxhyphen{}8). That problem is solved in line 9 by using \sphinxcode{\sphinxupquote{iter\_fill}}, which fills up the shorter tuples with the value that was specified for \sphinxcode{\sphinxupquote{iter\_fill}}, here \sphinxcode{\sphinxupquote{None}}. With that in place, the loop in line 12\sphinxhyphen{}15 runs through without raising an error. Note that \sphinxcode{\sphinxupquote{max\_depth}} has to be specified for \sphinxcode{\sphinxupquote{Fagus}} to know how many items to fill up to.


\subsubsection{iter\_nodes}
\label{\detokenize{README:iter-nodes}}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{Default}: \sphinxcode{\sphinxupquote{False}}

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Type}: \sphinxcode{\sphinxupquote{bool}}

\end{itemize}

\sphinxAtStartPar
This option is used to get references to the traversed nodes while iterating on a \sphinxcode{\sphinxupquote{Fagus}}\sphinxhyphen{}object, see {\hyperref[\detokenize{README:iterating-over-nested-objects}]{\sphinxcrossref{\DUrole{std,std-doc}{here}}}} for more about iteration in \sphinxcode{\sphinxupquote{Fagus}}. Below is an example of what this means:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{Fagus}\PYG{o}{.}\PYG{n}{iter}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{[(\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, 2), (\PYGZsq{}c\PYGZsq{}, 4)]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{Fagus}\PYG{o}{.}\PYG{n}{iter}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{iter\PYGZus{}nodes}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{[(\PYGZob{}\PYGZsq{}a\PYGZsq{}: \PYGZob{}\PYGZsq{}b\PYGZsq{}: 2\PYGZcb{}, \PYGZsq{}c\PYGZsq{}: 4\PYGZcb{}, \PYGZsq{}a\PYGZsq{}, \PYGZob{}\PYGZsq{}b\PYGZsq{}: 2\PYGZcb{}, \PYGZsq{}b\PYGZsq{}, 2), (\PYGZob{}\PYGZsq{}a\PYGZsq{}: \PYGZob{}\PYGZsq{}b\PYGZsq{}: 2\PYGZcb{}, \PYGZsq{}c\PYGZsq{}: 4\PYGZcb{}, \PYGZsq{}c\PYGZsq{}, 4)]}
\end{sphinxVerbatim}

\sphinxAtStartPar
As you can see, the node itself is included as the first element in both tuples. In the first tuple, we also find the subnode \sphinxcode{\sphinxupquote{\{"b": 2\}}} as the third element. In line 2, the tuples are filled after this scheme: \sphinxcode{\sphinxupquote{key1, key2, key3, ..., value}}. In line 4, we additionally get the nodes, so it is \sphinxcode{\sphinxupquote{root\sphinxhyphen{}node, key1, node, key2, node2, key3, ..., value}}.

\sphinxAtStartPar
Sometimes in loops it can be helpful to actually have access to the whole node containing other relevant information. This can be especially useful combined with {\hyperref[\detokenize{README:skipping-nodes-in-iteration}]{\sphinxcrossref{\DUrole{std,std-doc}{\sphinxcode{\sphinxupquote{skip()}}}}}}.


\subsubsection{value\_split}
\label{\detokenize{README:value-split}}

\subsection{Iterating over nested objects}
\label{\detokenize{README:iterating-over-nested-objects}}

\subsubsection{Skipping nodes in iteration.}
\label{\detokenize{README:skipping-nodes-in-iteration}}
\sphinxstepscope


\chapter{fagus package}
\label{\detokenize{fagus:module-fagus}}\label{\detokenize{fagus:fagus-package}}\label{\detokenize{fagus::doc}}\index{module@\spxentry{module}!fagus@\spxentry{fagus}}\index{fagus@\spxentry{fagus}!module@\spxentry{module}}
\sphinxAtStartPar
Library to easily create, edit and traverse nested objects of dicts and lists in Python
\begin{description}
\item[{The following objects can be imported directly from this module:}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
{\hyperref[\detokenize{fagus.fagus:fagus.fagus.Fagus}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fagus}}}}}: a wrapper\sphinxhyphen{}class for complex, nested objects of dicts and lists

\item {}
\sphinxAtStartPar
{\hyperref[\detokenize{fagus.filters:fagus.filters.Fil}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fil}}}}}, {\hyperref[\detokenize{fagus.filters:fagus.filters.CFil}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CFil}}}}} and {\hyperref[\detokenize{fagus.filters:fagus.filters.VFil}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{VFil}}}}} are filter\sphinxhyphen{}objects that can
be used to filter {\hyperref[\detokenize{fagus.fagus:fagus.fagus.Fagus}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fagus}}}}}\sphinxhyphen{}objects

\item {}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{INF}}: alias for \sphinxcode{\sphinxupquote{sys.maxsize}}, used e.g. to indicate that an element should be appended to
a list

\end{itemize}

\item[{Submodules in {\hyperref[\detokenize{fagus:module-fagus}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fagus}}}}}:}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
{\hyperref[\detokenize{fagus.fagus:module-fagus.fagus}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fagus}}}}}: Base\sphinxhyphen{}module that contains the {\hyperref[\detokenize{fagus.fagus:fagus.fagus.Fagus}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fagus}}}}}\sphinxhyphen{}class

\item {}
\sphinxAtStartPar
{\hyperref[\detokenize{fagus.filters:module-fagus.filters}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{filters}}}}}: filter\sphinxhyphen{}classes for filtering {\hyperref[\detokenize{fagus.fagus:fagus.fagus.Fagus}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fagus}}}}}\sphinxhyphen{}objects

\item {}
\sphinxAtStartPar
{\hyperref[\detokenize{fagus.iterators:module-fagus.iterators}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{iterators}}}}}: iterator\sphinxhyphen{}classes for iterating on {\hyperref[\detokenize{fagus.fagus:fagus.fagus.Fagus}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fagus}}}}}

\item {}
\sphinxAtStartPar
{\hyperref[\detokenize{fagus.utils:module-fagus.utils}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{utils}}}}}: helper classes and methods for {\hyperref[\detokenize{fagus.fagus:fagus.fagus.Fagus}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Fagus}}}}}

\end{itemize}

\end{description}


\section{Submodules}
\label{\detokenize{fagus:submodules}}
\sphinxstepscope


\subsection{fagus.fagus module}
\label{\detokenize{fagus.fagus:module-fagus.fagus}}\label{\detokenize{fagus.fagus:fagus-fagus-module}}\label{\detokenize{fagus.fagus::doc}}\index{module@\spxentry{module}!fagus.fagus@\spxentry{fagus.fagus}}\index{fagus.fagus@\spxentry{fagus.fagus}!module@\spxentry{module}}
\sphinxAtStartPar
Base\sphinxhyphen{}module that contains the \sphinxcode{\sphinxupquote{Fagus}}\sphinxhyphen{}class
\index{Fagus (class in fagus.fagus)@\spxentry{Fagus}\spxextra{class in fagus.fagus}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{fagus.fagus.}}\sphinxbfcode{\sphinxupquote{Fagus}}}{\emph{\DUrole{n}{root}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Optional\DUrole{p}{{[}}collections.abc.Collection\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{None}}, \emph{\DUrole{n}{node\_types}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{list\_insert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{value\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{default\_node\_type}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{default}\DUrole{o}{=}\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{if\_}\DUrole{o}{=}\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{iter\_fill}\DUrole{o}{=}\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{mod\_functions}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{collections.abc.Mapping}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{collections.abc.MutableMapping}}, \sphinxcode{\sphinxupquote{collections.abc.MutableSequence}}, \sphinxcode{\sphinxupquote{collections.abc.MutableSet}}

\sphinxAtStartPar
Fagus is a wrapper\sphinxhyphen{}class for complex, nested objects of dicts and lists in Python

\sphinxAtStartPar
Fagus can be used as an object by instantiating it, but it’s also possible to use all methods statically without
even an object, so that a = \{\}; Fagus.set(a, “top med”, 1) and a = Fagus(\{\}); a.set(1, “top med”) do the same.

\sphinxAtStartPar
The root node is always modified directly. If you don’t want to change the root node, all the functions where it
makes sense support to rather modify a copy, and return that modified copy using the copy\sphinxhyphen{}parameter.

\sphinxAtStartPar
Several parameters used in functions in Fagus work as options so that you don’t have to specify them each time you
run a function. In the docstrings, these options are marked with a *, e.g. the fagus parameter is an option.
Options can be specified at three levels with increasing precedence: at class\sphinxhyphen{}level (Fagus.fagus = True), at
object\sphinxhyphen{}level (a = Fagus(), a.fagus = True) and in each function\sphinxhyphen{}call (a.get(“b”, fagus=True)). If you generally want
to change an option, change it at class\sphinxhyphen{}level \sphinxhyphen{} all objects in that file will inherit this option. If you want to
change the option specifically for one object, change the option at object\sphinxhyphen{}level. If you only want to change the
option for one single run of a function, put it as a function\sphinxhyphen{}parameter. More thorough examples of options can be
found in README.md.
\index{\_\_init\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_init\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{n}{root}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Optional\DUrole{p}{{[}}collections.abc.Collection\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{None}}, \emph{\DUrole{n}{node\_types}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{list\_insert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{value\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{default\_node\_type}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{default}\DUrole{o}{=}\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{if\_}\DUrole{o}{=}\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{iter\_fill}\DUrole{o}{=}\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{mod\_functions}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{collections.abc.Mapping}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Constructor for Fagus, a wrapper\sphinxhyphen{}class for complex, nested objects of dicts and lists in Python

\sphinxAtStartPar
* means that the parameter is a Fagus\sphinxhyphen{}Setting, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{root}} \textendash{} object (like dict / list) to wrap Fagus around. If this is None, an empty node of the type
default\_node\_type will be used. Default None

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_types}} \textendash{} * Can be used to manually define if the nodes along path are supposed to be (l)ists or
(d)icts. E.g. “dll” to create a dict at level 1, and lists at level 2 and 3. ” ” can also be used \sphinxhyphen{}
space doesn’t enforce a node\sphinxhyphen{}type like d or l. For ” “, existing nodes are traversed if possible,
otherwise default\_node\_type is used to create new nodes. Default “”, interpreted as ” ” at each level.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{list\_insert}} \textendash{} * Level at which a new node shall be inserted into the list instead of traversing the
existing node in the list at that index. See README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value\_split}} \textendash{} * used to split path into a list if path is a string, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * this option is used to determine whether nodes in the returned object should be returned as
Fagus\sphinxhyphen{}objects. This can be useful e.g. if you want to use Fagus in an iteration. Check the particular
function you want to use for a more thorough explanation of what this does in each case

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default\_node\_type}} \textendash{} * determines if new nodes by default should be created as (d)ict or (l)ist. Must be
either “d” or “l”, default “d”

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default}} \textendash{} * \textasciitilde{} is used in get and other functions if a path doesn’t exist

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{if\_}} \textendash{} * only set value if it meets the condition specified here, otherwise do nothing. The condition can be
a lambda, any value or a tuple of accepted values. Default \_None (don’t check value)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{iter\_fill}} \textendash{} * Fill up tuples with iter\_fill (can be any object, e.g. None) to ensure that all the tuples
iter() returns are exactly max\_items long. See iter()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} \textasciitilde{} creates a copy of the root node before Fagus is initialized. Makes sure that changes on this Fagus
won’t modify the root node that was passed here itself. Default False

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{get() (fagus.fagus.Fagus method)@\spxentry{get()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.get}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{default}\DUrole{o}{=}\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{value\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ Any}}
\pysigstopsignatures
\sphinxAtStartPar
Retrieves value at path. If the value doesn’t exist, default is returned.

\sphinxAtStartPar
To get “hello” from x = Fagus(\{“a”: {[}“b”, \{“c”: “d”\}{]}, e: {[}“f”, “g”{]}\}), you can use x{[}(“a”, 1, “c”){]}. The tuple
(“a”, 1, “c”) is the path\sphinxhyphen{}parameter that is used to traverse x. At first, the list at “a” is picked in the
top\sphinxhyphen{}most dict, and then the 2nd element \{“c”: “d”\} is picked from that list. Then, “d” is picked from \{“c”: “d”\}
and returned. The path\sphinxhyphen{}parameter can be a tuple or list, the keys must be either integers for lists, or any
hashable objects for dicts. For convenience, the keys can also be put in a single string separated by
value\_split (default ” “), so a{[}“a 1 c”{]} also returns “d”.

\sphinxAtStartPar
* means that the parameter is a Fagus\sphinxhyphen{}Setting, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} List/Tuple of key\sphinxhyphen{}values to recursively traverse self. Can also be specified as string, that is split
into a tuple using value\_split

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default}} \textendash{} * returned if path doesn’t exist in self

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * returns a Fagus\sphinxhyphen{}object if the value at path is a list or dict

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} Option to return a copy of the returned value. The default behaviour is that if there are subnodes
(dicts, lists) in the returned values, and you make changes to these nodes, these changes will also be
applied in the root node from which values() was called. If you want the returned values to be
independent, use copy to get a shallow copy of the returned value

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the value if the path exists, or default if it doesn’t exist

\end{description}\end{quote}

\end{fulllineitems}

\index{iter() (fagus.fagus.Fagus method)@\spxentry{iter()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.iter}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{iter}}}{\emph{\DUrole{n}{max\_depth}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{9223372036854775807}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{filter\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Optional\DUrole{p}{{[}}{\hyperref[\detokenize{fagus.filters:fagus.filters.Fil}]{\sphinxcrossref{fagus.filters.Fil}}}\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{None}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{iter\_fill}\DUrole{o}{=}\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{select}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Optional\DUrole{p}{{[}}Union\DUrole{p}{{[}}int\DUrole{p}{,}\DUrole{w}{  }collections.abc.Iterable\DUrole{p}{{]}}\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{None}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{iter\_nodes}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{filter\_ends}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{value\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ {\hyperref[\detokenize{fagus.iterators:fagus.iterators.FagusIterator}]{\sphinxcrossref{fagus.iterators.FagusIterator}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Recursively iterate through Fagus\sphinxhyphen{}object, starting at path

\sphinxAtStartPar
* means that the parameter is a Fagus\sphinxhyphen{}Setting, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max\_depth}} \textendash{} Can be used to limit how deep the iteration goes. Example: a = \{“a”: {[}“b”, {[}“c”, “d”{]}{]}, “e”: “f”\}
If max\_depth is sys.max\_size, all the nodes are traversed: {[}(“a”, “b”, “c”), (“a”, “b”, “d”{]}),
(“e”, “f”){]}. If max\_depth is 1, iter returns {[}(“a”, “b”, {[}“c”, “d”{]}), (“e”, “f”){]}, so {[}“c”, “d”{]} is not
iterated through but returned as a node. If max\_depth is 0, iter returns {[}(“a”, {[}“b”, {[}“c”, “d”{]}{]}),
(“e”, “f”){]}, effectively the same as dict.items(). Default sys.maxitems (iterate as deeply as possible)
A negative number (e.g. \sphinxhyphen{}1) is treated as sys.maxitems.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} Start iterating at path. Internally calls get(path), and iterates on the node get returns. See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{filter\_}} \textendash{} Only iterate over specific nodes defined using TFilter (see README.md and TFilter for more info)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * If the leaf in the tuple is a dict or list, return it as a Fagus\sphinxhyphen{}object. This option has no
effect if max\_items is sys.maxitems.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{iter\_fill}} \textendash{} * Fill up tuples with iter\_fill (can be any object, e.g. None) to ensure that all the tuples
iter() returns are exactly max\_items long. This can be useful if you want to unpack the keys / leaves
from the tuples in a loop, which fails if the count of items in the tuples varies. This option has no
effect if max\_items is \sphinxhyphen{}1. The default value is …, meaning that the tuples are not filled, and the
length of the tuples can vary. See README.md for a more thorough example.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{select}} \textendash{} Extract only some specified values from the tuples. E.g. if \textasciitilde{} is \sphinxhyphen{}1, only the leaf\sphinxhyphen{}values are
returned. \textasciitilde{} can also be a list of indices. Default None (don’t reduce the tuples)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} Iterate on a shallow\sphinxhyphen{}copy to make sure that you can edit root node without disturbing the iteration

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{iter\_nodes}} \textendash{} * includes the traversed nodes into the resulting tuples, order is then:
node1, key1, node2, key2, …, leaf\_value

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{filter\_ends}} \textendash{} Affects the end dict/list that is returned if max\_items is used. Normally, filters are not
applied on that end node. If you would like to get the end node filtered too, set this to True. If this
is set to True, the last nodes will always be copies (if unfiltered they are references)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
FagusIterator with one tuple for each leaf\sphinxhyphen{}node, containing the keys of the parent\sphinxhyphen{}nodes until the leaf

\end{description}\end{quote}

\end{fulllineitems}

\index{filter() (fagus.fagus.Fagus method)@\spxentry{filter()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.filter}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{filter}}}{\emph{\DUrole{n}{filter\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{{\hyperref[\detokenize{fagus.filters:fagus.filters.Fil}]{\sphinxcrossref{fagus.filters.Fil}}}}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{default}\DUrole{o}{=}\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{value\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ collections.abc.Collection}}
\pysigstopsignatures
\sphinxAtStartPar
Filters self, only keeping the nodes that pass the filter

\sphinxAtStartPar
* means that the parameter is a Fagus\sphinxhyphen{}Setting, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{filter\_}} \textendash{} TFilter\sphinxhyphen{}object in which the filtering\sphinxhyphen{}criteria are specified

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} at this point in self, the filtering will start (apply filter\_ relatively from this point).
Default “”, meaning that the root node is filtered, see get() and README for examples

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * return the filtered self as Fagus\sphinxhyphen{}object (default is just to return the filtered node)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} Create a copy and filter on that copy. Default is to modify the self directly

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default}} \textendash{} * returned if path doesn’t exist in self, or the value at path can’t be filtered

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the filtered object, starting at path

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if the root node needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{description}\end{quote}

\end{fulllineitems}

\index{split() (fagus.fagus.Fagus method)@\spxentry{split()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.split}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{split}}}{\emph{\DUrole{n}{filter\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{{\hyperref[\detokenize{fagus.filters:fagus.filters.Fil}]{\sphinxcrossref{fagus.filters.Fil}}}}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{default}\DUrole{o}{=}\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{value\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ Union\DUrole{p}{{[}}Tuple\DUrole{p}{{[}}collections.abc.Collection\DUrole{p}{,}\DUrole{w}{  }collections.abc.Collection\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }Tuple\DUrole{p}{{[}}Any\DUrole{p}{,}\DUrole{w}{  }Any\DUrole{p}{{]}}\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Splits self into nodes that pass the filter, and nodes that don’t pass the filter

\sphinxAtStartPar
* means that the parameter is a Fagus\sphinxhyphen{}Setting, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{filter\_}} \textendash{} TFilter\sphinxhyphen{}object in which the filtering\sphinxhyphen{}criteria are specified

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} at this position in self, the splitting will start (apply filter\_ relatively from this point).
Default “”, meaning that the root node is split, see get() and README for examples

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * return the filtered self as Fagus\sphinxhyphen{}object (default is just to return the filtered node)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} Create a copy and filter on that copy. Default is to modify the object directly

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default}} \textendash{} * returned if path doesn’t exist in self, or the

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a tuple, where the first element is the nodes that pass the filter, and the second element is the nodes that
don’t pass the filter

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if the root node needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{description}\end{quote}

\end{fulllineitems}

\index{set() (fagus.fagus.Fagus method)@\spxentry{set()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.set}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set}}}{\emph{\DUrole{n}{value}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{collections.abc.Iterable}}, \emph{\DUrole{n}{node\_types}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{list\_insert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{value\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{if\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{default\_node\_type}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ collections.abc.Collection}}
\pysigstopsignatures
\sphinxAtStartPar
Create (if they don’t already exist) all sub\sphinxhyphen{}nodes in path, and finally set value at leaf\sphinxhyphen{}node

\sphinxAtStartPar
* means that the parameter is a Fagus\sphinxhyphen{}Setting, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value}} \textendash{} \textasciitilde{} is placed at path, after creating new nodes if necessary. An existing value at path is overwritten

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} List/Tuple of key\sphinxhyphen{}values that are traversed in self. If no nodes exist at the keys, new nodes are
created. Can also be specified as a string, that is split into a tuple using value\_split. See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_types}} \textendash{} * Can be used to manually define if the nodes along path are supposed to be (l)ists or
(d)icts. E.g. “dll” to create a dict at level 1, and lists at level 2 and 3. ” ” can also be used \sphinxhyphen{}
space doesn’t enforce a node\sphinxhyphen{}type like d or l. For ” “, existing nodes are traversed if possible,
otherwise default\_node\_type is used to create new nodes. Default “”, interpreted as ” ” at each level.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{list\_insert}} \textendash{} * Level at which a new node shall be inserted into the list instead of traversing the
existing node in the list at that index. See README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value\_split}} \textendash{} * used to split path into a list if path is a string, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * return self as a Fagus\sphinxhyphen{}object if it is a node (tuple / list / dict), default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{if\_}} \textendash{} * only set value if it meets the condition specified here, otherwise do nothing. The condition can be
a lambda, any value or a tuple of accepted values. Default \_None (don’t check value)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default\_node\_type}} \textendash{} * determines if new nodes by default should be created as (d)ict or (l)ist. Must be
either “d” or “l”, default “d”

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} if this is set, a copy of self is modified and then returned (thus self is not modified)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
self as a node if fagus is set, or a modified copy of self if copy is set

\item[{Raises}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if it isn’t possible to parse an int\sphinxhyphen{}index from the provided key in a position where node\sphinxhyphen{}types
    defines that the node shall be a list (if node\sphinxhyphen{}types is not l, the node will be replaced with a dict)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if the root node needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{append() (fagus.fagus.Fagus method)@\spxentry{append()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.append}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{append}}}{\emph{\DUrole{n}{value}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{node\_types}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{list\_insert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{value\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{if\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{default\_node\_type}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ collections.abc.Collection}}
\pysigstopsignatures
\sphinxAtStartPar
Create (if they don’t already exist) all sub\sphinxhyphen{}nodes in path, and finally append value to a list at leaf\sphinxhyphen{}node

\sphinxAtStartPar
If the leaf\sphinxhyphen{}node is a set, tuple or other value it is converted to a list. Then the new value is appended.

\sphinxAtStartPar
* means that the parameter is a Fagus\sphinxhyphen{}Setting, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value}} \textendash{} \textasciitilde{} is appended to list at path, after creating new nodes along path as necessary

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} List/Tuple of key\sphinxhyphen{}values that are traversed in self. If no nodes exist at the keys, new nodes are
created. Can also be specified as a string, that is split into a tuple using value\_split. See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_types}} \textendash{} * Can be used to manually define if the nodes along path are supposed to be (l)ists or
(d)icts. E.g. “dll” to create a dict at level 1, and lists at level 2 and 3. ” ” can also be used \sphinxhyphen{}
space doesn’t enforce a node\sphinxhyphen{}type like d or l. For ” “, existing nodes are traversed if possible,
otherwise default\_node\_type is used to create new nodes. Default “”, interpreted as ” ” at each level.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{list\_insert}} \textendash{} * Level at which a new node shall be inserted into the list instead of traversing the
existing node in the list at that index. See README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value\_split}} \textendash{} * used to split path into a list if path is a string, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * return self as a Fagus\sphinxhyphen{}object if it is a node (tuple / list / dict), default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{if\_}} \textendash{} * only append value if it meets the condition specified here, otherwise do nothing. The condition can
be a lambda, any value or a tuple of accepted values. Default \_None (don’t check value)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default\_node\_type}} \textendash{} * determines if new nodes by default should be created as (d)ict or (l)ist. Must be
either “d” or “l”, default “d”

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} if this is set, a copy of self is modified and then returned (thus self is not modified)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
self as a node if fagus is set, or a modified copy of self if copy is set

\item[{Raises}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if it isn’t possible to parse an int\sphinxhyphen{}index from the provided key in a position where node\sphinxhyphen{}types
    defines that the node shall be a list (if node\sphinxhyphen{}types is not l, the node will be replaced with a dict)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if path is empty and the root node is not a list (can’t append to a dict, tuple or set) or the
    root node needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{extend() (fagus.fagus.Fagus method)@\spxentry{extend()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.extend}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{extend}}}{\emph{\DUrole{n}{values}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{collections.abc.Iterable}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{node\_types}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{list\_insert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{value\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{if\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{default\_node\_type}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ collections.abc.Collection}}
\pysigstopsignatures
\sphinxAtStartPar
Create (if they don’t already exist) all sub\sphinxhyphen{}nodes in path. Then extend list at leaf\sphinxhyphen{}node with the new values

\sphinxAtStartPar
If the leaf\sphinxhyphen{}node is a set, tuple or other value it is converted to a list, which is extended with the new values

\sphinxAtStartPar
* means that the parameter is a Fagus\sphinxhyphen{}Setting, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{values}} \textendash{} the list at path is extended with \textasciitilde{}, after creating new nodes along path as necessary

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} List/Tuple of key\sphinxhyphen{}values that are traversed in self. If no nodes exist at the keys, new nodes are
created. Can also be specified as a string, that is split into a tuple using value\_split. See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_types}} \textendash{} * Can be used to manually define if the nodes along path are supposed to be (l)ists or
(d)icts. E.g. “dll” to create a dict at level 1, and lists at level 2 and 3. ” ” can also be used \sphinxhyphen{}
space doesn’t enforce a node\sphinxhyphen{}type like d or l. For ” “, existing nodes are traversed if possible,
otherwise default\_node\_type is used to create new nodes. Default “”, interpreted as ” ” at each level.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{list\_insert}} \textendash{} * Level at which a new node shall be inserted into the list instead of traversing the
existing node in the list at that index. See README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value\_split}} \textendash{} * used to split path into a list if path is a string, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * return self as a Fagus\sphinxhyphen{}object if it is a node (tuple / list / dict), default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{if\_}} \textendash{} * only extend with values if they meet the condition specified here, otherwise do nothing. The
condition can be a lambda, any value or a tuple of accepted values. Default \_None (don’t check values)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default\_node\_type}} \textendash{} * determines if new nodes by default should be created as (d)ict or (l)ist. Must be
either “d” or “l”, default “d”

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} if this is set, a copy of self is modified and then returned (thus self is not modified)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
self as a node if fagus is set, or a modified copy of self if copy is set

\item[{Raises}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if it isn’t possible to parse an int\sphinxhyphen{}index from the provided key in a position where node\sphinxhyphen{}types
    defines that the node shall be a list (if node\sphinxhyphen{}types is not l, the node will be replaced with a dict)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if path is empty and the root node is not a list (can’t extend a dict, tuple or set) or the
    root node needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{insert() (fagus.fagus.Fagus method)@\spxentry{insert()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.insert}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{insert}}}{\emph{\DUrole{n}{index}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{value}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{node\_types}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{list\_insert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{value\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{if\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{default\_node\_type}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ collections.abc.Collection}}
\pysigstopsignatures
\sphinxAtStartPar
Create (if they don’t already exist) all sub\sphinxhyphen{}nodes in path. Insert new value at index in list at leaf\sphinxhyphen{}node

\sphinxAtStartPar
If the leaf\sphinxhyphen{}node is a set, tuple or other value it is converted to a list, in which the new value is inserted at
index

\sphinxAtStartPar
* means that the parameter is a Fagus\sphinxhyphen{}Setting, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{index}} \textendash{} \textasciitilde{} at which the value shall be inserted in the list at path

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value}} \textendash{} \textasciitilde{} is inserted at index into list at path, after creating new nodes along path as necessary

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} List/Tuple of key\sphinxhyphen{}values that are traversed in self. If no nodes exist at the keys, new nodes are
created. Can also be specified as a string, that is split into a tuple using value\_split. See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_types}} \textendash{} * Can be used to manually define if the nodes along path are supposed to be (l)ists or
(d)icts. E.g. “dll” to create a dict at level 1, and lists at level 2 and 3. ” ” can also be used \sphinxhyphen{}
space doesn’t enforce a node\sphinxhyphen{}type like d or l. For ” “, existing nodes are traversed if possible,
otherwise default\_node\_type is used to create new nodes. Default “”, interpreted as ” ” at each level.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{list\_insert}} \textendash{} * Level at which a new node shall be inserted into the list instead of traversing the
existing node in the list at that index. See README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value\_split}} \textendash{} * used to split path into a list if path is a string, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * return self as a Fagus\sphinxhyphen{}object if it is a node (tuple / list / dict), default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{if\_}} \textendash{} * only insert value if it meets the condition specified here, otherwise do nothing. The condition can
be a lambda, any value or a tuple of accepted values. Default \_None (don’t check value)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default\_node\_type}} \textendash{} * determines if new nodes by default should be created as (d)ict or (l)ist. Must be
either “d” or “l”, default “d”

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} if this is set, a copy of self is modified and then returned (thus self is not modified)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
self as a node if fagus is set, or a modified copy of self if copy is set

\item[{Raises}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if it isn’t possible to parse an int\sphinxhyphen{}index from the provided key in a position where node\sphinxhyphen{}types
    defines that the node shall be a list (if node\sphinxhyphen{}types is not l, the node will be replaced with a dict)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if path is empty and the root node is not a list (can’t insert into dict, tuple or set) or the
    root node needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{add() (fagus.fagus.Fagus method)@\spxentry{add()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.add}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add}}}{\emph{\DUrole{n}{value}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{node\_types}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{list\_insert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{value\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{if\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{default\_node\_type}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ collections.abc.Collection}}
\pysigstopsignatures
\sphinxAtStartPar
Create (if they don’t already exist) all sub\sphinxhyphen{}nodes in path, and finally add new value to set at leaf\sphinxhyphen{}node

\sphinxAtStartPar
If the leaf\sphinxhyphen{}node is a list, tuple or other value it is converted to a set, to which the new value is added

\sphinxAtStartPar
* means that the parameter is a Fagus\sphinxhyphen{}Setting, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value}} \textendash{} \textasciitilde{} is added to set at path, after creating new nodes along path as necessary

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} List/Tuple of key\sphinxhyphen{}values that are traversed in self. If no nodes exist at the keys, new nodes are
created. Can also be specified as a string, that is split into a tuple using value\_split. See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_types}} \textendash{} * Can be used to manually define if the nodes along path are supposed to be (l)ists or
(d)icts. E.g. “dll” to create a dict at level 1, and lists at level 2 and 3. ” ” can also be used \sphinxhyphen{}
space doesn’t enforce a node\sphinxhyphen{}type like d or l. For ” “, existing nodes are traversed if possible,
otherwise default\_node\_type is used to create new nodes. Default “”, interpreted as ” ” at each level.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{list\_insert}} \textendash{} * Level at which a new node shall be inserted into the list instead of traversing the
existing node in the list at that index. See README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value\_split}} \textendash{} * used to split path into a list if path is a string, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * return self as a Fagus\sphinxhyphen{}object if it is a node (tuple / list / dict), default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{if\_}} \textendash{} * only add value if it meets the condition specified here, otherwise do nothing. The condition can be
a lambda, any value or a tuple of accepted values. Default \_None (don’t check value)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default\_node\_type}} \textendash{} * determines if new nodes by default should be created as (d)ict or (l)ist. Must be
either “d” or “l”, default “d”

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} if this is set, a copy of self is modified and then returned (thus self is not modified)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
self as a node if fagus is set, or a modified copy of self if copy is set

\item[{Raises}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if it isn’t possible to parse an int\sphinxhyphen{}index from the provided key in a position where node\sphinxhyphen{}types
    defines that the node shall be a list (if node\sphinxhyphen{}types is not l, the node will be replaced with a dict)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if path is empty and the root node is not a set (can’t add to list or dict) or the root node
    needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{update() (fagus.fagus.Fagus method)@\spxentry{update()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.update}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{update}}}{\emph{\DUrole{n}{values}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{collections.abc.Iterable}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{node\_types}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{list\_insert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{value\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{if\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{default\_node\_type}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ collections.abc.Collection}}
\pysigstopsignatures
\sphinxAtStartPar
Create (if they don’t already exist) all sub\sphinxhyphen{}nodes in path, then update set at leaf\sphinxhyphen{}node with new values

\sphinxAtStartPar
If the leaf\sphinxhyphen{}node is a list, tuple or other value it is converted to a set. That set is then updated with the new
values. If the node at path is a dict, and values also is a dict, the node\sphinxhyphen{}dict is updated with the new values.

\sphinxAtStartPar
* means that the parameter is a Fagus\sphinxhyphen{}Setting, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{values}} \textendash{} the set/dict at path is updated with \textasciitilde{}, after creating new nodes along path as necessary

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} List/Tuple of key\sphinxhyphen{}values that are traversed in self. If no nodes exist at the keys, new nodes are
created. Can also be specified as a string, that is split into a tuple using value\_split. See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_types}} \textendash{} * Can be used to manually define if the nodes along path are supposed to be (l)ists or
(d)icts. E.g. “dll” to create a dict at level 1, and lists at level 2 and 3. ” ” can also be used \sphinxhyphen{}
space doesn’t enforce a node\sphinxhyphen{}type like d or l. For ” “, existing nodes are traversed if possible,
otherwise default\_node\_type is used to create new nodes. Default “”, interpreted as ” ” at each level.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{list\_insert}} \textendash{} * Level at which a new node shall be inserted into the list instead of traversing the
existing node in the list at that index. See README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value\_split}} \textendash{} * used to split path into a list if path is a string, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * return self as a Fagus\sphinxhyphen{}object if it is a node (tuple / list / dict), default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{if\_}} \textendash{} * only update with values if they meet the condition specified here, otherwise do nothing. The
condition can be a lambda, any value or a tuple of accepted values. Default \_None (don’t check values)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default\_node\_type}} \textendash{} * determines if new nodes by default should be created as (d)ict or (l)ist. Must be
either “d” or “l”, default “d”

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} if this is set, a copy of self is modified and then returned (thus self is not modified)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
self as a node if fagus is set, or a modified copy of self if copy is set

\item[{Raises}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if it isn’t possible to parse an int\sphinxhyphen{}index from the provided key in a position where node\sphinxhyphen{}types
    defines that the node shall be a list (if node\sphinxhyphen{}types is not l, the node will be replaced with a dict)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if path is empty and the root node is not a set or dict (can’t update list) or the root node
    needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{setdefault() (fagus.fagus.Fagus method)@\spxentry{setdefault()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.setdefault}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setdefault}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{default}\DUrole{o}{=}\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{node\_types}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{list\_insert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{value\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{default\_node\_type}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ Any}}
\pysigstopsignatures
\sphinxAtStartPar
Get value at path and return it. If there is no value at path, set default at path, and return default

\sphinxAtStartPar
* means that the parameter is a Fagus\sphinxhyphen{}Setting, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} position in self where default shall be set / from where value shall be fetched. See get() and README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default}} \textendash{} * returned if path doesn’t exist in self

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * return self as a Fagus\sphinxhyphen{}object if it is a node (tuple / list / dict), default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_types}} \textendash{} * Can be used to manually define if the nodes along path are supposed to be (l)ists or
(d)icts. E.g. “dll” to create a dict at level 1, and lists at level 2 and 3. ” ” can also be used \sphinxhyphen{}
space doesn’t enforce a node\sphinxhyphen{}type like d or l. For ” “, existing nodes are traversed if possible,
otherwise default\_node\_type is used to create new nodes. Default “”, interpreted as ” ” at each level.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{list\_insert}} \textendash{} * Level at which a new node shall be inserted into the list instead of traversing the
existing node in the list at that index. See README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default\_node\_type}} \textendash{} * determines if new nodes by default should be created as (d)ict or (l)ist. Must be
either “d” or “l”, default “d”

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
value at path if it exists, otherwise default is set at path and returned

\item[{Raises}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if it isn’t possible to parse an int\sphinxhyphen{}index from the provided key in a position where node\sphinxhyphen{}types
    defines that the node shall be a list (if node\sphinxhyphen{}types is not l, the node will be replaced with a dict)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if the root node needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{mod() (fagus.fagus.Fagus method)@\spxentry{mod()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.mod}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mod}}}{\emph{\DUrole{n}{mod\_function}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Callable}}, \emph{\DUrole{n}{path}}, \emph{\DUrole{n}{default}\DUrole{o}{=}\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{replace\_value}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{node\_types}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{list\_insert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{value\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{default\_node\_type}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ Any}}
\pysigstopsignatures
\sphinxAtStartPar
Modifies the value at path using the function\sphinxhyphen{}pointer mod\_function

\sphinxAtStartPar
mod can be used like this Fagus.mod(obj, “kitchen spoon”, lambda x: x + 1, 1) to count the number of spoons in
the kitchen. If there is no value to modify, the default value (here 1) will be set at the node.

\sphinxAtStartPar
* means that the parameter is a Fagus\sphinxhyphen{}Setting, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mod\_function}} \textendash{} A function pointer or lambda that modifies the existing value at path. TFunc can be used to
call more complex functions requiring several arguments.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} position in self at which the value shall be modified. Defined as a list/Tuple of key\sphinxhyphen{}values to
recursively traverse self. Can also be specified as string which is split into a tuple using value\_split

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default}} \textendash{} * this value is set in path if it doesn’t exist

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * Return new value as a Fagus\sphinxhyphen{}object if it is a node (tuple / list / dict), default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{replace\_value}} \textendash{} Replace the old value with what mod\_function returns. Can be deactivated e.g. if mod\_function
changes the object, but returns None (if \textasciitilde{} stays on, the object is replaced with None). Default True.
If no value exists at path, the default value is always set at path (independent of \textasciitilde{})

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_types}} \textendash{} * Can be used to manually define if the nodes along path are supposed to be (l)ists or
(d)icts. E.g. “dll” to create a dict at level 1, and lists at level 2 and 3. ” ” can also be used \sphinxhyphen{}
space doesn’t enforce a node\sphinxhyphen{}type like d or l. For ” “, existing nodes are traversed if possible,
otherwise default\_node\_type is used to create new nodes. Default “”, interpreted as ” ” at each level.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{list\_insert}} \textendash{} * Level at which a new node shall be inserted into the list instead of traversing the
existing node in the list at that index. See README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default\_node\_type}} \textendash{} * determines if new nodes by default should be created as (d)ict or (l)ist. Must be
either “d” or “l”, default “d”

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the new value that was returned by the mod\_function, or default if there was no value at path

\item[{Raises}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if it isn’t possible to parse an int\sphinxhyphen{}index from the provided key in a position where node\sphinxhyphen{}types
    defines that the node shall be a list (if node\sphinxhyphen{}types is not l, the node will be replaced with a dict)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if the root node needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{mod\_all() (fagus.fagus.Fagus method)@\spxentry{mod\_all()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.mod_all}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mod\_all}}}{\emph{\DUrole{n}{mod\_function}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Callable}}, \emph{\DUrole{n}{filter\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Optional\DUrole{p}{{[}}{\hyperref[\detokenize{fagus.filters:fagus.filters.Fil}]{\sphinxcrossref{fagus.filters.Fil}}}\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{None}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{replace\_value}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{default}\DUrole{o}{=}\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{max\_depth}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{9223372036854775807}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{value\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ collections.abc.Collection}}
\pysigstopsignatures
\sphinxAtStartPar
Modify all the leaf\sphinxhyphen{}values that match a certain filter

\sphinxAtStartPar
* means that the parameter is a Fagus\sphinxhyphen{}Setting, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mod\_function}} \textendash{} A function pointer or lambda that modifies the existing value at path. TFunc can be used to
call more complex functions requiring several arguments.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{filter\_}} \textendash{} used to select which leaves shall be modified. Default None (all leaves are modified)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} position in self at which the value shall be modified. See get() / README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default}} \textendash{} * this value is returned if path doesn’t exist, or if no leaves match the filter

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * Return new value as a Fagus\sphinxhyphen{}object if it is a node (tuple / list / dict), default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{replace\_value}} \textendash{} Replace the old value with what mod\_function returns. Can be deactivated e.g. if mod\_function
changes the object, but returns None (if \textasciitilde{} stays on, the object is replaced with None). Default True.
If no value exists at path, the default value is always set at path (independent of \textasciitilde{})

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max\_depth}} \textendash{} Defines the maximum depth for the iteration. See Fagus.iter max\_depth for more information

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} Can be ued to make sure that the node at path is not modified (instead a modified copy is returned)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the node at path where all the leaves matching filter\_ are modified, or default if it didn’t exist

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if the root node needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{description}\end{quote}

\end{fulllineitems}

\index{serialize() (fagus.fagus.Fagus method)@\spxentry{serialize()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.serialize}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{serialize}}}{\emph{\DUrole{n}{mod\_functions}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Optional\DUrole{p}{{[}}collections.abc.Mapping\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{None}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{node\_types}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{list\_insert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{value\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ Union\DUrole{p}{{[}}dict\DUrole{p}{,}\DUrole{w}{  }list\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Makes sure the object can be serialized so that it can be converted to JSON, YAML etc.

\sphinxAtStartPar
The only allowed data\sphinxhyphen{}types for serialization are: dict, list, bool, float, int, str, None

\sphinxAtStartPar
Sets and tuples are converted into lists. Other objects whose types are not allowed in serialized objects are
modified to a type that is allowed using the mod\_functions\sphinxhyphen{}parameter. mod\_functions is a dict, with the type
of object like IPv4Address or a tuple of types like (IPv4Address, IPv6Address). The values are function pointers
or lambdas, that are executed to convert e.g. an IPv4Address to one of the allowed data types mentioned above.

\sphinxAtStartPar
The default mod\_functions are: \{datetime: lambda x: x.isoformat(), date: lambda x: x.isoformat(), time:
lambda x: x.isoformat(), “default”: lambda x: str(x)\}

\sphinxAtStartPar
By default, date, datetime and time\sphinxhyphen{}objects are replaced by their isoformat\sphinxhyphen{}string. All other objects whose
types don’t appear in mod\_functions are modified by the function behind the key “default”. By default, this
function is lambda x: str(x) that replaces the object with its string\sphinxhyphen{}representation.

\sphinxAtStartPar
* means that the parameter is a Fagus\sphinxhyphen{}Setting, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mod\_functions}} \textendash{} * \textasciitilde{} is used to define how different types of objects are supposed to be serialized. This is
defined in a dict. The keys are either a type (like IPAddress) or a tuple of different types
(IPv4Address, IPv6Address). The values are function pointers, or lambdas, which are supposed to convert
e.g. an IPv4Address into a string. Check out TFunc if you want to call more complicated functions with
several arguments. See README for examples

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} position in self at which the value shall be modified. See get() / README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_types}} \textendash{} * Can be used to manually define if the nodes along path are supposed to be (l)ists or
(d)icts. E.g. “dll” to create a dict at level 1, and lists at level 2 and 3. ” ” can also be used \sphinxhyphen{}
space doesn’t enforce a node\sphinxhyphen{}type like d or l. For ” “, existing nodes are traversed if possible,
otherwise default\_node\_type is used to create new nodes. Default “”, interpreted as ” ” at each level.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{list\_insert}} \textendash{} * Level at which a new node shall be inserted into the list instead of traversing the
existing node in the list at that index. See README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} Create a copy and make that copy serializable. Default is to modify self directly

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a serializable object that only contains types allowed in json or yaml

\item[{Raises}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if root node is not a dict or list (serialize can’t fix that for the root node)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if tuple\_keys is not defined in mod\_functions and a dict has tuples as keys

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Exception}} \textendash{} Can raise any exception if it occurs in one of the mod\_functions

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{merge() (fagus.fagus.Fagus method)@\spxentry{merge()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.merge}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{merge}}}{\emph{\DUrole{n}{obj}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Union\DUrole{p}{{[}}{\hyperref[\detokenize{fagus.iterators:fagus.iterators.FagusIterator}]{\sphinxcrossref{fagus.iterators.FagusIterator}}}\DUrole{p}{,}\DUrole{w}{  }collections.abc.Collection\DUrole{p}{{]}}}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{new\_value\_action}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}r\textquotesingle{}}}, \emph{\DUrole{n}{extend\_from}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{9223372036854775807}}, \emph{\DUrole{n}{update\_from}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{9223372036854775807}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{copy\_obj}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{value\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{node\_types}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{list\_insert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{default\_node\_type}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ collections.abc.Collection}}
\pysigstopsignatures
\sphinxAtStartPar
Merges two or more tree\sphinxhyphen{}objects to update and extend the root node
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{obj}} \textendash{} tree\sphinxhyphen{}object that shall be merged. Can also be a FagusIterator returned from iter() to only merge
values matching a filter defined in iter()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} position in root where the new objects shall be merged, default “”

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{new\_value\_action}} \textendash{} This parameter defines what merge is supposed to do if a value at a path is present in the
root and in one of the objects to merge. The possible values are: (r)eplace \sphinxhyphen{} the value in the root is
replaced with the new value, this is the default behaviour; (i)gnore \sphinxhyphen{} the value in the root is not
updated; (a)ppend \sphinxhyphen{} the old and new value are both put into a list, and thus aggregated

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{extend\_from}} \textendash{} By default, lists are traversed, so the value at index i will be compared in both lists. If
at some point you rather want to just append the contents from the objects to be merged, use this
parameter to define the level (count of keys) from which lists should be extended isf traversed. Default
infinite (never extend lists)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{update\_from}} \textendash{} Like extend\_from, but for dicts. Allows you to define at which level the contents of the root
should just be updated with the contents of the objects instead of traversing and comparing each value

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} whether the returned tree\sphinxhyphen{}object should be returned as Fagus

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} Don’t modify the root node, modify and return a copy instead

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy\_obj}} \textendash{} The objects to be merged are not modified, but references to subnodes of the objects can be
put into the root node. Set this to True to prevent that and keep root and objects independent

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_types}} \textendash{} * Can be used to manually define if the nodes along path are supposed to be (l)ists or
(d)icts. E.g. “dll” to create a dict at level 1, and lists at level 2 and 3. ” ” can also be used \sphinxhyphen{}
space doesn’t enforce a node\sphinxhyphen{}type like d or l. For ” “, existing nodes are traversed if possible,
otherwise default\_node\_type is used to create new nodes. Default “”, interpreted as ” ” at each level.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{list\_insert}} \textendash{} * Level at which a new node shall be inserted into the list instead of traversing the
existing node in the list at that index. See README

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default\_node\_type}} \textendash{} * determines if new nodes by default should be created as (d)ict or (l)ist. Must be
either “d” or “l”, default “d”

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a reference to the modified root node, or a modified copy of the root node (see copy\sphinxhyphen{}parameter)

\item[{Raises}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} if it isn’t possible to parse an int\sphinxhyphen{}index from the provided key in a position where node\sphinxhyphen{}types
    defines that the node shall be a list (if node\sphinxhyphen{}types is not l, the node will be replaced with a dict)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if obj is not either a FagusIterator or a Collection. Also raised if you try to merge different
    types of nodes at root level, e.g. a dict can only be merged with another Mapping, and a list can only
    be merged with another Iterable. \textasciitilde{} is also raised if a not modifiable root node needs to be modified

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{pop() (fagus.fagus.Fagus method)@\spxentry{pop()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.pop}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pop}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{default}\DUrole{o}{=}\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{value\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Deletes the value at path and returns it

\sphinxAtStartPar
* means that the parameter is a Fagus\sphinxhyphen{}Setting, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} pop value at this position in self, or don’t do anything if path doesn’t exist in self

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default}} \textendash{} * returned if path doesn’t exist in self

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * return the result as Fagus\sphinxhyphen{}object if possible (default is just to return the result)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
value at path if it exists, or default if it doesn’t

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if the root node needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{description}\end{quote}

\end{fulllineitems}

\index{popitem() (fagus.fagus.Fagus method)@\spxentry{popitem()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.popitem}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{popitem}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
This function is not implemented in Fagus

\end{fulllineitems}

\index{discard() (fagus.fagus.Fagus method)@\spxentry{discard()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.discard}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{discard}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{value\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Deletes the value at path if it exists

\sphinxAtStartPar
* means that the parameter is a Fagus\sphinxhyphen{}Setting, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} pop value at this position in self, or don’t do anything if path doesn’t exist in self

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\end{itemize}

\end{description}\end{quote}

\sphinxAtStartPar
Returns: None

\end{fulllineitems}

\index{remove() (fagus.fagus.Fagus method)@\spxentry{remove()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.remove}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{remove}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{value\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Deletes the value at path if it exists, raises KeyError if it doesn’t

\sphinxAtStartPar
* means that the parameter is a Fagus\sphinxhyphen{}Setting, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} pop value at this position in self, or don’t do anything if path doesn’t exist in self

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\end{itemize}

\end{description}\end{quote}

\sphinxAtStartPar
Returns: None
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{KeyError}} \textendash{} if the value at path doesn’t exist

\end{description}\end{quote}

\end{fulllineitems}

\index{keys() (fagus.fagus.Fagus method)@\spxentry{keys()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.keys}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{keys}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{value\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Returns keys for the node at path, or None if that node is a set or doesn’t exist / doesn’t have keys

\sphinxAtStartPar
* means that the parameter is a Fagus\sphinxhyphen{}Setting, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} get keys for node at this position in self. Default “” (gets values from the root node), See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
keys for the node at path, or an empty tuple if that node is a set or doesn’t exist / doesn’t have keys

\end{description}\end{quote}

\end{fulllineitems}

\index{values() (fagus.fagus.Fagus method)@\spxentry{values()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.values}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{values}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{value\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Returns values for node at path

\sphinxAtStartPar
* means that the parameter is a Fagus\sphinxhyphen{}Setting, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} get values at this position in self, default “” (gets values from the root node). See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * converts sub\sphinxhyphen{}nodes into Fagus\sphinxhyphen{}objects in the returned list of values, default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} \textasciitilde{} creates a copy of the node before values() are returned. This can be beneficial if you want to make
changes to the returned nodes, but you don’t want to change self. Default False

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
values for the node at path. Returns an empty tuple if the value doesn’t exist, or just the value in a
tuple if the node isn’t iterable.

\end{description}\end{quote}

\end{fulllineitems}

\index{items() (fagus.fagus.Fagus method)@\spxentry{items()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.items}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{items}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{value\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Returns in iterator of (key, value)\sphinxhyphen{}tuples in self, like dict.items()

\sphinxAtStartPar
* means that the parameter is a Fagus\sphinxhyphen{}Setting, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} get items at this position in self, Default “” (gets values from the root node). See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * converts sub\sphinxhyphen{}nodes into Fagus\sphinxhyphen{}objects in the returned iterator, default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} \textasciitilde{} creates a copy of the node before items() are returned. This can be beneficial if you want to make
changes to the returned nodes, but you don’t want to change self. Default False

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
iterator of (key, value)\sphinxhyphen{}tuples in self, like dict.items()

\end{description}\end{quote}

\end{fulllineitems}

\index{clear() (fagus.fagus.Fagus method)@\spxentry{clear()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.clear}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{clear}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{value\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ collections.abc.Collection}}
\pysigstopsignatures
\sphinxAtStartPar
Removes all elements from node at path.

\sphinxAtStartPar
* means that the parameter is a Fagus\sphinxhyphen{}Setting, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} clear at this position in self, Default “” (gets values from the root node). See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} if \textasciitilde{} is set, a copy of self is modified and then returned (thus self is not modified), default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * return self as a Fagus\sphinxhyphen{}object if it is a node (tuple / list / dict), default False

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
self as a node if fagus is set, or a modified copy of self if copy is set

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if the root node needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{description}\end{quote}

\end{fulllineitems}

\index{contains() (fagus.fagus.Fagus method)@\spxentry{contains()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.contains}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{contains}}}{\emph{\DUrole{n}{value}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{value\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ bool}}
\pysigstopsignatures
\sphinxAtStartPar
Check if value is present in the node at path

\sphinxAtStartPar
* means that the parameter is a Fagus\sphinxhyphen{}Setting, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value}} \textendash{} value to check

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} check if value is in node at this position in self, Default “” (checks root node). See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
whether value is in node at path in self. returns value == node if the node isn’t iterable, and false if
path doesn’t exit in self

\end{description}\end{quote}

\end{fulllineitems}

\index{count() (fagus.fagus.Fagus method)@\spxentry{count()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.count}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{count}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{value\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ int}}
\pysigstopsignatures
\sphinxAtStartPar
Check the number of elements in the node at path

\sphinxAtStartPar
* means that the parameter is a Fagus\sphinxhyphen{}Setting, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} position in self where the number of elements shall be found.Default “” (checks root node). See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the number of elements in the node at path. if there is no node at path, 0 is returned. If the element
at path is not a node, 1 is returned

\end{description}\end{quote}

\end{fulllineitems}

\index{index() (fagus.fagus.Fagus method)@\spxentry{index()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.index}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{index}}}{\emph{\DUrole{n}{value}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}}, \emph{\DUrole{n}{start}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{stop}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{all\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{value\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}}{{ $\rightarrow$ Optional\DUrole{p}{{[}}Union\DUrole{p}{{[}}int\DUrole{p}{,}\DUrole{w}{  }Any\DUrole{p}{,}\DUrole{w}{  }collections.abc.Sequence\DUrole{p}{{]}}\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Returns the index / key of the specified value in the node at path if it exists
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value}} \textendash{} \textasciitilde{} to search index for

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{start}} \textendash{} start searching at this index. Only applicable if the node at path is a list / tuple

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{stop}} \textendash{} stop searching at this index. Only applicable if the node at path is a list / tuple

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} position in self where the node shall be searched for value. Default “” (checks root node). See get()

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{all\_}} \textendash{} returns all matching indices / keys in a generator (instead of only the first)

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
The first index of value if the node at path is a list, or the first key containing value if the node at
path is a dict. True if the node at path is a Set and contains value. If the element can’t be found in the
node at path, or there is no Collection at path, None is returned (instead of a ValueError).

\end{description}\end{quote}

\end{fulllineitems}

\index{isdisjoint() (fagus.fagus.Fagus method)@\spxentry{isdisjoint()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.isdisjoint}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{isdisjoint}}}{\emph{\DUrole{n}{other}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{collections.abc.Iterable}}, \emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{value\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{dict\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}keys\textquotesingle{}}}}{{ $\rightarrow$ bool}}
\pysigstopsignatures
\sphinxAtStartPar
Returns whether the other iterable is disjoint (has no common items) with the node at path

\sphinxAtStartPar
* means that the parameter is a Fagus\sphinxhyphen{}Setting, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{other}} \textendash{} other object to check

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} check if the node at this position in self, is disjoint from other

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dict\_}} \textendash{} use (k)eys, (v)alues or (i)tems for if value is a dict. Default keys

\end{itemize}

\end{description}\end{quote}
\begin{description}
\item[{Returns: whether the other iterable is disjoint from the value at path. If value is a dict, the keys are used.}] \leavevmode
\sphinxAtStartPar
Checks if value is present in other if value isn’t iterable. Returns True if there is no value at path.

\end{description}

\end{fulllineitems}

\index{child() (fagus.fagus.Fagus method)@\spxentry{child()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.child}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{child}}}{\emph{\DUrole{n}{obj}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Optional\DUrole{p}{{[}}collections.abc.Collection\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{{ $\rightarrow$ {\hyperref[\detokenize{fagus.fagus:fagus.fagus.Fagus}]{\sphinxcrossref{fagus.fagus.Fagus}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Creates a Fagus\sphinxhyphen{}object for obj that has the same options as self

\end{fulllineitems}

\index{reversed() (fagus.fagus.Fagus method)@\spxentry{reversed()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.reversed}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reversed}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{value\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Get reversed child\sphinxhyphen{}node at path if that node is a list

\sphinxAtStartPar
* means that the parameter is a Fagus\sphinxhyphen{}Setting, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} position in self where a list / tuple shall be returned reversed

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * converts sub\sphinxhyphen{}nodes into Fagus\sphinxhyphen{}objects in the returned iterator, default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} \textasciitilde{} creates a copy of the node before it is returned reversed(). This can be beneficial if you want to
make changes to the returned nodes, but you don’t want to change self. Default False

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a reversed iterator on the node at path (empty if path doesn’t exist)

\end{description}\end{quote}

\end{fulllineitems}

\index{reverse() (fagus.fagus.Fagus method)@\spxentry{reverse()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.reverse}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reverse}}}{\emph{\DUrole{n}{path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Any}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{fagus}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{value\_split}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{Ellipsis}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ collections.abc.Collection}}
\pysigstopsignatures
\sphinxAtStartPar
Reverse child\sphinxhyphen{}node at path if that node exists and is reversible

\sphinxAtStartPar
* means that the parameter is a Fagus\sphinxhyphen{}Setting, see Fagus\sphinxhyphen{}class\sphinxhyphen{}docstring for more information about options
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path}} \textendash{} position in self where a list / tuple shall be reversed

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fagus}} \textendash{} * converts sub\sphinxhyphen{}nodes into Fagus\sphinxhyphen{}objects in the returned iterator, default False

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value\_split}} \textendash{} * used to split path into a list if path is a str, default ” “

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{copy}} \textendash{} \textasciitilde{} creates a copy of the node before it is returned reversed(). This can be beneficial if you want to
make changes to the returned nodes, but you don’t want to change self. Default False

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
self as a node if fagus is set, or a modified copy of self if copy is set

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if the root node needs to be modified and isn’t modifiable (e.g. tuple or frozenset)

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (fagus.fagus.Fagus method)@\spxentry{copy()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.copy}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{\DUrole{n}{deep}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Creates a copy of self. Creates a recursive shallow copy by default, or a copy.deepcopy() if deep is set.

\end{fulllineitems}

\index{options() (fagus.fagus.Fagus method)@\spxentry{options()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.options}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{options}}}{\emph{\DUrole{n}{options}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Optional\DUrole{p}{{[}}dict\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{None}}, \emph{\DUrole{n}{get\_default\_options}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{reset}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ dict}}
\pysigstopsignatures
\sphinxAtStartPar
Function to set multiple Fagus\sphinxhyphen{}options in one line
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{options}} \textendash{} dict with options that shall be set

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{get\_default\_options}} \textendash{} return all options (include default\sphinxhyphen{}values). Default: only return options that are set

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{reset}} \textendash{} if \textasciitilde{} is set, all options are reset before options is set

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a dict of options that are set, or all options if get\_default\_options is set

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_copy\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_copy\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__copy__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_copy\_\_}}}{\emph{\DUrole{n}{recursive}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Recursively creates a shallow\sphinxhyphen{}copy of self

\end{fulllineitems}

\index{\_\_call\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_call\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__call__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_call\_\_}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Calling the Fagus\sphinxhyphen{}object returns the root node the Fagus\sphinxhyphen{}object is wrapped around (equivalent to .root)
\subsubsection*{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{fagus} \PYG{k+kn}{import} \PYG{n}{Fagus}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Fagus}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{q}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}
\PYG{g+go}{Fagus(\PYGZob{}\PYGZsq{}f\PYGZsq{}: \PYGZsq{}q\PYGZsq{}\PYGZcb{})}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}\PYGZsq{}f\PYGZsq{}: \PYGZsq{}q\PYGZsq{}\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{root}  \PYG{c+c1}{\PYGZsh{} .root returns the root\PYGZhy{}object in the same way as ()}
\PYG{g+go}{\PYGZob{}\PYGZsq{}f\PYGZsq{}: \PYGZsq{}q\PYGZsq{}\PYGZcb{}}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
the root object Fagus is wrapped around

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_getattr\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_getattr\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__getattr__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_getattr\_\_}}}{\emph{\DUrole{n}{attr}}}{}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_getitem\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_getitem\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__getitem__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_getitem\_\_}}}{\emph{\DUrole{n}{item}}}{}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_setattr\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_setattr\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__setattr__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_setattr\_\_}}}{\emph{\DUrole{n}{attr}}, \emph{\DUrole{n}{value}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Implement setattr(self, name, value).

\end{fulllineitems}

\index{\_\_setitem\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_setitem\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__setitem__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_setitem\_\_}}}{\emph{\DUrole{n}{path}}, \emph{\DUrole{n}{value}}}{}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_delattr\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_delattr\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__delattr__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_delattr\_\_}}}{\emph{\DUrole{n}{attr}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Implement delattr(self, name).

\end{fulllineitems}

\index{\_\_delitem\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_delitem\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__delitem__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_delitem\_\_}}}{\emph{\DUrole{n}{path}}}{}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_iter\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_iter\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__iter__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_iter\_\_}}}{}{}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_hash\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_hash\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__hash__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_hash\_\_}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Return hash(self).

\end{fulllineitems}

\index{\_\_eq\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_eq\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__eq__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_eq\_\_}}}{\emph{\DUrole{n}{other}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Return self==value.

\end{fulllineitems}

\index{\_\_ne\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_ne\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__ne__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_ne\_\_}}}{\emph{\DUrole{n}{other}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Return self!=value.

\end{fulllineitems}

\index{\_\_lt\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_lt\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__lt__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_lt\_\_}}}{\emph{\DUrole{n}{other}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Return self\textless{}value.

\end{fulllineitems}

\index{\_\_le\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_le\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__le__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_le\_\_}}}{\emph{\DUrole{n}{other}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Return self\textless{}=value.

\end{fulllineitems}

\index{\_\_gt\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_gt\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__gt__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_gt\_\_}}}{\emph{\DUrole{n}{other}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Return self\textgreater{}value.

\end{fulllineitems}

\index{\_\_ge\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_ge\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__ge__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_ge\_\_}}}{\emph{\DUrole{n}{other}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Return self\textgreater{}=value.

\end{fulllineitems}

\index{\_\_contains\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_contains\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__contains__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_contains\_\_}}}{\emph{\DUrole{n}{value}}}{}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_len\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_len\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__len__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_len\_\_}}}{}{}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_bool\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_bool\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__bool__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_bool\_\_}}}{}{}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_repr\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_repr\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__repr__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_repr\_\_}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Return repr(self).

\end{fulllineitems}

\index{\_\_str\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_str\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__str__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_str\_\_}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Return str(self).

\end{fulllineitems}

\index{\_\_iadd\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_iadd\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__iadd__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_iadd\_\_}}}{\emph{\DUrole{n}{value}}}{}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_add\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_add\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__add__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_add\_\_}}}{\emph{\DUrole{n}{other}}}{}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_radd\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_radd\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__radd__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_radd\_\_}}}{\emph{\DUrole{n}{other}}}{}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_isub\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_isub\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__isub__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_isub\_\_}}}{\emph{\DUrole{n}{other}}}{}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_sub\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_sub\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__sub__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_sub\_\_}}}{\emph{\DUrole{n}{other}}}{}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_rsub\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_rsub\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__rsub__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_rsub\_\_}}}{\emph{\DUrole{n}{other}}}{}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_imul\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_imul\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__imul__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_imul\_\_}}}{\emph{\DUrole{n}{times}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}}{}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_mul\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_mul\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__mul__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_mul\_\_}}}{\emph{\DUrole{n}{times}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}}{}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_rmul\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_rmul\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__rmul__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_rmul\_\_}}}{\emph{\DUrole{n}{times}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}}{}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_abstractmethods\_\_ (fagus.fagus.Fagus attribute)@\spxentry{\_\_abstractmethods\_\_}\spxextra{fagus.fagus.Fagus attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__abstractmethods__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_abstractmethods\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }frozenset(\{\})}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_dict\_\_ (fagus.fagus.Fagus attribute)@\spxentry{\_\_dict\_\_}\spxextra{fagus.fagus.Fagus attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__dict__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_dict\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }mappingproxy(\{\textquotesingle{}\_\_module\_\_\textquotesingle{}: \textquotesingle{}fagus.fagus\textquotesingle{}, \textquotesingle{}\_\_doc\_\_\textquotesingle{}: \textquotesingle{}Fagus is a wrapper\sphinxhyphen{}class for complex, nested objects of dicts and lists in Python\textbackslash{}n\textbackslash{}n    Fagus can be used as an object by instantiating it, but it\textbackslash{}\textquotesingle{}s also possible to use all methods statically without\textbackslash{}n    even an object, so that a = \{\}; Fagus.set(a, "top med", 1) and a = Fagus(\{\}); a.set(1, "top med") do the same.\textbackslash{}n\textbackslash{}n    The root node is always modified directly. If you don\textbackslash{}\textquotesingle{}t want to change the root node, all the functions where it\textbackslash{}n    makes sense support to rather modify a copy, and return that modified copy using the copy\sphinxhyphen{}parameter.\textbackslash{}n\textbackslash{}n    Several parameters used in functions in Fagus work as options so that you don\textbackslash{}\textquotesingle{}t have to specify them each time you\textbackslash{}n    run a function. In the docstrings, these options are marked with a \textbackslash{}\textbackslash{}*, e.g. the fagus parameter is an option.\textbackslash{}n    Options can be specified at three levels with increasing precedence: at class\sphinxhyphen{}level (Fagus.fagus = True), at\textbackslash{}n    object\sphinxhyphen{}level (a = Fagus(), a.fagus = True) and in each function\sphinxhyphen{}call (a.get("b", fagus=True)). If you generally want\textbackslash{}n    to change an option, change it at class\sphinxhyphen{}level \sphinxhyphen{} all objects in that file will inherit this option. If you want to\textbackslash{}n    change the option specifically for one object, change the option at object\sphinxhyphen{}level. If you only want to change the\textbackslash{}n    option for one single run of a function, put it as a function\sphinxhyphen{}parameter. More thorough examples of options can be\textbackslash{}n    found in README.md.\textbackslash{}n    \textquotesingle{}, \textquotesingle{}\_\_init\_\_\textquotesingle{}: \textless{}function Fagus.\_\_init\_\_\textgreater{}, \textquotesingle{}get\textquotesingle{}: \textless{}function Fagus.get\textgreater{}, \textquotesingle{}iter\textquotesingle{}: \textless{}function Fagus.iter\textgreater{}, \textquotesingle{}filter\textquotesingle{}: \textless{}function Fagus.filter\textgreater{}, \textquotesingle{}split\textquotesingle{}: \textless{}function Fagus.split\textgreater{}, \textquotesingle{}\_split\_r\textquotesingle{}: \textless{}staticmethod object\textgreater{}, \textquotesingle{}set\textquotesingle{}: \textless{}function Fagus.set\textgreater{}, \textquotesingle{}append\textquotesingle{}: \textless{}function Fagus.append\textgreater{}, \textquotesingle{}extend\textquotesingle{}: \textless{}function Fagus.extend\textgreater{}, \textquotesingle{}insert\textquotesingle{}: \textless{}function Fagus.insert\textgreater{}, \textquotesingle{}add\textquotesingle{}: \textless{}function Fagus.add\textgreater{}, \textquotesingle{}update\textquotesingle{}: \textless{}function Fagus.update\textgreater{}, \textquotesingle{}\_build\_node\textquotesingle{}: \textless{}function Fagus.\_build\_node\textgreater{}, \textquotesingle{}\_put\_value\textquotesingle{}: \textless{}staticmethod object\textgreater{}, \textquotesingle{}setdefault\textquotesingle{}: \textless{}function Fagus.setdefault\textgreater{}, \textquotesingle{}mod\textquotesingle{}: \textless{}function Fagus.mod\textgreater{}, \textquotesingle{}mod\_all\textquotesingle{}: \textless{}function Fagus.mod\_all\textgreater{}, \textquotesingle{}serialize\textquotesingle{}: \textless{}function Fagus.serialize\textgreater{}, \textquotesingle{}\_serialize\_r\textquotesingle{}: \textless{}staticmethod object\textgreater{}, \textquotesingle{}\_serializable\_value\textquotesingle{}: \textless{}staticmethod object\textgreater{}, \textquotesingle{}merge\textquotesingle{}: \textless{}function Fagus.merge\textgreater{}, \textquotesingle{}pop\textquotesingle{}: \textless{}function Fagus.pop\textgreater{}, \textquotesingle{}popitem\textquotesingle{}: \textless{}function Fagus.popitem\textgreater{}, \textquotesingle{}discard\textquotesingle{}: \textless{}function Fagus.discard\textgreater{}, \textquotesingle{}remove\textquotesingle{}: \textless{}function Fagus.remove\textgreater{}, \textquotesingle{}keys\textquotesingle{}: \textless{}function Fagus.keys\textgreater{}, \textquotesingle{}values\textquotesingle{}: \textless{}function Fagus.values\textgreater{}, \textquotesingle{}items\textquotesingle{}: \textless{}function Fagus.items\textgreater{}, \textquotesingle{}clear\textquotesingle{}: \textless{}function Fagus.clear\textgreater{}, \textquotesingle{}contains\textquotesingle{}: \textless{}function Fagus.contains\textgreater{}, \textquotesingle{}count\textquotesingle{}: \textless{}function Fagus.count\textgreater{}, \textquotesingle{}index\textquotesingle{}: \textless{}function Fagus.index\textgreater{}, \textquotesingle{}isdisjoint\textquotesingle{}: \textless{}function Fagus.isdisjoint\textgreater{}, \textquotesingle{}child\textquotesingle{}: \textless{}function Fagus.child\textgreater{}, \textquotesingle{}reversed\textquotesingle{}: \textless{}function Fagus.reversed\textgreater{}, \textquotesingle{}reverse\textquotesingle{}: \textless{}function Fagus.reverse\textgreater{}, \textquotesingle{}copy\textquotesingle{}: \textless{}function Fagus.copy\textgreater{}, \textquotesingle{}options\textquotesingle{}: \textless{}function Fagus.options\textgreater{}, \textquotesingle{}\_opt\textquotesingle{}: \textless{}function Fagus.\_opt\textgreater{}, \textquotesingle{}\_ensure\_mutable\_node\textquotesingle{}: \textless{}staticmethod object\textgreater{}, \textquotesingle{}\_get\_mutable\_node\textquotesingle{}: \textless{}function Fagus.\_get\_mutable\_node\textgreater{}, \textquotesingle{}\_node\_type\textquotesingle{}: \textless{}staticmethod object\textgreater{}, \textquotesingle{}\_hash\textquotesingle{}: \textless{}function Fagus.\_hash\textgreater{}, \textquotesingle{}\_\_copy\_\_\textquotesingle{}: \textless{}function Fagus.\_\_copy\_\_\textgreater{}, \textquotesingle{}\_\_call\_\_\textquotesingle{}: \textless{}function Fagus.\_\_call\_\_\textgreater{}, \textquotesingle{}\_\_getattr\_\_\textquotesingle{}: \textless{}function Fagus.\_\_getattr\_\_\textgreater{}, \textquotesingle{}\_\_getitem\_\_\textquotesingle{}: \textless{}function Fagus.\_\_getitem\_\_\textgreater{}, \textquotesingle{}\_\_setattr\_\_\textquotesingle{}: \textless{}function Fagus.\_\_setattr\_\_\textgreater{}, \textquotesingle{}\_\_setitem\_\_\textquotesingle{}: \textless{}function Fagus.\_\_setitem\_\_\textgreater{}, \textquotesingle{}\_\_delattr\_\_\textquotesingle{}: \textless{}function Fagus.\_\_delattr\_\_\textgreater{}, \textquotesingle{}\_\_delitem\_\_\textquotesingle{}: \textless{}function Fagus.\_\_delitem\_\_\textgreater{}, \textquotesingle{}\_\_iter\_\_\textquotesingle{}: \textless{}function Fagus.\_\_iter\_\_\textgreater{}, \textquotesingle{}\_\_hash\_\_\textquotesingle{}: \textless{}function Fagus.\_\_hash\_\_\textgreater{}, \textquotesingle{}\_\_eq\_\_\textquotesingle{}: \textless{}function Fagus.\_\_eq\_\_\textgreater{}, \textquotesingle{}\_\_ne\_\_\textquotesingle{}: \textless{}function Fagus.\_\_ne\_\_\textgreater{}, \textquotesingle{}\_\_lt\_\_\textquotesingle{}: \textless{}function Fagus.\_\_lt\_\_\textgreater{}, \textquotesingle{}\_\_le\_\_\textquotesingle{}: \textless{}function Fagus.\_\_le\_\_\textgreater{}, \textquotesingle{}\_\_gt\_\_\textquotesingle{}: \textless{}function Fagus.\_\_gt\_\_\textgreater{}, \textquotesingle{}\_\_ge\_\_\textquotesingle{}: \textless{}function Fagus.\_\_ge\_\_\textgreater{}, \textquotesingle{}\_\_contains\_\_\textquotesingle{}: \textless{}function Fagus.\_\_contains\_\_\textgreater{}, \textquotesingle{}\_\_len\_\_\textquotesingle{}: \textless{}function Fagus.\_\_len\_\_\textgreater{}, \textquotesingle{}\_\_bool\_\_\textquotesingle{}: \textless{}function Fagus.\_\_bool\_\_\textgreater{}, \textquotesingle{}\_\_repr\_\_\textquotesingle{}: \textless{}function Fagus.\_\_repr\_\_\textgreater{}, \textquotesingle{}\_\_str\_\_\textquotesingle{}: \textless{}function Fagus.\_\_str\_\_\textgreater{}, \textquotesingle{}\_\_iadd\_\_\textquotesingle{}: \textless{}function Fagus.\_\_iadd\_\_\textgreater{}, \textquotesingle{}\_\_add\_\_\textquotesingle{}: \textless{}function Fagus.\_\_add\_\_\textgreater{}, \textquotesingle{}\_\_radd\_\_\textquotesingle{}: \textless{}function Fagus.\_\_radd\_\_\textgreater{}, \textquotesingle{}\_\_isub\_\_\textquotesingle{}: \textless{}function Fagus.\_\_isub\_\_\textgreater{}, \textquotesingle{}\_\_sub\_\_\textquotesingle{}: \textless{}function Fagus.\_\_sub\_\_\textgreater{}, \textquotesingle{}\_\_rsub\_\_\textquotesingle{}: \textless{}function Fagus.\_\_rsub\_\_\textgreater{}, \textquotesingle{}\_\_imul\_\_\textquotesingle{}: \textless{}function Fagus.\_\_imul\_\_\textgreater{}, \textquotesingle{}\_\_mul\_\_\textquotesingle{}: \textless{}function Fagus.\_\_mul\_\_\textgreater{}, \textquotesingle{}\_\_rmul\_\_\textquotesingle{}: \textless{}function Fagus.\_\_rmul\_\_\textgreater{}, \textquotesingle{}\_\_reversed\_\_\textquotesingle{}: \textless{}function Fagus.\_\_reversed\_\_\textgreater{}, \textquotesingle{}\_\_reduce\_\_\textquotesingle{}: \textless{}function Fagus.\_\_reduce\_\_\textgreater{}, \textquotesingle{}\_\_reduce\_ex\_\_\textquotesingle{}: \textless{}function Fagus.\_\_reduce\_ex\_\_\textgreater{}, \textquotesingle{}\_\_dict\_\_\textquotesingle{}: \textless{}attribute \textquotesingle{}\_\_dict\_\_\textquotesingle{} of \textquotesingle{}Fagus\textquotesingle{} objects\textgreater{}, \textquotesingle{}\_\_weakref\_\_\textquotesingle{}: \textless{}attribute \textquotesingle{}\_\_weakref\_\_\textquotesingle{} of \textquotesingle{}Fagus\textquotesingle{} objects\textgreater{}, \textquotesingle{}\_\_abstractmethods\_\_\textquotesingle{}: frozenset(), \textquotesingle{}\_abc\_impl\textquotesingle{}: \textless{}\_abc\_data object\textgreater{}, \textquotesingle{}\_\_annotations\_\_\textquotesingle{}: \{\}\})}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_module\_\_ (fagus.fagus.Fagus attribute)@\spxentry{\_\_module\_\_}\spxextra{fagus.fagus.Fagus attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__module__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_module\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }\textquotesingle{}fagus.fagus\textquotesingle{}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_reversed\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_reversed\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__reversed__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_reversed\_\_}}}{}{}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_weakref\_\_ (fagus.fagus.Fagus attribute)@\spxentry{\_\_weakref\_\_}\spxextra{fagus.fagus.Fagus attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__weakref__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_weakref\_\_}}}
\pysigstopsignatures
\sphinxAtStartPar
list of weak references to the object (if defined)

\end{fulllineitems}

\index{\_\_reduce\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_reduce\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__reduce__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_reduce\_\_}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Helper for pickle.

\end{fulllineitems}

\index{\_\_reduce\_ex\_\_() (fagus.fagus.Fagus method)@\spxentry{\_\_reduce\_ex\_\_()}\spxextra{fagus.fagus.Fagus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.fagus:fagus.fagus.Fagus.__reduce_ex__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_reduce\_ex\_\_}}}{\emph{\DUrole{n}{protocol}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Helper for pickle.

\end{fulllineitems}


\end{fulllineitems}


\sphinxstepscope


\subsection{fagus.filters module}
\label{\detokenize{fagus.filters:module-fagus.filters}}\label{\detokenize{fagus.filters:fagus-filters-module}}\label{\detokenize{fagus.filters::doc}}\index{module@\spxentry{module}!fagus.filters@\spxentry{fagus.filters}}\index{fagus.filters@\spxentry{fagus.filters}!module@\spxentry{module}}
\sphinxAtStartPar
This module contains filter\sphinxhyphen{}classes used in Fagus
\index{FilBase (class in fagus.filters)@\spxentry{FilBase}\spxextra{class in fagus.filters}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.FilBase}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{fagus.filters.}}\sphinxbfcode{\sphinxupquote{FilBase}}}{\emph{\DUrole{o}{*}\DUrole{n}{filter\_args}}, \emph{\DUrole{n}{inexclude}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
FilterBase \sphinxhyphen{} base\sphinxhyphen{}class for all filters used in Fagus, providing basic functions shared by all filters
\index{\_\_init\_\_() (fagus.filters.FilBase method)@\spxentry{\_\_init\_\_()}\spxextra{fagus.filters.FilBase method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.FilBase.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{o}{*}\DUrole{n}{filter\_args}}, \emph{\DUrole{n}{inexclude}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Basic constructor for all filter\sphinxhyphen{}classes used in Fagus
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{*filter\_args}} \textendash{} Each argument filters one key in the tree, the last argument filters the leaf\sphinxhyphen{}value. You can
put a list of values to match different values in the same filter. In this list, you can also specify
subfilters to match different grains differently.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{inexclude}} \textendash{} In some cases it’s easier to specify that a filter shall match everything except b, rather than
match a. \textasciitilde{} can be used to specify for each argument if the filter shall include it (+) or exclude it
(\sphinxhyphen{}). Valid example: “++\sphinxhyphen{}+”. If this parameter isn’t specified, all args will be treated as (+).

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{included() (fagus.filters.FilBase method)@\spxentry{included()}\spxextra{fagus.filters.FilBase method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.FilBase.included}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{included}}}{\emph{\DUrole{n}{index}}}{{ $\rightarrow$ bool}}
\pysigstopsignatures
\sphinxAtStartPar
This function returns if the filter should be an include\sphinxhyphen{}filter (+) or an exclude\sphinxhyphen{}filter (\sphinxhyphen{}) at a given index
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{index}} \textendash{} index in filter\sphinxhyphen{}arguments that shall be interpreted as include\sphinxhyphen{} or exclude\sphinxhyphen{}filter

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\begin{description}
\item[{bool that is True if it is an include\sphinxhyphen{}filter, and False if it is an Exclude\sphinxhyphen{}Filter, defaults to True if}] \leavevmode
\sphinxAtStartPar
undefined at index

\end{description}


\end{description}\end{quote}

\end{fulllineitems}

\index{match\_node() (fagus.filters.FilBase method)@\spxentry{match\_node()}\spxextra{fagus.filters.FilBase method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.FilBase.match_node}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{match\_node}}}{\emph{\DUrole{n}{node}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{collections.abc.Collection}}, \emph{\DUrole{n}{\_}\DUrole{o}{=}\DUrole{default_value}{None}}}{{ $\rightarrow$ bool}}
\pysigstopsignatures
\sphinxAtStartPar
This method is overridden by CheckFilter and ValueFilter, and otherwise not in use

\end{fulllineitems}

\index{\_\_dict\_\_ (fagus.filters.FilBase attribute)@\spxentry{\_\_dict\_\_}\spxextra{fagus.filters.FilBase attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.FilBase.__dict__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_dict\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }mappingproxy(\{\textquotesingle{}\_\_module\_\_\textquotesingle{}: \textquotesingle{}fagus.filters\textquotesingle{}, \textquotesingle{}\_\_doc\_\_\textquotesingle{}: \textquotesingle{}FilterBase \sphinxhyphen{} base\sphinxhyphen{}class for all filters used in Fagus, providing basic functions shared by all filters\textquotesingle{}, \textquotesingle{}\_\_init\_\_\textquotesingle{}: \textless{}function FilBase.\_\_init\_\_\textgreater{}, \textquotesingle{}included\textquotesingle{}: \textless{}function FilBase.included\textgreater{}, \textquotesingle{}match\_node\textquotesingle{}: \textless{}function FilBase.match\_node\textgreater{}, \textquotesingle{}\_\_dict\_\_\textquotesingle{}: \textless{}attribute \textquotesingle{}\_\_dict\_\_\textquotesingle{} of \textquotesingle{}FilBase\textquotesingle{} objects\textgreater{}, \textquotesingle{}\_\_weakref\_\_\textquotesingle{}: \textless{}attribute \textquotesingle{}\_\_weakref\_\_\textquotesingle{} of \textquotesingle{}FilBase\textquotesingle{} objects\textgreater{}, \textquotesingle{}\_\_annotations\_\_\textquotesingle{}: \{\}\})}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_module\_\_ (fagus.filters.FilBase attribute)@\spxentry{\_\_module\_\_}\spxextra{fagus.filters.FilBase attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.FilBase.__module__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_module\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }\textquotesingle{}fagus.filters\textquotesingle{}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_weakref\_\_ (fagus.filters.FilBase attribute)@\spxentry{\_\_weakref\_\_}\spxextra{fagus.filters.FilBase attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.FilBase.__weakref__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_weakref\_\_}}}
\pysigstopsignatures
\sphinxAtStartPar
list of weak references to the object (if defined)

\end{fulllineitems}


\end{fulllineitems}

\index{VFil (class in fagus.filters)@\spxentry{VFil}\spxextra{class in fagus.filters}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.VFil}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{fagus.filters.}}\sphinxbfcode{\sphinxupquote{VFil}}}{\emph{\DUrole{o}{*}\DUrole{n}{filter\_args}}, \emph{\DUrole{n}{inexclude}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{invert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{fagus.filters:fagus.filters.FilBase}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fagus.filters.FilBase}}}}}

\sphinxAtStartPar
ValueFilter \sphinxhyphen{} This special type of filter can be used to inspect the entire node

\sphinxAtStartPar
It can be used to e.g. select all the nodes that contain at least 10 elements. See README for an example
\index{\_\_init\_\_() (fagus.filters.VFil method)@\spxentry{\_\_init\_\_()}\spxextra{fagus.filters.VFil method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.VFil.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{o}{*}\DUrole{n}{filter\_args}}, \emph{\DUrole{n}{inexclude}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{invert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{}
\pysigstopsignatures\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{*filter\_args}} \textendash{} Each argument filters one key in the tree, the last argument filters the leaf\sphinxhyphen{}value. You can
put a list of values to match different values in the same filter. In this list, you can also specify
subfilters to match different grains differently.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{inexclude}} \textendash{} In some cases it’s easier to specify that a filter shall match everything except b, rather than
match a. \textasciitilde{} can be used to specify for each argument if the filter shall include it (+) or exclude it
(\sphinxhyphen{}). Valid example: “++\sphinxhyphen{}+”. If this parameter isn’t specified, all args will be treated as (+).

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{invert}} \textendash{} Invert this whole filter to match if it doesn’t match. E.g. if you want to select all the nodes
that don’t have a certain property.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{match\_node() (fagus.filters.VFil method)@\spxentry{match\_node()}\spxextra{fagus.filters.VFil method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.VFil.match_node}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{match\_node}}}{\emph{\DUrole{n}{node}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{collections.abc.Collection}}, \emph{\DUrole{n}{\_}\DUrole{o}{=}\DUrole{default_value}{None}}}{{ $\rightarrow$ bool}}
\pysigstopsignatures
\sphinxAtStartPar
Verify that a node matches ValueFilter
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node}} \textendash{} node to check

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{\_}} \textendash{} this argument is ignored

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
bool whether the filter matched

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_module\_\_ (fagus.filters.VFil attribute)@\spxentry{\_\_module\_\_}\spxextra{fagus.filters.VFil attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.VFil.__module__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_module\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }\textquotesingle{}fagus.filters\textquotesingle{}}}}
\pysigstopsignatures
\end{fulllineitems}


\end{fulllineitems}

\index{KFil (class in fagus.filters)@\spxentry{KFil}\spxextra{class in fagus.filters}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.KFil}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{fagus.filters.}}\sphinxbfcode{\sphinxupquote{KFil}}}{\emph{\DUrole{o}{*}\DUrole{n}{filter\_args}}, \emph{\DUrole{n}{inexclude}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{str\_as\_re}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{fagus.filters:fagus.filters.FilBase}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fagus.filters.FilBase}}}}}

\sphinxAtStartPar
KeyFilter \sphinxhyphen{} Base class for filters in Fagus that inspect key\sphinxhyphen{}values to determine whether the filter matched
\index{\_\_init\_\_() (fagus.filters.KFil method)@\spxentry{\_\_init\_\_()}\spxextra{fagus.filters.KFil method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.KFil.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{o}{*}\DUrole{n}{filter\_args}}, \emph{\DUrole{n}{inexclude}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{str\_as\_re}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Initializes KeyFilter and verifies the arguments passed to it
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{*filter\_args}} \textendash{} Each argument filters one key in the tree, the last argument filters the leaf\sphinxhyphen{}value. You can
put a list of values to match different values in the same filter. In this list, you can also specify
subfilters to match different grains differently.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{inexclude}} \textendash{} In some cases it’s easier to specify that a filter shall match everything except b, rather than
match a. \textasciitilde{} can be used to specify for each argument if the filter shall include it (+) or exclude it
(\sphinxhyphen{}). Valid example: “++\sphinxhyphen{}+”. If this parameter isn’t specified, all args will be treated as (+).

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{str\_as\_re}} \textendash{} If this is set to True, it will be evaluated for all str’s if they’d match differently as a
regex, and in the latter case match these strings as regex patterns. E.g. re.match(“a.*”, b) will match
differently than “a.*” == b. In this case, “a.*” will be used as a regex\sphinxhyphen{}pattern. However
re.match(“abc”, b) will give the same result as “abc” == b, so here “abc” == b will be used.

\end{itemize}

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if the filters are not stacked correctly / stacked in a way that doesn’t make sense

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_getitem\_\_() (fagus.filters.KFil method)@\spxentry{\_\_getitem\_\_()}\spxextra{fagus.filters.KFil method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.KFil.__getitem__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_getitem\_\_}}}{\emph{\DUrole{n}{index}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}}{{ $\rightarrow$ Any}}
\pysigstopsignatures
\sphinxAtStartPar
Get filter\sphinxhyphen{}argument at index
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
filter\sphinxhyphen{}argument at index, \_None if index isn’t defined

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_setitem\_\_() (fagus.filters.KFil method)@\spxentry{\_\_setitem\_\_()}\spxextra{fagus.filters.KFil method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.KFil.__setitem__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_setitem\_\_}}}{\emph{\DUrole{n}{key}}, \emph{\DUrole{n}{value}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Set filter\sphinxhyphen{}argument at index. Throws IndexError if that index isn’t defined

\end{fulllineitems}

\index{match() (fagus.filters.KFil method)@\spxentry{match()}\spxextra{fagus.filters.KFil method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.KFil.match}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{match}}}{\emph{\DUrole{n}{value}}, \emph{\DUrole{n}{index}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{0}}, \emph{\DUrole{n}{\_}\DUrole{o}{=}\DUrole{default_value}{None}}}{{ $\rightarrow$ Tuple\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }Optional\DUrole{p}{{[}}{\hyperref[\detokenize{fagus.filters:fagus.filters.KFil}]{\sphinxcrossref{fagus.filters.KFil}}}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }int\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
match filter at index (matches recursively into subfilters if necessary)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value}} \textendash{} the value to be matched against the filter

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{index}} \textendash{} index of filter\sphinxhyphen{}argument to check

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{\_}} \textendash{} this argument is ignored

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\begin{description}
\item[{whether the value matched the filter, the filter that matched (as it can be a subfilter), and the next index}] \leavevmode
\sphinxAtStartPar
in that (sub)filter

\end{description}


\end{description}\end{quote}

\end{fulllineitems}

\index{match\_list() (fagus.filters.KFil method)@\spxentry{match\_list()}\spxextra{fagus.filters.KFil method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.KFil.match_list}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{match\_list}}}{\emph{\DUrole{n}{value}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{index}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{0}}, \emph{\DUrole{n}{node\_length}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{0}}}{{ $\rightarrow$ Tuple\DUrole{p}{{[}}bool\DUrole{p}{,}\DUrole{w}{  }Optional\DUrole{p}{{[}}{\hyperref[\detokenize{fagus.filters:fagus.filters.KFil}]{\sphinxcrossref{fagus.filters.KFil}}}\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }int\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
match\_list: same as match, but optimized to match list\sphinxhyphen{}indices (e. g. no regex\sphinxhyphen{}matching here)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value}} \textendash{} the value to be matched against the filter

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{index}} \textendash{} index of filter\sphinxhyphen{}argument to check

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_length}} \textendash{} length of the list whose indices shall be verified

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\begin{description}
\item[{whether the value matched the filter, the filter that matched (as it can be a subfilter), and the next index}] \leavevmode
\sphinxAtStartPar
in that (sub)filter

\end{description}


\end{description}\end{quote}

\end{fulllineitems}

\index{match\_extra\_filters() (fagus.filters.KFil method)@\spxentry{match\_extra\_filters()}\spxextra{fagus.filters.KFil method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.KFil.match_extra_filters}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{match\_extra\_filters}}}{\emph{\DUrole{n}{node}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{collections.abc.Collection}}, \emph{\DUrole{n}{index}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{0}}}{{ $\rightarrow$ bool}}
\pysigstopsignatures
\sphinxAtStartPar
Match extra filters on node (CFil and VFil).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node}} \textendash{} node to be verified

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{index}} \textendash{} filter\_index to check for extra filters

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
bool whether the extra filters matched

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_module\_\_ (fagus.filters.KFil attribute)@\spxentry{\_\_module\_\_}\spxextra{fagus.filters.KFil attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.KFil.__module__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_module\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }\textquotesingle{}fagus.filters\textquotesingle{}}}}
\pysigstopsignatures
\end{fulllineitems}


\end{fulllineitems}

\index{Fil (class in fagus.filters)@\spxentry{Fil}\spxextra{class in fagus.filters}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.Fil}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{fagus.filters.}}\sphinxbfcode{\sphinxupquote{Fil}}}{\emph{\DUrole{o}{*}\DUrole{n}{filter\_args}}, \emph{\DUrole{n}{inexclude}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{str\_as\_re}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{fagus.filters:fagus.filters.KFil}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fagus.filters.KFil}}}}}

\sphinxAtStartPar
TFilter \sphinxhyphen{} what matches this filter will actually be visible in the result. See README
\index{\_\_module\_\_ (fagus.filters.Fil attribute)@\spxentry{\_\_module\_\_}\spxextra{fagus.filters.Fil attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.Fil.__module__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_module\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }\textquotesingle{}fagus.filters\textquotesingle{}}}}
\pysigstopsignatures
\end{fulllineitems}


\end{fulllineitems}

\index{CFil (class in fagus.filters)@\spxentry{CFil}\spxextra{class in fagus.filters}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.CFil}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{fagus.filters.}}\sphinxbfcode{\sphinxupquote{CFil}}}{\emph{\DUrole{o}{*}\DUrole{n}{filter\_args}}, \emph{\DUrole{n}{inexclude}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{str\_as\_re}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{invert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{fagus.filters:fagus.filters.KFil}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fagus.filters.KFil}}}}}

\sphinxAtStartPar
CFil \sphinxhyphen{} can be used to select nodes based on values that shall not appear in the result. See README
\index{\_\_init\_\_() (fagus.filters.CFil method)@\spxentry{\_\_init\_\_()}\spxextra{fagus.filters.CFil method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.CFil.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{o}{*}\DUrole{n}{filter\_args}}, \emph{\DUrole{n}{inexclude}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{str\_as\_re}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{invert}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Initializes KeyFilter and verifies the arguments passed to it
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{*filter\_args}} \textendash{} Each argument filters one key in the tree, the last argument filters the leaf\sphinxhyphen{}value. You can
put a list of values to match different values in the same filter. In this list, you can also specify
subfilters to match different grains differently.

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{inexclude}} \textendash{} In some cases it’s easier to specify that a filter shall match everything except b, rather than
match a. \textasciitilde{} can be used to specify for each argument if the filter shall include it (+) or exclude it
(\sphinxhyphen{}). Valid example: “++\sphinxhyphen{}+”. If this parameter isn’t specified, all args will be treated as (+).

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{str\_as\_re}} \textendash{} If this is set to True, it will be evaluated for all str’s if they’d match differently as a
regex, and in the latter case match these strings as regex patterns. E.g. re.match(“a.*”, b) will match
differently than “a.*” == b. In this case, “a.*” will be used as a regex\sphinxhyphen{}pattern. However
re.match(“abc”, b) will give the same result as “abc” == b, so here “abc” == b will be used.

\end{itemize}

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} if the filters are not stacked correctly, or stacked in a way that doesn’t make sense

\end{description}\end{quote}

\end{fulllineitems}

\index{match\_node() (fagus.filters.CFil method)@\spxentry{match\_node()}\spxextra{fagus.filters.CFil method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.CFil.match_node}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{match\_node}}}{\emph{\DUrole{n}{node}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{collections.abc.Collection}}, \emph{\DUrole{n}{index}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{0}}}{{ $\rightarrow$ bool}}
\pysigstopsignatures
\sphinxAtStartPar
Recursive function to completely verify a node and its subnodes in CFil
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node}} \textendash{} node to check

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{index}} \textendash{} index in filter to check (filter is self)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
bool whether the filter matched

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_module\_\_ (fagus.filters.CFil attribute)@\spxentry{\_\_module\_\_}\spxextra{fagus.filters.CFil attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.filters:fagus.filters.CFil.__module__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_module\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }\textquotesingle{}fagus.filters\textquotesingle{}}}}
\pysigstopsignatures
\end{fulllineitems}


\end{fulllineitems}


\sphinxstepscope


\subsection{fagus.iterators module}
\label{\detokenize{fagus.iterators:module-fagus.iterators}}\label{\detokenize{fagus.iterators:fagus-iterators-module}}\label{\detokenize{fagus.iterators::doc}}\index{module@\spxentry{module}!fagus.iterators@\spxentry{fagus.iterators}}\index{fagus.iterators@\spxentry{fagus.iterators}!module@\spxentry{module}}
\sphinxAtStartPar
This module contains iterator\sphinxhyphen{}classes that are used to iterate over Fagus\sphinxhyphen{}objects
\index{FilteredIterator (class in fagus.iterators)@\spxentry{FilteredIterator}\spxextra{class in fagus.iterators}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.iterators:fagus.iterators.FilteredIterator}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{fagus.iterators.}}\sphinxbfcode{\sphinxupquote{FilteredIterator}}}{\emph{\DUrole{n}{obj}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{collections.abc.Collection}}, \emph{\DUrole{n}{filter\_value}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}}, \emph{\DUrole{n}{filter\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{{\hyperref[\detokenize{fagus.filters:fagus.filters.Fil}]{\sphinxcrossref{Fil}}}}}, \emph{\DUrole{n}{filter\_index}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{0}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Iterator class that gives keys and values for any Collection (use optimal\_iterator() to initialize it)
\index{optimal\_iterator() (fagus.iterators.FilteredIterator static method)@\spxentry{optimal\_iterator()}\spxextra{fagus.iterators.FilteredIterator static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.iterators:fagus.iterators.FilteredIterator.optimal_iterator}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static\DUrole{w}{  }}}\sphinxbfcode{\sphinxupquote{optimal\_iterator}}}{\emph{\DUrole{n}{obj}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{collections.abc.Collection}}, \emph{\DUrole{n}{filter\_value}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{filter\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{{\hyperref[\detokenize{fagus.filters:fagus.filters.Fil}]{\sphinxcrossref{Fil}}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{None}}, \emph{\DUrole{n}{filter\_index}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{0}}}{}
\pysigstopsignatures
\sphinxAtStartPar
This method returns the simplest possible Iterator to loop through a given object.

\sphinxAtStartPar
If no filter is present, either items or enumerate are called to loop through the keys, for sets … is put
as key for each value (as sets have no meaningful keys). If you additionally need filtering, this class is
initialized to support iteration on only the keys and values that pass the filter

\end{fulllineitems}

\index{\_\_init\_\_() (fagus.iterators.FilteredIterator method)@\spxentry{\_\_init\_\_()}\spxextra{fagus.iterators.FilteredIterator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.iterators:fagus.iterators.FilteredIterator.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{n}{obj}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{collections.abc.Collection}}, \emph{\DUrole{n}{filter\_value}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}}, \emph{\DUrole{n}{filter\_}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{{\hyperref[\detokenize{fagus.filters:fagus.filters.Fil}]{\sphinxcrossref{Fil}}}}}, \emph{\DUrole{n}{filter\_index}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{0}}}{}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_iter\_\_() (fagus.iterators.FilteredIterator method)@\spxentry{\_\_iter\_\_()}\spxextra{fagus.iterators.FilteredIterator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.iterators:fagus.iterators.FilteredIterator.__iter__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_iter\_\_}}}{}{}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_next\_\_() (fagus.iterators.FilteredIterator method)@\spxentry{\_\_next\_\_()}\spxextra{fagus.iterators.FilteredIterator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.iterators:fagus.iterators.FilteredIterator.__next__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_next\_\_}}}{}{}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_dict\_\_ (fagus.iterators.FilteredIterator attribute)@\spxentry{\_\_dict\_\_}\spxextra{fagus.iterators.FilteredIterator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.iterators:fagus.iterators.FilteredIterator.__dict__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_dict\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }mappingproxy(\{\textquotesingle{}\_\_module\_\_\textquotesingle{}: \textquotesingle{}fagus.iterators\textquotesingle{}, \textquotesingle{}\_\_doc\_\_\textquotesingle{}: \textquotesingle{}Iterator class that gives keys and values for any Collection (use optimal\_iterator() to initialize it)\textquotesingle{}, \textquotesingle{}optimal\_iterator\textquotesingle{}: \textless{}staticmethod object\textgreater{}, \textquotesingle{}\_\_init\_\_\textquotesingle{}: \textless{}function FilteredIterator.\_\_init\_\_\textgreater{}, \textquotesingle{}\_\_iter\_\_\textquotesingle{}: \textless{}function FilteredIterator.\_\_iter\_\_\textgreater{}, \textquotesingle{}\_\_next\_\_\textquotesingle{}: \textless{}function FilteredIterator.\_\_next\_\_\textgreater{}, \textquotesingle{}\_\_dict\_\_\textquotesingle{}: \textless{}attribute \textquotesingle{}\_\_dict\_\_\textquotesingle{} of \textquotesingle{}FilteredIterator\textquotesingle{} objects\textgreater{}, \textquotesingle{}\_\_weakref\_\_\textquotesingle{}: \textless{}attribute \textquotesingle{}\_\_weakref\_\_\textquotesingle{} of \textquotesingle{}FilteredIterator\textquotesingle{} objects\textgreater{}, \textquotesingle{}\_\_annotations\_\_\textquotesingle{}: \{\}\})}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_module\_\_ (fagus.iterators.FilteredIterator attribute)@\spxentry{\_\_module\_\_}\spxextra{fagus.iterators.FilteredIterator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.iterators:fagus.iterators.FilteredIterator.__module__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_module\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }\textquotesingle{}fagus.iterators\textquotesingle{}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_weakref\_\_ (fagus.iterators.FilteredIterator attribute)@\spxentry{\_\_weakref\_\_}\spxextra{fagus.iterators.FilteredIterator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.iterators:fagus.iterators.FilteredIterator.__weakref__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_weakref\_\_}}}
\pysigstopsignatures
\sphinxAtStartPar
list of weak references to the object (if defined)

\end{fulllineitems}


\end{fulllineitems}

\index{FagusIterator (class in fagus.iterators)@\spxentry{FagusIterator}\spxextra{class in fagus.iterators}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.iterators:fagus.iterators.FagusIterator}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{fagus.iterators.}}\sphinxbfcode{\sphinxupquote{FagusIterator}}}{\emph{\DUrole{n}{obj: Fagus}}, \emph{\DUrole{n}{max\_depth: int = 9223372036854775807}}, \emph{\DUrole{n}{filter\_: Fil = None}}, \emph{\DUrole{n}{fagus: bool = False}}, \emph{\DUrole{n}{iter\_fill=\textless{}class \textquotesingle{}fagus.utils.\_None\textquotesingle{}\textgreater{}}}, \emph{\DUrole{n}{select: typing.Union{[}int}}, \emph{\DUrole{n}{collections.abc.Iterable{]} = None}}, \emph{\DUrole{n}{iter\_nodes: bool = False}}, \emph{\DUrole{n}{copy: bool = False}}, \emph{\DUrole{n}{filter\_ends: bool = False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Iterator\sphinxhyphen{}class for Fagus to facilitate the complex iteration with filtering etc. in the tree\sphinxhyphen{}object

\sphinxAtStartPar
Internal \sphinxhyphen{} use Fagus.iter() to use this iterator on your object
\index{\_\_init\_\_() (fagus.iterators.FagusIterator method)@\spxentry{\_\_init\_\_()}\spxextra{fagus.iterators.FagusIterator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.iterators:fagus.iterators.FagusIterator.__init__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{n}{obj: Fagus}}, \emph{\DUrole{n}{max\_depth: int = 9223372036854775807}}, \emph{\DUrole{n}{filter\_: Fil = None}}, \emph{\DUrole{n}{fagus: bool = False}}, \emph{\DUrole{n}{iter\_fill=\textless{}class \textquotesingle{}fagus.utils.\_None\textquotesingle{}\textgreater{}}}, \emph{\DUrole{n}{select: typing.Union{[}int}}, \emph{\DUrole{n}{collections.abc.Iterable{]} = None}}, \emph{\DUrole{n}{iter\_nodes: bool = False}}, \emph{\DUrole{n}{copy: bool = False}}, \emph{\DUrole{n}{filter\_ends: bool = False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Internal function. Recursively iterates through Fagus\sphinxhyphen{}object

\sphinxAtStartPar
Initiate this iterator through Fagus.iter(), there the parameters are discussed as well.

\end{fulllineitems}

\index{\_\_iter\_\_() (fagus.iterators.FagusIterator method)@\spxentry{\_\_iter\_\_()}\spxextra{fagus.iterators.FagusIterator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.iterators:fagus.iterators.FagusIterator.__iter__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_iter\_\_}}}{}{}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_dict\_\_ (fagus.iterators.FagusIterator attribute)@\spxentry{\_\_dict\_\_}\spxextra{fagus.iterators.FagusIterator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.iterators:fagus.iterators.FagusIterator.__dict__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_dict\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }mappingproxy(\{\textquotesingle{}\_\_module\_\_\textquotesingle{}: \textquotesingle{}fagus.iterators\textquotesingle{}, \textquotesingle{}\_\_doc\_\_\textquotesingle{}: \textquotesingle{}Iterator\sphinxhyphen{}class for Fagus to facilitate the complex iteration with filtering etc. in the tree\sphinxhyphen{}object\textbackslash{}n\textbackslash{}n    Internal \sphinxhyphen{} use Fagus.iter() to use this iterator on your object\textquotesingle{}, \textquotesingle{}\_\_init\_\_\textquotesingle{}: \textless{}function FagusIterator.\_\_init\_\_\textgreater{}, \textquotesingle{}\_\_iter\_\_\textquotesingle{}: \textless{}function FagusIterator.\_\_iter\_\_\textgreater{}, \textquotesingle{}\_\_next\_\_\textquotesingle{}: \textless{}function FagusIterator.\_\_next\_\_\textgreater{}, \textquotesingle{}skip\textquotesingle{}: \textless{}function FagusIterator.skip\textgreater{}, \textquotesingle{}\_\_dict\_\_\textquotesingle{}: \textless{}attribute \textquotesingle{}\_\_dict\_\_\textquotesingle{} of \textquotesingle{}FagusIterator\textquotesingle{} objects\textgreater{}, \textquotesingle{}\_\_weakref\_\_\textquotesingle{}: \textless{}attribute \textquotesingle{}\_\_weakref\_\_\textquotesingle{} of \textquotesingle{}FagusIterator\textquotesingle{} objects\textgreater{}, \textquotesingle{}\_\_annotations\_\_\textquotesingle{}: \{\}\})}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_module\_\_ (fagus.iterators.FagusIterator attribute)@\spxentry{\_\_module\_\_}\spxextra{fagus.iterators.FagusIterator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.iterators:fagus.iterators.FagusIterator.__module__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_module\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }\textquotesingle{}fagus.iterators\textquotesingle{}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_next\_\_() (fagus.iterators.FagusIterator method)@\spxentry{\_\_next\_\_()}\spxextra{fagus.iterators.FagusIterator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.iterators:fagus.iterators.FagusIterator.__next__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_next\_\_}}}{}{}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_weakref\_\_ (fagus.iterators.FagusIterator attribute)@\spxentry{\_\_weakref\_\_}\spxextra{fagus.iterators.FagusIterator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.iterators:fagus.iterators.FagusIterator.__weakref__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_weakref\_\_}}}
\pysigstopsignatures
\sphinxAtStartPar
list of weak references to the object (if defined)

\end{fulllineitems}

\index{skip() (fagus.iterators.FagusIterator method)@\spxentry{skip()}\spxextra{fagus.iterators.FagusIterator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.iterators:fagus.iterators.FagusIterator.skip}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{skip}}}{\emph{\DUrole{n}{level}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{copy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ collections.abc.Collection}}
\pysigstopsignatures
\end{fulllineitems}


\end{fulllineitems}


\sphinxstepscope


\subsection{fagus.utils module}
\label{\detokenize{fagus.utils:module-fagus.utils}}\label{\detokenize{fagus.utils:fagus-utils-module}}\label{\detokenize{fagus.utils::doc}}\index{module@\spxentry{module}!fagus.utils@\spxentry{fagus.utils}}\index{fagus.utils@\spxentry{fagus.utils}!module@\spxentry{module}}
\sphinxAtStartPar
This module contains classes and functions used across the Fagus\sphinxhyphen{}library that didn’t fit in another module
\index{FagusMeta (class in fagus.utils)@\spxentry{FagusMeta}\spxextra{class in fagus.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.utils:fagus.utils.FagusMeta}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{fagus.utils.}}\sphinxbfcode{\sphinxupquote{FagusMeta}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{bases}}, \emph{\DUrole{n}{namespace}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{abc.ABCMeta}}

\sphinxAtStartPar
Metaclass for Fagus\sphinxhyphen{}objects to facilitate options at class\sphinxhyphen{}level
\index{\_\_verify\_option\_\_() (fagus.utils.FagusMeta static method)@\spxentry{\_\_verify\_option\_\_()}\spxextra{fagus.utils.FagusMeta static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.utils:fagus.utils.FagusMeta.__verify_option__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static\DUrole{w}{  }}}\sphinxbfcode{\sphinxupquote{\_\_verify\_option\_\_}}}{\emph{\DUrole{n}{option\_name}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}}, \emph{\DUrole{n}{option}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Verify Fagus\sphinxhyphen{}option using the functions / types in \_\_default\_options\_\_
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{option\_name}} \textendash{} name of the option to verify

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{option}} \textendash{} the value to be verified

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the option\sphinxhyphen{}value if it was valid (otherwise the function is left in an error)

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_default\_options\_\_ (fagus.utils.FagusMeta attribute)@\spxentry{\_\_default\_options\_\_}\spxextra{fagus.utils.FagusMeta attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.utils:fagus.utils.FagusMeta.__default_options__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_default\_options\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }\{\textquotesingle{}default\textquotesingle{}: (None,), \textquotesingle{}default\_node\_type\textquotesingle{}: (\textquotesingle{}d\textquotesingle{}, \textless{}class \textquotesingle{}str\textquotesingle{}\textgreater{}, \textless{}function FagusMeta.\textless{}lambda\textgreater{}\textgreater{}, \textquotesingle{}default\_node\_type must be either "d" for dict or "l" for list.\textquotesingle{}), \textquotesingle{}fagus\textquotesingle{}: (False, \textless{}class \textquotesingle{}bool\textquotesingle{}\textgreater{}), \textquotesingle{}if\_\textquotesingle{}: (\textless{}class \textquotesingle{}fagus.utils.\_None\textquotesingle{}\textgreater{},), \textquotesingle{}iter\_fill\textquotesingle{}: (\textless{}class \textquotesingle{}fagus.utils.\_None\textquotesingle{}\textgreater{},), \textquotesingle{}iter\_nodes\textquotesingle{}: (False, \textless{}class \textquotesingle{}bool\textquotesingle{}\textgreater{}), \textquotesingle{}list\_insert\textquotesingle{}: (9223372036854775807, \textless{}class \textquotesingle{}int\textquotesingle{}\textgreater{}, \textless{}function FagusMeta.\textless{}lambda\textgreater{}\textgreater{}, \textquotesingle{}list\sphinxhyphen{}insert must be a positive int. By default (list\_insert == INF), all existing list\sphinxhyphen{}indices are traversed. If list\sphinxhyphen{}insert \textless{} maxsize, earliest at level n a new node is inserted if that node is a list\textquotesingle{}), \textquotesingle{}node\_types\textquotesingle{}: (\textquotesingle{}\textquotesingle{}, \textless{}class \textquotesingle{}str\textquotesingle{}\textgreater{}, \textless{}function FagusMeta.\textless{}lambda\textgreater{}\textgreater{}, \textquotesingle{}The only allowed characters in node\_types are d (for dict) and l (for list). " " can also be used. In that case, existing nodes are used if possible, and default\_node\_type is used to create new nodes.\textquotesingle{}), \textquotesingle{}value\_split\textquotesingle{}: (\textquotesingle{} \textquotesingle{}, \textless{}class \textquotesingle{}str\textquotesingle{}\textgreater{}, \textless{}function FagusMeta.\textless{}lambda\textgreater{}\textgreater{}, \textquotesingle{}value\_split can\textbackslash{}\textquotesingle{}t be "", as a string can\textbackslash{}\textquotesingle{}t be split by "".\textquotesingle{})\}}}}
\pysigstopsignatures
\sphinxAtStartPar
Default values for all options used in Fagus

\end{fulllineitems}

\index{no\_node (fagus.utils.FagusMeta attribute)@\spxentry{no\_node}\spxextra{fagus.utils.FagusMeta attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.utils:fagus.utils.FagusMeta.no_node}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{no\_node}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }(\textless{}class \textquotesingle{}str\textquotesingle{}\textgreater{}, \textless{}class \textquotesingle{}bytes\textquotesingle{}\textgreater{}, \textless{}class \textquotesingle{}bytearray\textquotesingle{}\textgreater{})}}}
\pysigstopsignatures
\sphinxAtStartPar
Every type of Collection in no\_node will not be treated as a node, but as a single value

\end{fulllineitems}

\index{options() (fagus.utils.FagusMeta method)@\spxentry{options()}\spxextra{fagus.utils.FagusMeta method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.utils:fagus.utils.FagusMeta.options}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{options}}}{\emph{\DUrole{n}{options}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Optional\DUrole{p}{{[}}dict\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{None}}, \emph{\DUrole{n}{get\_default\_options}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}, \emph{\DUrole{n}{reset}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{{ $\rightarrow$ dict}}
\pysigstopsignatures
\sphinxAtStartPar
Function to set multiple Fagus\sphinxhyphen{}options in one line
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{options}} \textendash{} dict with options that shall be set

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{get\_default\_options}} \textendash{} return all options (include default\sphinxhyphen{}values). Default: only return options that are set

\item {}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{reset}} \textendash{} if \textasciitilde{} is set, all options are reset before options is set

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
a dict of options that are set, or all options if get\_default\_options is set

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_setattr\_\_() (fagus.utils.FagusMeta method)@\spxentry{\_\_setattr\_\_()}\spxextra{fagus.utils.FagusMeta method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.utils:fagus.utils.FagusMeta.__setattr__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_setattr\_\_}}}{\emph{\DUrole{n}{attr}}, \emph{\DUrole{n}{value}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Implement setattr(self, name, value).

\end{fulllineitems}

\index{\_\_getattr\_\_() (fagus.utils.FagusMeta method)@\spxentry{\_\_getattr\_\_()}\spxextra{fagus.utils.FagusMeta method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.utils:fagus.utils.FagusMeta.__getattr__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_getattr\_\_}}}{\emph{\DUrole{n}{attr}}}{}
\pysigstopsignatures
\end{fulllineitems}

\index{\_\_delattr\_\_() (fagus.utils.FagusMeta method)@\spxentry{\_\_delattr\_\_()}\spxextra{fagus.utils.FagusMeta method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.utils:fagus.utils.FagusMeta.__delattr__}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_delattr\_\_}}}{\emph{\DUrole{n}{attr}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Implement delattr(self, name).

\end{fulllineitems}

\index{\_\_module\_\_ (fagus.utils.FagusMeta attribute)@\spxentry{\_\_module\_\_}\spxextra{fagus.utils.FagusMeta attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{fagus.utils:fagus.utils.FagusMeta.__module__}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_module\_\_}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }\textquotesingle{}fagus.utils\textquotesingle{}}}}
\pysigstopsignatures
\end{fulllineitems}


\end{fulllineitems}


\sphinxstepscope


\chapter{Changelog}
\label{\detokenize{CHANGELOG:changelog}}\label{\detokenize{CHANGELOG::doc}}
\sphinxAtStartPar
\sphinxstylestrong{2022\sphinxhyphen{}05\sphinxhyphen{}13 1.0.1 Release of Fagus on GitHub and ReadTheDocs}

\sphinxAtStartPar
Now. Finally. The documentation is still not completely ready but it’s time to get some feedback from the community.

\sphinxAtStartPar
\sphinxstylestrong{2022\sphinxhyphen{}04\sphinxhyphen{}05 1.0.0 Renaming to Fagus}

\sphinxAtStartPar
Checking GitHub I found that there already were several other libraries and programs having TreeO as a name which I had chosen originally. I then found another (much cooler) name which wasn’t in use yet.

\sphinxAtStartPar
\sphinxstylestrong{2022\sphinxhyphen{}04 0.9.0 Release getting closer}

\sphinxAtStartPar
Development has been ongoing for almost a year. Documentation and testing takes time, but it is absolutely necessary for a library like this. Finally moving away from two Python\sphinxhyphen{}files (one for tests and one for the lib) to a proper \sphinxcode{\sphinxupquote{poetry}}\sphinxhyphen{}project, starting to implement sphinx to parse the docstrings that had been written earlier.

\sphinxAtStartPar
\sphinxstylestrong{2021\sphinxhyphen{}06 0.1.0 First idea for TreeO}

\sphinxAtStartPar
Development starts, the idea to this was born writing my Bachelor’s thesis where I felt that constantly writing \sphinxcode{\sphinxupquote{.get("a", \{\}).get("b", \{\}).get("c", \{\})}} was too annoying to go on with.

\sphinxstepscope


\chapter{Contributing to Fagus}
\label{\detokenize{CONTRIBUTING:contributing-to-fagus}}\label{\detokenize{CONTRIBUTING::doc}}
\sphinxAtStartPar
First off, welcome and thank you for taking the time to contribute to Fagus! Any contribution, big or small, is welcome to make Fagus more useful such that more people can benefit from it.

\sphinxAtStartPar
The following is a set of guidelines for contribution to Fagus, which is hosted by the \sphinxhref{https://github.com/treeorg}{treeorg} organisation on GitHub. They are mostly guidelines, not rules. All of this can be discussed \sphinxhyphen{} use your best judgement, and feel free to propose changes to this document in a pull request.


\section{Table of contents}
\label{\detokenize{CONTRIBUTING:table-of-contents}}
\sphinxAtStartPar
{\hyperref[\detokenize{CONTRIBUTING:fagus-principles}]{\sphinxcrossref{\DUrole{std,std-doc}{Fagus Principles}}}}

\sphinxAtStartPar
{\hyperref[\detokenize{CONTRIBUTING:how-can-i-contribute}]{\sphinxcrossref{\DUrole{std,std-doc}{How Can I Contribute?}}}}
\begin{itemize}
\item {}
\sphinxAtStartPar
{\hyperref[\detokenize{CONTRIBUTING:reporting-bugs}]{\sphinxcrossref{\DUrole{std,std-doc}{Reporting Bugs}}}}

\item {}
\sphinxAtStartPar
{\hyperref[\detokenize{CONTRIBUTING:requesting-new-features}]{\sphinxcrossref{\DUrole{std,std-doc}{Requesting New Features}}}}

\end{itemize}

\sphinxAtStartPar
{\hyperref[\detokenize{CONTRIBUTING:developing-fagus}]{\sphinxcrossref{\DUrole{std,std-doc}{Developing Fagus}}}}
\begin{itemize}
\item {}
\sphinxAtStartPar
{\hyperref[\detokenize{CONTRIBUTING:software-dependencies-for-development}]{\sphinxcrossref{\DUrole{std,std-doc}{Software Dependencies for Development}}}}

\item {}
\sphinxAtStartPar
{\hyperref[\detokenize{CONTRIBUTING:code-styling-guidelines}]{\sphinxcrossref{\DUrole{std,std-doc}{Code Styling Guidelines}}}}

\item {}
\sphinxAtStartPar
{\hyperref[\detokenize{CONTRIBUTING:setting-up-a-local-fagus-developing-environment}]{\sphinxcrossref{\DUrole{std,std-doc}{Setting Up A Local Fagus Developing Environment}}}}

\item {}
\sphinxAtStartPar
{\hyperref[\detokenize{CONTRIBUTING:submitting-pull-requests-for-fagus}]{\sphinxcrossref{\DUrole{std,std-doc}{Submitting Pull Requests For Fagus}}}}

\end{itemize}


\section{Fagus Principles}
\label{\detokenize{CONTRIBUTING:fagus-principles}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
\sphinxstylestrong{No external dependencies}: Fagus runs on native Python without 3rd party dependencies.

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Documented}: All functions / modules / arguments / classes have docstrings.

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Tested}: All the functions shall have tests for as many edge cases as possible. It’s never possible to imagine all edge\sphinxhyphen{}cases, but if e.g. a bug is fixed which there is no test for, a new test case should be added to prevent the bug from being reintroduced.

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Consistent}: Fagus’s function arguments follow a common structure to be as consistent as possible.

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Static and Instance}: All functions in Fagus (except from \_\_internals\_\_) should be able to run static \sphinxcode{\sphinxupquote{Fagus.function(obj)}} or at a Fagus\sphinxhyphen{}instance \sphinxcode{\sphinxupquote{obj = Fagus(); obj.function()}}.

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Simple and efficient}: If you have suggestions on how to make the code more efficient, feel free to submit.

\end{enumerate}


\section{How Can I Contribute?}
\label{\detokenize{CONTRIBUTING:how-can-i-contribute}}

\subsection{Reporting Bugs}
\label{\detokenize{CONTRIBUTING:reporting-bugs}}
\sphinxAtStartPar
This section guides you through submitting a bug report for Fagus. Following these guidelines helps maintainers and the community understand your report, reproduce the behavior, and find related reports.


\subsubsection{Before Submitting A Bug Report}
\label{\detokenize{CONTRIBUTING:before-submitting-a-bug-report}}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{Check the \sphinxhref{https://github.com/treeorg/Fagus/discussions/categories/q-a}{FAQ} and the \sphinxhref{https://github.com/treeorg/Fagus/discussions}{discussions}} for a list of common questions and problems.

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Check \sphinxhref{https://github.com/treeorg/Fagus/issues}{issues} to see if your issue has already been reported}
\begin{itemize}
\item {}
\sphinxAtStartPar
If it has been reported \sphinxstylestrong{and the issue is still open}, add a comment to the existing issue instead of opening a new one.

\item {}
\sphinxAtStartPar
If you find a \sphinxstylestrong{Closed} issue that seems like it is the same thing that you’re experiencing, open a new issue and include a link to the original issue in the body of your new one.

\end{itemize}

\end{itemize}


\subsubsection{How Do I Submit A (Good) Bug Report?}
\label{\detokenize{CONTRIBUTING:how-do-i-submit-a-good-bug-report}}
\sphinxAtStartPar
Bugs are tracked as \sphinxhref{https://guides.github.com/features/issues/}{GitHub issues}. When you are creating a bug report, please {\hyperref[\detokenize{CONTRIBUTING:how-do-i-submit-a-good-bug-report}]{\sphinxcrossref{\DUrole{std,std-doc}{include as many details as possible (in particular test\sphinxhyphen{}data)}}}}. Fill out \sphinxhref{https://github.com/treeorg/Fagus/issues/new?template=bug\_report.md}{the required template}, the information it asks for helps us resolve issues faster.


\subsection{Requesting New Features}
\label{\detokenize{CONTRIBUTING:requesting-new-features}}
\sphinxAtStartPar
This section guides you through submitting an enhancement suggestion for Fagus, including completely new features and minor improvements to existing functionality. Following these guidelines helps maintainers and the community understand your suggestion and find related suggestions.


\subsubsection{Before Submitting A Feature Request}
\label{\detokenize{CONTRIBUTING:before-submitting-a-feature-request}}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{Check the \sphinxhref{https://github.com/treeorg/Fagus/discussions/categories/q-a}{FAQ} and the \sphinxhref{https://github.com/treeorg/Fagus/discussions}{discussions}} for a list of common questions and problems. Probably there already is a solution for your feature\sphinxhyphen{}request?

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Check \sphinxhref{https://github.com/treeorg/Fagus/issues}{issues} to see if your feature request has already been reported}
\begin{itemize}
\item {}
\sphinxAtStartPar
If it has been reported \sphinxstylestrong{and the feature request is still open}, add a comment to the existing issue instead of opening a new one. You can also give it a like to get it prioritized.

\item {}
\sphinxAtStartPar
If you find a \sphinxstylestrong{Closed} feature request that seems like it is the same thing that you would like to get added, you can create a new one and include a link to the old one. If many people would like to have a new feature it is more likely to get prioritized.

\end{itemize}

\end{itemize}


\subsubsection{How Do I Submit A (Good) Feature Request?}
\label{\detokenize{CONTRIBUTING:how-do-i-submit-a-good-feature-request}}
\sphinxAtStartPar
Feature requests are tracked as \sphinxhref{https://guides.github.com/features/issues/}{GitHub issues}. When you are creating a feature request, please {\hyperref[\detokenize{CONTRIBUTING:how-do-i-submit-a-good-feature-request}]{\sphinxcrossref{\DUrole{std,std-doc}{include as many details as possible (in particular test\sphinxhyphen{}data)}}}}. Fill out \sphinxhref{https://github.com/treeorg/Fagus/issues/new?template=feature\_request.md}{the required template}, the information it asks for helps us to better judge and understand your suggestion.


\section{Developing Fagus}
\label{\detokenize{CONTRIBUTING:developing-fagus}}
\sphinxAtStartPar
This section shows you how you can set up a local environment to test and develop Fagus, and finally how you can make your contribution.


\subsection{Software Dependencies For Development}
\label{\detokenize{CONTRIBUTING:software-dependencies-for-development}}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxhref{https://www.python.org/}{Python} (at least 3.6.2)

\item {}
\sphinxAtStartPar
\sphinxhref{https://python-poetry.org}{Poetry} for dependency management and deployment (creating packages for PyPi), instructions are found in {\hyperref[\detokenize{CONTRIBUTING:setting-up-a-local-fagus-developing-environment}]{\sphinxcrossref{\DUrole{std,std-doc}{installation steps}}}}

\item {}
\sphinxAtStartPar
\sphinxhref{https://git-scm.com/}{Git} to checkout this repo

\item {}
\sphinxAtStartPar
An IDE, I used \sphinxhref{https://www.jetbrains.com/pycharm/download/}{Intellij PyCharm Community}. Not mandatory, but I found it handy to see how the data is modified in the debugger.

\item {}
\sphinxAtStartPar
Fagus itself has no external dependencies, but some packages are used to smoothen the development process. They are installed and set up through poetry, check \sphinxhref{https://github.com/treeorg/Fagus/blob/main/pyproject.toml}{pyproject.toml} or {\hyperref[\detokenize{CONTRIBUTING:code-styling-guidelines}]{\sphinxcrossref{\DUrole{std,std-doc}{Code Styling Rules}}}} for a list.

\end{itemize}


\subsection{Code Styling Guidelines}
\label{\detokenize{CONTRIBUTING:code-styling-guidelines}}\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{Code formatting}: The code is formatted using the \sphinxhref{https://peps.python.org/pep-0008/}{PEP\sphinxhyphen{}8\sphinxhyphen{}Standard}, but with a line length of 120 characters.
\begin{itemize}
\item {}
\sphinxAtStartPar
The code is automatically formatted correctly by using \sphinxhref{https://github.com/psf/black}{black}. Run \sphinxcode{\sphinxupquote{black .}} to ensure correct formatting for all py\sphinxhyphen{}files in the repo.

\item {}
\sphinxAtStartPar
The PEP\sphinxhyphen{}8\sphinxhyphen{}rules are verified through \sphinxhref{https://flake8.pycqa.org/en/latest/}{flake8}. This tool only shows what is wrong \sphinxhyphen{} you’ll have to fix it yourself.

\end{itemize}

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Docstrings}: All public functions in Fagus have docstrings following the \sphinxhref{https://google.github.io/styleguide/pyguide.html}{Google Python Style Guide}

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Formatting commit\sphinxhyphen{}messages}: \sphinxhref{https://commitizen-tools.github.io/commitizen/}{commitizen} is used to make sure that commit\sphinxhyphen{}messages follow a common style

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Pre\sphinxhyphen{}commit checks}: \sphinxhref{https://pre-commit.com/}{pre\sphinxhyphen{}commit} is used to ensure that the code changes have test\sphinxhyphen{}coverage, are formatted correctly etc. It runs black, flake8, unittests and a lot of other checks prior to accepting a commit.

\end{itemize}


\subsection{Setting Up A Local Fagus Developing Environment}
\label{\detokenize{CONTRIBUTING:setting-up-a-local-fagus-developing-environment}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
Install \sphinxhref{https://www.python.org/downloads/}{Python} and \sphinxhref{https://git-scm.com/}{Git}

\item {}
\sphinxAtStartPar
Checkout the repository: \sphinxcode{\sphinxupquote{git checkout https://github.com/treeorg/Fagus.git; cd Fagus}}

\item {}
\sphinxAtStartPar
Instructions how to install poetry can be found \sphinxhref{https://python-poetry.org/docs/}{here}
\begin{itemize}
\item {}
\sphinxAtStartPar
you might have to reopen your terminal after installing poetry (or run \sphinxcode{\sphinxupquote{source \textasciitilde{}/.bashrc}} on Linux)

\end{itemize}

\item {}
\sphinxAtStartPar
Run \sphinxcode{\sphinxupquote{poetry shell}} to open a terminal that is set up with the development tools for Fagus.
\begin{itemize}
\item {}
\sphinxAtStartPar
check if you can now run this command without getting errors: \sphinxcode{\sphinxupquote{poetry shell}}

\item {}
\sphinxAtStartPar
if the \sphinxcode{\sphinxupquote{poetry}}\sphinxhyphen{}command is not found, you might have to add \sphinxcode{\sphinxupquote{eval "\$(pyenv init \sphinxhyphen{}\sphinxhyphen{}path)"}} to your \sphinxcode{\sphinxupquote{.bashrc}} (on Linux)

\item {}
\sphinxAtStartPar
if you have problems setting this up, just ask a \sphinxhref{https://github.com/treeorg/Fagus/discussions/categories/q-a}{question}, we can later include the problem and the solution we found into this guide

\end{itemize}

\item {}
\sphinxAtStartPar
Install the project and developing dependencies: \sphinxcode{\sphinxupquote{poetry install}}

\item {}
\sphinxAtStartPar
If you use an IDE, you can now open your project there. If it has a poetry mode, use that mode \sphinxhyphen{} \sphinxcode{\sphinxupquote{poetry shell}} will then be executed automatically in the terminal of your IDE.

\end{enumerate}


\subsection{Submitting Pull Requests for Fagus}
\label{\detokenize{CONTRIBUTING:submitting-pull-requests-for-fagus}}
\sphinxAtStartPar
If it hasn’t run in your console yet, run \sphinxcode{\sphinxupquote{poetry shell}} to get all the development dependencies and some new commands available in your console.


\subsubsection{Tests}
\label{\detokenize{CONTRIBUTING:tests}}
\sphinxAtStartPar
You can run \sphinxcode{\sphinxupquote{python3 \sphinxhyphen{}m unittest discover}} to run all the tests in \sphinxcode{\sphinxupquote{./tests}}. If you add new functionality in your pull\sphinxhyphen{}request, make sure that the tests still work, or update them if necessary. As this is a generic library, it’s very important that all the functions have test coverage for as many edge cases as possible.


\subsubsection{Committing using pre\sphinxhyphen{}commit and commitizen}
\label{\detokenize{CONTRIBUTING:committing-using-pre-commit-and-commitizen}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
Make sure all your changes are staged for commit: \sphinxcode{\sphinxupquote{git add \sphinxhyphen{}A}} includes all of your changes

\item {}
\sphinxAtStartPar
Dry\sphinxhyphen{}run the pre\sphinxhyphen{}commit\sphinxhyphen{}checks: \sphinxcode{\sphinxupquote{pre\sphinxhyphen{}commit}}
\begin{itemize}
\item {}
\sphinxAtStartPar
Some errors like missing trailing whitespace or wrong formatting are automatically corrected.

\item {}
\sphinxAtStartPar
If there are errors in the tests, or flake8 observes problems, you’ll have to go back in the code and fix the problems.

\end{itemize}

\item {}
\sphinxAtStartPar
Repeat Step 1 and 2 until all the tests are green.

\item {}
\sphinxAtStartPar
Use \sphinxcode{\sphinxupquote{git cz c}} to commit using commitizen.
\begin{itemize}
\item {}
\sphinxAtStartPar
If the pre\sphinxhyphen{}commit\sphinxhyphen{}checks fail, your commit is rejected and after fixing the issues you’d have to retype the commit\sphinxhyphen{}message. To not have that problem, do step 3 beforehand.

\end{itemize}

\end{enumerate}


\subsubsection{Releasing A New Fagus Package on PyPi}
\label{\detokenize{CONTRIBUTING:releasing-a-new-fagus-package-on-pypi}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
Run \sphinxcode{\sphinxupquote{poetry version \textless{}major, minor or patch\textgreater{}}}to increment the version number in poetry.
\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstylestrong{Major}: For backwards incompatible changes (e.g. removing support for Python 3.6)

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Minor}: Adds functionality in a backwards compatible way

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Patch}: Fixes bugs in a backwards compatible way

\end{itemize}

\item {}
\sphinxAtStartPar
Run \sphinxcode{\sphinxupquote{sed \sphinxhyphen{}i "s/\_\_version\_\_ = .*\textbackslash{}\$/\_\_version\_\_ = \textbackslash{}"\$(poetry version \sphinxhyphen{}s)\textbackslash{}"/" fagus/\_\_init\_\_.py}} (only works on Linux / MacOS) to update the version number in the fagus\sphinxhyphen{}package. If you know the command to do this replacement in a windows shell, feel free to add it here.

\end{enumerate}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{f}
\item\relax\sphinxstyleindexentry{fagus}\sphinxstyleindexpageref{fagus:\detokenize{module-fagus}}
\item\relax\sphinxstyleindexentry{fagus.fagus}\sphinxstyleindexpageref{fagus.fagus:\detokenize{module-fagus.fagus}}
\item\relax\sphinxstyleindexentry{fagus.filters}\sphinxstyleindexpageref{fagus.filters:\detokenize{module-fagus.filters}}
\item\relax\sphinxstyleindexentry{fagus.iterators}\sphinxstyleindexpageref{fagus.iterators:\detokenize{module-fagus.iterators}}
\item\relax\sphinxstyleindexentry{fagus.utils}\sphinxstyleindexpageref{fagus.utils:\detokenize{module-fagus.utils}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
